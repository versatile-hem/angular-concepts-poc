{
  "version": 3,
  "sources": ["../../../../../node_modules/ts-invariant/lib/invariant.js", "../../../../../node_modules/@apollo/client/version.js", "../../../../../node_modules/@apollo/client/utilities/globals/maybe.js", "../../../../../node_modules/@apollo/client/utilities/globals/global.js", "../../../../../node_modules/@apollo/client/utilities/common/makeUniqueId.js", "../../../../../node_modules/@apollo/client/utilities/common/stringifyForDisplay.js", "../../../../../node_modules/@apollo/client/utilities/globals/invariantWrappers.js", "../../../../../node_modules/@apollo/client/utilities/globals/index.js", "../../../../../node_modules/@apollo/client/utilities/graphql/directives.js", "../../../../../node_modules/@wry/trie/lib/index.js", "../../../../../node_modules/@apollo/client/utilities/common/canUse.js", "../../../../../node_modules/@apollo/client/utilities/common/objects.js", "../../../../../node_modules/@apollo/client/utilities/graphql/fragments.js", "../../../../../node_modules/@apollo/client/utilities/graphql/storeUtils.js", "../../../../../node_modules/@apollo/client/utilities/graphql/getFromAST.js", "../../../../../node_modules/@apollo/client/utilities/graphql/DocumentTransform.js", "../../../../../node_modules/@apollo/client/utilities/graphql/print.js", "../../../../../node_modules/@apollo/client/utilities/common/arrays.js", "../../../../../node_modules/@apollo/client/utilities/graphql/transform.js", "../../../../../node_modules/@apollo/client/utilities/common/mergeDeep.js", "../../../../../node_modules/zen-observable-ts/module.js", "../../../../../node_modules/symbol-observable/es/ponyfill.js", "../../../../../node_modules/symbol-observable/es/index.js", "../../../../../node_modules/@apollo/client/utilities/observables/Observable.js", "../../../../../node_modules/@apollo/client/utilities/common/cloneDeep.js", "../../../../../node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js", "../../../../../node_modules/@apollo/client/utilities/observables/iteration.js", "../../../../../node_modules/@apollo/client/utilities/observables/asyncMap.js", "../../../../../node_modules/@apollo/client/utilities/observables/subclassing.js", "../../../../../node_modules/@apollo/client/utilities/observables/Concast.js", "../../../../../node_modules/@apollo/client/utilities/common/incrementalResult.js", "../../../../../node_modules/@apollo/client/utilities/common/errorHandling.js", "../../../../../node_modules/@apollo/client/utilities/common/compact.js", "../../../../../node_modules/@apollo/client/utilities/common/mergeOptions.js", "../../../../../node_modules/@apollo/client/link/utils/fromError.js", "../../../../../node_modules/@apollo/client/link/utils/toPromise.js", "../../../../../node_modules/@apollo/client/link/utils/fromPromise.js", "../../../../../node_modules/@apollo/client/link/utils/throwServerError.js", "../../../../../node_modules/@apollo/client/link/utils/validateOperation.js", "../../../../../node_modules/@apollo/client/link/utils/createOperation.js", "../../../../../node_modules/@apollo/client/link/utils/transformOperation.js", "../../../../../node_modules/@apollo/client/link/utils/filterOperationVariables.js", "../../../../../node_modules/@apollo/client/link/core/ApolloLink.js", "../../../../../node_modules/@apollo/client/link/core/empty.js", "../../../../../node_modules/@apollo/client/link/core/from.js", "../../../../../node_modules/@apollo/client/link/core/split.js", "../../../../../node_modules/@apollo/client/link/core/concat.js", "../../../../../node_modules/@apollo/client/link/core/execute.js", "../../../../../node_modules/@apollo/client/link/http/iterators/async.js", "../../../../../node_modules/@apollo/client/link/http/iterators/nodeStream.js", "../../../../../node_modules/@apollo/client/link/http/iterators/promise.js", "../../../../../node_modules/@apollo/client/link/http/iterators/reader.js", "../../../../../node_modules/@apollo/client/link/http/responseIterator.js", "../../../../../node_modules/@apollo/client/errors/index.js", "../../../../../node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js", "../../../../../node_modules/@apollo/client/link/http/serializeFetchParameter.js", "../../../../../node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js", "../../../../../node_modules/@apollo/client/link/http/checkFetcher.js", "../../../../../node_modules/@apollo/client/link/http/createSignalIfSupported.js", "../../../../../node_modules/@apollo/client/link/http/selectURI.js", "../../../../../node_modules/@apollo/client/link/http/rewriteURIForGET.js", "../../../../../node_modules/@apollo/client/link/http/createHttpLink.js", "../../../../../node_modules/@apollo/client/link/http/HttpLink.js", "../../../../../node_modules/@wry/equality/lib/index.js", "../../../../../node_modules/optimism/node_modules/@wry/trie/lib/index.js", "../../../../../node_modules/@wry/caches/lib/strong.js", "../../../../../node_modules/@wry/context/lib/slot.js", "../../../../../node_modules/@wry/context/lib/index.js", "../../../../../node_modules/optimism/lib/context.js", "../../../../../node_modules/optimism/lib/helpers.js", "../../../../../node_modules/optimism/lib/entry.js", "../../../../../node_modules/optimism/lib/dep.js", "../../../../../node_modules/optimism/lib/index.js", "../../../../../node_modules/@apollo/client/cache/core/cache.js", "../../../../../node_modules/@apollo/client/cache/core/types/Cache.js", "../../../../../node_modules/@apollo/client/cache/core/types/common.js", "../../../../../node_modules/@apollo/client/cache/inmemory/helpers.js", "../../../../../node_modules/@apollo/client/cache/inmemory/entityStore.js", "../../../../../node_modules/@apollo/client/cache/inmemory/object-canon.js", "../../../../../node_modules/@apollo/client/cache/inmemory/readFromStore.js", "../../../../../node_modules/@apollo/client/cache/inmemory/reactiveVars.js", "../../../../../node_modules/@apollo/client/cache/inmemory/key-extractor.js", "../../../../../node_modules/@apollo/client/cache/inmemory/policies.js", "../../../../../node_modules/@apollo/client/cache/inmemory/writeToStore.js", "../../../../../node_modules/@apollo/client/cache/inmemory/inMemoryCache.js", "../../../../../node_modules/@apollo/client/cache/inmemory/fragmentRegistry.js", "../../../../../node_modules/@apollo/client/core/networkStatus.js", "../../../../../node_modules/@apollo/client/core/equalByQuery.js", "../../../../../node_modules/@apollo/client/core/ObservableQuery.js", "../../../../../node_modules/@apollo/client/core/LocalState.js", "../../../../../node_modules/@apollo/client/core/QueryInfo.js", "../../../../../node_modules/@apollo/client/core/QueryManager.js", "../../../../../node_modules/@apollo/client/core/ApolloClient.js", "../../../../../node_modules/@apollo/client/core/index.js"],
  "sourcesContent": ["import { __extends } from \"tslib\";\nvar genericMessage = \"Invariant Violation\";\nvar _a = Object.setPrototypeOf, setPrototypeOf = _a === void 0 ? function (obj, proto) {\n    obj.__proto__ = proto;\n    return obj;\n} : _a;\nvar InvariantError = /** @class */ (function (_super) {\n    __extends(InvariantError, _super);\n    function InvariantError(message) {\n        if (message === void 0) { message = genericMessage; }\n        var _this = _super.call(this, typeof message === \"number\"\n            ? genericMessage + \": \" + message + \" (see https://github.com/apollographql/invariant-packages)\"\n            : message) || this;\n        _this.framesToPop = 1;\n        _this.name = genericMessage;\n        setPrototypeOf(_this, InvariantError.prototype);\n        return _this;\n    }\n    return InvariantError;\n}(Error));\nexport { InvariantError };\nexport function invariant(condition, message) {\n    if (!condition) {\n        throw new InvariantError(message);\n    }\n}\nvar verbosityLevels = [\"debug\", \"log\", \"warn\", \"error\", \"silent\"];\nvar verbosityLevel = verbosityLevels.indexOf(\"log\");\nfunction wrapConsoleMethod(name) {\n    return function () {\n        if (verbosityLevels.indexOf(name) >= verbosityLevel) {\n            // Default to console.log if this host environment happens not to provide\n            // all the console.* methods we need.\n            var method = console[name] || console.log;\n            return method.apply(console, arguments);\n        }\n    };\n}\n(function (invariant) {\n    invariant.debug = wrapConsoleMethod(\"debug\");\n    invariant.log = wrapConsoleMethod(\"log\");\n    invariant.warn = wrapConsoleMethod(\"warn\");\n    invariant.error = wrapConsoleMethod(\"error\");\n})(invariant || (invariant = {}));\nexport function setVerbosity(level) {\n    var old = verbosityLevels[verbosityLevel];\n    verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));\n    return old;\n}\nexport default invariant;\n", "export var version = \"3.8.10\";\n", "export function maybe(thunk) {\n    try {\n        return thunk();\n    }\n    catch (_a) { }\n}\n", "import { maybe } from \"./maybe.js\";\nexport default (maybe(function () { return globalThis; }) ||\n    maybe(function () { return window; }) ||\n    maybe(function () { return self; }) ||\n    maybe(function () { return global; }) || // We don't expect the Function constructor ever to be invoked at runtime, as\n// long as at least one of globalThis, window, self, or global is defined, so\n// we are under no obligation to make it easy for static analysis tools to\n// detect syntactic usage of the Function constructor. If you think you can\n// improve your static analysis to detect this obfuscation, think again. This\n// is an arms race you cannot win, at least not in JavaScript.\nmaybe(function () {\n    return maybe.constructor(\"return this\")();\n}));\n", "var prefixCounts = new Map();\n// These IDs won't be globally unique, but they will be unique within this\n// process, thanks to the counter, and unguessable thanks to the random suffix.\nexport function makeUniqueId(prefix) {\n    var count = prefixCounts.get(prefix) || 1;\n    prefixCounts.set(prefix, count + 1);\n    return \"\".concat(prefix, \":\").concat(count, \":\").concat(Math.random().toString(36).slice(2));\n}\n", "import { makeUniqueId } from \"./makeUniqueId.js\";\nexport function stringifyForDisplay(value, space) {\n    if (space === void 0) { space = 0; }\n    var undefId = makeUniqueId(\"stringifyForDisplay\");\n    return JSON.stringify(value, function (key, value) {\n        return value === void 0 ? undefId : value;\n    }, space)\n        .split(JSON.stringify(undefId))\n        .join(\"<undefined>\");\n}\n", "import { invariant as originalInvariant, InvariantError } from \"ts-invariant\";\nimport { version } from \"../../version.js\";\nimport global from \"./global.js\";\nimport { stringifyForDisplay } from \"../common/stringifyForDisplay.js\";\nfunction wrap(fn) {\n    return function (message) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        if (typeof message === \"number\") {\n            var arg0 = message;\n            message = getHandledErrorMsg(arg0);\n            if (!message) {\n                message = getFallbackErrorMsg(arg0, args);\n                args = [];\n            }\n        }\n        fn.apply(void 0, [message].concat(args));\n    };\n}\nvar invariant = Object.assign(function invariant(condition, message) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    if (!condition) {\n        originalInvariant(condition, getHandledErrorMsg(message, args) || getFallbackErrorMsg(message, args));\n    }\n}, {\n    debug: wrap(originalInvariant.debug),\n    log: wrap(originalInvariant.log),\n    warn: wrap(originalInvariant.warn),\n    error: wrap(originalInvariant.error),\n});\n/**\n * Returns an InvariantError.\n *\n * `message` can only be a string, a concatenation of strings, or a ternary statement\n * that results in a string. This will be enforced on build, where the message will\n * be replaced with a message number.\n * String substitutions with %s are supported and will also return\n * pretty-stringified objects.\n * Excess `optionalParams` will be swallowed.\n */\nfunction newInvariantError(message) {\n    var optionalParams = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        optionalParams[_i - 1] = arguments[_i];\n    }\n    return new InvariantError(getHandledErrorMsg(message, optionalParams) ||\n        getFallbackErrorMsg(message, optionalParams));\n}\nvar ApolloErrorMessageHandler = Symbol.for(\"ApolloErrorMessageHandler_\" + version);\nfunction stringify(arg) {\n    return typeof arg == \"string\" ? arg : (stringifyForDisplay(arg, 2).slice(0, 1000));\n}\nfunction getHandledErrorMsg(message, messageArgs) {\n    if (messageArgs === void 0) { messageArgs = []; }\n    if (!message)\n        return;\n    return (global[ApolloErrorMessageHandler] &&\n        global[ApolloErrorMessageHandler](message, messageArgs.map(stringify)));\n}\nfunction getFallbackErrorMsg(message, messageArgs) {\n    if (messageArgs === void 0) { messageArgs = []; }\n    if (!message)\n        return;\n    return \"An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#\".concat(encodeURIComponent(JSON.stringify({\n        version: version,\n        message: message,\n        args: messageArgs.map(stringify),\n    })));\n}\nexport { invariant, InvariantError, newInvariantError, ApolloErrorMessageHandler, };\n", "import { invariant, newInvariantError, InvariantError, } from \"./invariantWrappers.js\";\nexport { maybe } from \"./maybe.js\";\nexport { default as global } from \"./global.js\";\nexport { invariant, newInvariantError, InvariantError };\n/**\n * @deprecated we do not use this internally anymore,\n * it is just exported for backwards compatibility\n */\n// this file is extempt from automatic `__DEV__` replacement\n// so we have to write it out here\n// @ts-ignore\nexport var DEV = globalThis.__DEV__ !== false;\nexport { DEV as __DEV__ };\n", "import { invariant } from \"../globals/index.js\";\nimport { visit, BREAK } from \"graphql\";\nexport function shouldInclude(_a, variables) {\n    var directives = _a.directives;\n    if (!directives || !directives.length) {\n        return true;\n    }\n    return getInclusionDirectives(directives).every(function (_a) {\n        var directive = _a.directive, ifArgument = _a.ifArgument;\n        var evaledValue = false;\n        if (ifArgument.value.kind === \"Variable\") {\n            evaledValue =\n                variables && variables[ifArgument.value.name.value];\n            invariant(evaledValue !== void 0, 66, directive.name.value);\n        }\n        else {\n            evaledValue = ifArgument.value.value;\n        }\n        return directive.name.value === \"skip\" ? !evaledValue : evaledValue;\n    });\n}\nexport function getDirectiveNames(root) {\n    var names = [];\n    visit(root, {\n        Directive: function (node) {\n            names.push(node.name.value);\n        },\n    });\n    return names;\n}\nexport var hasAnyDirectives = function (names, root) {\n    return hasDirectives(names, root, false);\n};\nexport var hasAllDirectives = function (names, root) {\n    return hasDirectives(names, root, true);\n};\nexport function hasDirectives(names, root, all) {\n    var nameSet = new Set(names);\n    var uniqueCount = nameSet.size;\n    visit(root, {\n        Directive: function (node) {\n            if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {\n                return BREAK;\n            }\n        },\n    });\n    // If we found all the names, nameSet will be empty. If we only care about\n    // finding some of them, the < condition is sufficient.\n    return all ? !nameSet.size : nameSet.size < uniqueCount;\n}\nexport function hasClientExports(document) {\n    return document && hasDirectives([\"client\", \"export\"], document, true);\n}\nfunction isInclusionDirective(_a) {\n    var value = _a.name.value;\n    return value === \"skip\" || value === \"include\";\n}\nexport function getInclusionDirectives(directives) {\n    var result = [];\n    if (directives && directives.length) {\n        directives.forEach(function (directive) {\n            if (!isInclusionDirective(directive))\n                return;\n            var directiveArguments = directive.arguments;\n            var directiveName = directive.name.value;\n            invariant(directiveArguments && directiveArguments.length === 1, 67, directiveName);\n            var ifArgument = directiveArguments[0];\n            invariant(ifArgument.name && ifArgument.name.value === \"if\", 68, directiveName);\n            var ifValue = ifArgument.value;\n            // means it has to be a variable value if this is a valid @skip or @include directive\n            invariant(ifValue &&\n                (ifValue.kind === \"Variable\" || ifValue.kind === \"BooleanValue\"), 69, directiveName);\n            result.push({ directive: directive, ifArgument: ifArgument });\n        });\n    }\n    return result;\n}\n", "// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\nconst { hasOwnProperty } = Object.prototype;\nexport class Trie {\n    constructor(weakness = true, makeData = defaultMakeData) {\n        this.weakness = weakness;\n        this.makeData = makeData;\n    }\n    lookup() {\n        return this.lookupArray(arguments);\n    }\n    lookupArray(array) {\n        let node = this;\n        forEach.call(array, key => node = node.getChildTrie(key));\n        return hasOwnProperty.call(node, \"data\")\n            ? node.data\n            : node.data = this.makeData(slice.call(array));\n    }\n    peek() {\n        return this.peekArray(arguments);\n    }\n    peekArray(array) {\n        let node = this;\n        for (let i = 0, len = array.length; node && i < len; ++i) {\n            const map = node.mapFor(array[i], false);\n            node = map && map.get(array[i]);\n        }\n        return node && node.data;\n    }\n    remove() {\n        return this.removeArray(arguments);\n    }\n    removeArray(array) {\n        let data;\n        if (array.length) {\n            const head = array[0];\n            const map = this.mapFor(head, false);\n            const child = map && map.get(head);\n            if (child) {\n                data = child.removeArray(slice.call(array, 1));\n                if (!child.data && !child.weak && !(child.strong && child.strong.size)) {\n                    map.delete(head);\n                }\n            }\n        }\n        else {\n            data = this.data;\n            delete this.data;\n        }\n        return data;\n    }\n    getChildTrie(key) {\n        const map = this.mapFor(key, true);\n        let child = map.get(key);\n        if (!child)\n            map.set(key, child = new Trie(this.weakness, this.makeData));\n        return child;\n    }\n    mapFor(key, create) {\n        return this.weakness && isObjRef(key)\n            ? this.weak || (create ? this.weak = new WeakMap : void 0)\n            : this.strong || (create ? this.strong = new Map : void 0);\n    }\n}\nfunction isObjRef(value) {\n    switch (typeof value) {\n        case \"object\":\n            if (value === null)\n                break;\n        // Fall through to return true...\n        case \"function\":\n            return true;\n    }\n    return false;\n}\n", "import { maybe } from \"../globals/index.js\";\nexport var canUseWeakMap = typeof WeakMap === \"function\" &&\n    maybe(function () { return navigator.product; }) !== \"ReactNative\";\nexport var canUseWeakSet = typeof WeakSet === \"function\";\nexport var canUseSymbol = typeof Symbol === \"function\" && typeof Symbol.for === \"function\";\nexport var canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;\nexport var canUseDOM = typeof maybe(function () { return window.document.createElement; }) === \"function\";\nvar usingJSDOM = \n// Following advice found in this comment from @domenic (maintainer of jsdom):\n// https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327\n//\n// Since we control the version of Jest and jsdom used when running Apollo\n// Client tests, and that version is recent enought to include \" jsdom/x.y.z\"\n// at the end of the user agent string, I believe this case is all we need to\n// check. Testing for \"Node.js\" was recommended for backwards compatibility\n// with older version of jsdom, but we don't have that problem.\nmaybe(function () { return navigator.userAgent.indexOf(\"jsdom\") >= 0; }) || false;\n// Our tests should all continue to pass if we remove this !usingJSDOM\n// condition, thereby allowing useLayoutEffect when using jsdom. Unfortunately,\n// if we allow useLayoutEffect, then useSyncExternalStore generates many\n// warnings about useLayoutEffect doing nothing on the server. While these\n// warnings are harmless, this !usingJSDOM condition seems to be the best way to\n// prevent them (i.e. skipping useLayoutEffect when using jsdom).\nexport var canUseLayoutEffect = canUseDOM && !usingJSDOM;\n", "export function isNonNullObject(obj) {\n    return obj !== null && typeof obj === \"object\";\n}\nexport function isPlainObject(obj) {\n    return (obj !== null &&\n        typeof obj === \"object\" &&\n        (Object.getPrototypeOf(obj) === Object.prototype ||\n            Object.getPrototypeOf(obj) === null));\n}\n", "import { __assign, __spreadArray } from \"tslib\";\nimport { invariant, newInvariantError } from \"../globals/index.js\";\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo { a b c }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * { ...foo }\n *\n * fragment foo on Foo { a b c }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more than one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n */\nexport function getFragmentQueryDocument(document, fragmentName) {\n    var actualFragmentName = fragmentName;\n    // Build an array of all our fragment definitions that will be used for\n    // validations. We also do some validations on the other definitions in the\n    // document while building this list.\n    var fragments = [];\n    document.definitions.forEach(function (definition) {\n        // Throw an error if we encounter an operation definition because we will\n        // define our own operation definition later on.\n        if (definition.kind === \"OperationDefinition\") {\n            throw newInvariantError(\n                70,\n                definition.operation,\n                definition.name ? \" named '\".concat(definition.name.value, \"'\") : \"\"\n            );\n        }\n        // Add our definition to the fragments array if it is a fragment\n        // definition.\n        if (definition.kind === \"FragmentDefinition\") {\n            fragments.push(definition);\n        }\n    });\n    // If the user did not give us a fragment name then let us try to get a\n    // name from a single fragment in the definition.\n    if (typeof actualFragmentName === \"undefined\") {\n        invariant(fragments.length === 1, 71, fragments.length);\n        actualFragmentName = fragments[0].name.value;\n    }\n    // Generate a query document with an operation that simply spreads the\n    // fragment inside of it.\n    var query = __assign(__assign({}, document), { definitions: __spreadArray([\n            {\n                kind: \"OperationDefinition\",\n                // OperationTypeNode is an enum\n                operation: \"query\",\n                selectionSet: {\n                    kind: \"SelectionSet\",\n                    selections: [\n                        {\n                            kind: \"FragmentSpread\",\n                            name: {\n                                kind: \"Name\",\n                                value: actualFragmentName,\n                            },\n                        },\n                    ],\n                },\n            }\n        ], document.definitions, true) });\n    return query;\n}\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(fragments) {\n    if (fragments === void 0) { fragments = []; }\n    var symTable = {};\n    fragments.forEach(function (fragment) {\n        symTable[fragment.name.value] = fragment;\n    });\n    return symTable;\n}\nexport function getFragmentFromSelection(selection, fragmentMap) {\n    switch (selection.kind) {\n        case \"InlineFragment\":\n            return selection;\n        case \"FragmentSpread\": {\n            var fragmentName = selection.name.value;\n            if (typeof fragmentMap === \"function\") {\n                return fragmentMap(fragmentName);\n            }\n            var fragment = fragmentMap && fragmentMap[fragmentName];\n            invariant(fragment, 72, fragmentName);\n            return fragment || null;\n        }\n        default:\n            return null;\n    }\n}\n", "import { newInvariantError } from \"../globals/index.js\";\nimport { isNonNullObject } from \"../common/objects.js\";\nimport { getFragmentFromSelection } from \"./fragments.js\";\nexport function makeReference(id) {\n    return { __ref: String(id) };\n}\nexport function isReference(obj) {\n    return Boolean(obj && typeof obj === \"object\" && typeof obj.__ref === \"string\");\n}\nexport function isDocumentNode(value) {\n    return (isNonNullObject(value) &&\n        value.kind === \"Document\" &&\n        Array.isArray(value.definitions));\n}\nfunction isStringValue(value) {\n    return value.kind === \"StringValue\";\n}\nfunction isBooleanValue(value) {\n    return value.kind === \"BooleanValue\";\n}\nfunction isIntValue(value) {\n    return value.kind === \"IntValue\";\n}\nfunction isFloatValue(value) {\n    return value.kind === \"FloatValue\";\n}\nfunction isVariable(value) {\n    return value.kind === \"Variable\";\n}\nfunction isObjectValue(value) {\n    return value.kind === \"ObjectValue\";\n}\nfunction isListValue(value) {\n    return value.kind === \"ListValue\";\n}\nfunction isEnumValue(value) {\n    return value.kind === \"EnumValue\";\n}\nfunction isNullValue(value) {\n    return value.kind === \"NullValue\";\n}\nexport function valueToObjectRepresentation(argObj, name, value, variables) {\n    if (isIntValue(value) || isFloatValue(value)) {\n        argObj[name.value] = Number(value.value);\n    }\n    else if (isBooleanValue(value) || isStringValue(value)) {\n        argObj[name.value] = value.value;\n    }\n    else if (isObjectValue(value)) {\n        var nestedArgObj_1 = {};\n        value.fields.map(function (obj) {\n            return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);\n        });\n        argObj[name.value] = nestedArgObj_1;\n    }\n    else if (isVariable(value)) {\n        var variableValue = (variables || {})[value.name.value];\n        argObj[name.value] = variableValue;\n    }\n    else if (isListValue(value)) {\n        argObj[name.value] = value.values.map(function (listValue) {\n            var nestedArgArrayObj = {};\n            valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);\n            return nestedArgArrayObj[name.value];\n        });\n    }\n    else if (isEnumValue(value)) {\n        argObj[name.value] = value.value;\n    }\n    else if (isNullValue(value)) {\n        argObj[name.value] = null;\n    }\n    else {\n        throw newInvariantError(81, name.value, value.kind);\n    }\n}\nexport function storeKeyNameFromField(field, variables) {\n    var directivesObj = null;\n    if (field.directives) {\n        directivesObj = {};\n        field.directives.forEach(function (directive) {\n            directivesObj[directive.name.value] = {};\n            if (directive.arguments) {\n                directive.arguments.forEach(function (_a) {\n                    var name = _a.name, value = _a.value;\n                    return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);\n                });\n            }\n        });\n    }\n    var argObj = null;\n    if (field.arguments && field.arguments.length) {\n        argObj = {};\n        field.arguments.forEach(function (_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj, name, value, variables);\n        });\n    }\n    return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\nvar KNOWN_DIRECTIVES = [\n    \"connection\",\n    \"include\",\n    \"skip\",\n    \"client\",\n    \"rest\",\n    \"export\",\n    \"nonreactive\",\n];\nexport var getStoreKeyName = Object.assign(function (fieldName, args, directives) {\n    if (args &&\n        directives &&\n        directives[\"connection\"] &&\n        directives[\"connection\"][\"key\"]) {\n        if (directives[\"connection\"][\"filter\"] &&\n            directives[\"connection\"][\"filter\"].length > 0) {\n            var filterKeys = directives[\"connection\"][\"filter\"] ?\n                directives[\"connection\"][\"filter\"]\n                : [];\n            filterKeys.sort();\n            var filteredArgs_1 = {};\n            filterKeys.forEach(function (key) {\n                filteredArgs_1[key] = args[key];\n            });\n            return \"\".concat(directives[\"connection\"][\"key\"], \"(\").concat(stringify(filteredArgs_1), \")\");\n        }\n        else {\n            return directives[\"connection\"][\"key\"];\n        }\n    }\n    var completeFieldName = fieldName;\n    if (args) {\n        // We can't use `JSON.stringify` here since it's non-deterministic,\n        // and can lead to different store key names being created even though\n        // the `args` object used during creation has the same properties/values.\n        var stringifiedArgs = stringify(args);\n        completeFieldName += \"(\".concat(stringifiedArgs, \")\");\n    }\n    if (directives) {\n        Object.keys(directives).forEach(function (key) {\n            if (KNOWN_DIRECTIVES.indexOf(key) !== -1)\n                return;\n            if (directives[key] && Object.keys(directives[key]).length) {\n                completeFieldName += \"@\".concat(key, \"(\").concat(stringify(directives[key]), \")\");\n            }\n            else {\n                completeFieldName += \"@\".concat(key);\n            }\n        });\n    }\n    return completeFieldName;\n}, {\n    setStringify: function (s) {\n        var previous = stringify;\n        stringify = s;\n        return previous;\n    },\n});\n// Default stable JSON.stringify implementation. Can be updated/replaced with\n// something better by calling getStoreKeyName.setStringify.\nvar stringify = function defaultStringify(value) {\n    return JSON.stringify(value, stringifyReplacer);\n};\nfunction stringifyReplacer(_key, value) {\n    if (isNonNullObject(value) && !Array.isArray(value)) {\n        value = Object.keys(value)\n            .sort()\n            .reduce(function (copy, key) {\n            copy[key] = value[key];\n            return copy;\n        }, {});\n    }\n    return value;\n}\nexport function argumentsObjectFromField(field, variables) {\n    if (field.arguments && field.arguments.length) {\n        var argObj_1 = {};\n        field.arguments.forEach(function (_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj_1, name, value, variables);\n        });\n        return argObj_1;\n    }\n    return null;\n}\nexport function resultKeyNameFromField(field) {\n    return field.alias ? field.alias.value : field.name.value;\n}\nexport function getTypenameFromResult(result, selectionSet, fragmentMap) {\n    var fragments;\n    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {\n        var selection = _a[_i];\n        if (isField(selection)) {\n            if (selection.name.value === \"__typename\") {\n                return result[resultKeyNameFromField(selection)];\n            }\n        }\n        else if (fragments) {\n            fragments.push(selection);\n        }\n        else {\n            fragments = [selection];\n        }\n    }\n    if (typeof result.__typename === \"string\") {\n        return result.__typename;\n    }\n    if (fragments) {\n        for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {\n            var selection = fragments_1[_b];\n            var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);\n            if (typeof typename === \"string\") {\n                return typename;\n            }\n        }\n    }\n}\nexport function isField(selection) {\n    return selection.kind === \"Field\";\n}\nexport function isInlineFragment(selection) {\n    return selection.kind === \"InlineFragment\";\n}\n", "import { invariant, newInvariantError } from \"../globals/index.js\";\nimport { valueToObjectRepresentation } from \"./storeUtils.js\";\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc) {\n    invariant(doc && doc.kind === \"Document\", 73);\n    var operations = doc.definitions\n        .filter(function (d) { return d.kind !== \"FragmentDefinition\"; })\n        .map(function (definition) {\n        if (definition.kind !== \"OperationDefinition\") {\n            throw newInvariantError(74, definition.kind);\n        }\n        return definition;\n    });\n    invariant(operations.length <= 1, 75, operations.length);\n    return doc;\n}\nexport function getOperationDefinition(doc) {\n    checkDocument(doc);\n    return doc.definitions.filter(function (definition) {\n        return definition.kind === \"OperationDefinition\";\n    })[0];\n}\nexport function getOperationName(doc) {\n    return (doc.definitions\n        .filter(function (definition) {\n        return definition.kind === \"OperationDefinition\" && !!definition.name;\n    })\n        .map(function (x) { return x.name.value; })[0] || null);\n}\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(doc) {\n    return doc.definitions.filter(function (definition) {\n        return definition.kind === \"FragmentDefinition\";\n    });\n}\nexport function getQueryDefinition(doc) {\n    var queryDef = getOperationDefinition(doc);\n    invariant(queryDef && queryDef.operation === \"query\", 76);\n    return queryDef;\n}\nexport function getFragmentDefinition(doc) {\n    invariant(doc.kind === \"Document\", 77);\n    invariant(doc.definitions.length <= 1, 78);\n    var fragmentDef = doc.definitions[0];\n    invariant(fragmentDef.kind === \"FragmentDefinition\", 79);\n    return fragmentDef;\n}\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(queryDoc) {\n    checkDocument(queryDoc);\n    var fragmentDefinition;\n    for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {\n        var definition = _a[_i];\n        if (definition.kind === \"OperationDefinition\") {\n            var operation = definition.operation;\n            if (operation === \"query\" ||\n                operation === \"mutation\" ||\n                operation === \"subscription\") {\n                return definition;\n            }\n        }\n        if (definition.kind === \"FragmentDefinition\" && !fragmentDefinition) {\n            // we do this because we want to allow multiple fragment definitions\n            // to precede an operation definition.\n            fragmentDefinition = definition;\n        }\n    }\n    if (fragmentDefinition) {\n        return fragmentDefinition;\n    }\n    throw newInvariantError(80);\n}\nexport function getDefaultValues(definition) {\n    var defaultValues = Object.create(null);\n    var defs = definition && definition.variableDefinitions;\n    if (defs && defs.length) {\n        defs.forEach(function (def) {\n            if (def.defaultValue) {\n                valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);\n            }\n        });\n    }\n    return defaultValues;\n}\n", "import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\nfunction identity(document) {\n    return document;\n}\nvar DocumentTransform = /** @class */ (function () {\n    function DocumentTransform(transform, options) {\n        if (options === void 0) { options = Object.create(null); }\n        this.resultCache = canUseWeakSet ? new WeakSet() : new Set();\n        this.transform = transform;\n        if (options.getCacheKey) {\n            // Override default `getCacheKey` function, which returns [document].\n            this.getCacheKey = options.getCacheKey;\n        }\n        if (options.cache !== false) {\n            this.stableCacheKeys = new Trie(canUseWeakMap, function (key) { return ({ key: key }); });\n        }\n    }\n    // This default implementation of getCacheKey can be overridden by providing\n    // options.getCacheKey to the DocumentTransform constructor. In general, a\n    // getCacheKey function may either return an array of keys (often including\n    // the document) to be used as a cache key, or undefined to indicate the\n    // transform for this document should not be cached.\n    DocumentTransform.prototype.getCacheKey = function (document) {\n        return [document];\n    };\n    DocumentTransform.identity = function () {\n        // No need to cache this transform since it just returns the document\n        // unchanged. This should save a bit of memory that would otherwise be\n        // needed to populate the `documentCache` of this transform.\n        return new DocumentTransform(identity, { cache: false });\n    };\n    DocumentTransform.split = function (predicate, left, right) {\n        if (right === void 0) { right = DocumentTransform.identity(); }\n        return new DocumentTransform(function (document) {\n            var documentTransform = predicate(document) ? left : right;\n            return documentTransform.transformDocument(document);\n        }, \n        // Reasonably assume both `left` and `right` transforms handle their own caching\n        { cache: false });\n    };\n    DocumentTransform.prototype.transformDocument = function (document) {\n        // If a user passes an already transformed result back to this function,\n        // immediately return it.\n        if (this.resultCache.has(document)) {\n            return document;\n        }\n        var cacheEntry = this.getStableCacheEntry(document);\n        if (cacheEntry && cacheEntry.value) {\n            return cacheEntry.value;\n        }\n        checkDocument(document);\n        var transformedDocument = this.transform(document);\n        this.resultCache.add(transformedDocument);\n        if (cacheEntry) {\n            cacheEntry.value = transformedDocument;\n        }\n        return transformedDocument;\n    };\n    DocumentTransform.prototype.concat = function (otherTransform) {\n        var _this = this;\n        return new DocumentTransform(function (document) {\n            return otherTransform.transformDocument(_this.transformDocument(document));\n        }, \n        // Reasonably assume both transforms handle their own caching\n        { cache: false });\n    };\n    DocumentTransform.prototype.getStableCacheEntry = function (document) {\n        if (!this.stableCacheKeys)\n            return;\n        var cacheKeys = this.getCacheKey(document);\n        if (cacheKeys) {\n            invariant(Array.isArray(cacheKeys), 65);\n            return this.stableCacheKeys.lookupArray(cacheKeys);\n        }\n    };\n    return DocumentTransform;\n}());\nexport { DocumentTransform };\n", "import { print as origPrint } from \"graphql\";\nimport { canUseWeakMap } from \"../common/canUse.js\";\nvar printCache = canUseWeakMap ? new WeakMap() : undefined;\nexport var print = function (ast) {\n    var result;\n    result = printCache === null || printCache === void 0 ? void 0 : printCache.get(ast);\n    if (!result) {\n        result = origPrint(ast);\n        printCache === null || printCache === void 0 ? void 0 : printCache.set(ast, result);\n    }\n    return result;\n};\n", "// A version of Array.isArray that works better with readonly arrays.\nexport var isArray = Array.isArray;\nexport function isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\n", "import { __assign, __spreadArray } from \"tslib\";\nimport { invariant } from \"../globals/index.js\";\nimport { visit, Kind } from \"graphql\";\nimport { checkDocument, getOperationDefinition, getFragmentDefinition, getFragmentDefinitions, getMainDefinition, } from \"./getFromAST.js\";\nimport { isField } from \"./storeUtils.js\";\nimport { createFragmentMap } from \"./fragments.js\";\nimport { isArray, isNonEmptyArray } from \"../common/arrays.js\";\nvar TYPENAME_FIELD = {\n    kind: Kind.FIELD,\n    name: {\n        kind: Kind.NAME,\n        value: \"__typename\",\n    },\n};\nfunction isEmpty(op, fragmentMap) {\n    return (!op ||\n        op.selectionSet.selections.every(function (selection) {\n            return selection.kind === Kind.FRAGMENT_SPREAD &&\n                isEmpty(fragmentMap[selection.name.value], fragmentMap);\n        }));\n}\nfunction nullIfDocIsEmpty(doc) {\n    return (isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc)))) ?\n        null\n        : doc;\n}\nfunction getDirectiveMatcher(configs) {\n    var names = new Map();\n    var tests = new Map();\n    configs.forEach(function (directive) {\n        if (directive) {\n            if (directive.name) {\n                names.set(directive.name, directive);\n            }\n            else if (directive.test) {\n                tests.set(directive.test, directive);\n            }\n        }\n    });\n    return function (directive) {\n        var config = names.get(directive.name.value);\n        if (!config && tests.size) {\n            tests.forEach(function (testConfig, test) {\n                if (test(directive)) {\n                    config = testConfig;\n                }\n            });\n        }\n        return config;\n    };\n}\nfunction makeInUseGetterFunction(defaultKey) {\n    var map = new Map();\n    return function inUseGetterFunction(key) {\n        if (key === void 0) { key = defaultKey; }\n        var inUse = map.get(key);\n        if (!inUse) {\n            map.set(key, (inUse = {\n                // Variable and fragment spread names used directly within this\n                // operation or fragment definition, as identified by key. These sets\n                // will be populated during the first traversal of the document in\n                // removeDirectivesFromDocument below.\n                variables: new Set(),\n                fragmentSpreads: new Set(),\n            }));\n        }\n        return inUse;\n    };\n}\nexport function removeDirectivesFromDocument(directives, doc) {\n    checkDocument(doc);\n    // Passing empty strings to makeInUseGetterFunction means we handle anonymous\n    // operations as if their names were \"\". Anonymous fragment definitions are\n    // not supposed to be possible, but the same default naming strategy seems\n    // appropriate for that case as well.\n    var getInUseByOperationName = makeInUseGetterFunction(\"\");\n    var getInUseByFragmentName = makeInUseGetterFunction(\"\");\n    var getInUse = function (ancestors) {\n        for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {\n            if (isArray(ancestor))\n                continue;\n            if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n                // If an operation is anonymous, we use the empty string as its key.\n                return getInUseByOperationName(ancestor.name && ancestor.name.value);\n            }\n            if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n                return getInUseByFragmentName(ancestor.name.value);\n            }\n        }\n        globalThis.__DEV__ !== false && invariant.error(82);\n        return null;\n    };\n    var operationCount = 0;\n    for (var i = doc.definitions.length - 1; i >= 0; --i) {\n        if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n            ++operationCount;\n        }\n    }\n    var directiveMatcher = getDirectiveMatcher(directives);\n    var shouldRemoveField = function (nodeDirectives) {\n        return isNonEmptyArray(nodeDirectives) &&\n            nodeDirectives\n                .map(directiveMatcher)\n                .some(function (config) { return config && config.remove; });\n    };\n    var originalFragmentDefsByPath = new Map();\n    // Any time the first traversal of the document below makes a change like\n    // removing a fragment (by returning null), this variable should be set to\n    // true. Once it becomes true, it should never be set to false again. If this\n    // variable remains false throughout the traversal, then we can return the\n    // original doc immediately without any modifications.\n    var firstVisitMadeChanges = false;\n    var fieldOrInlineFragmentVisitor = {\n        enter: function (node) {\n            if (shouldRemoveField(node.directives)) {\n                firstVisitMadeChanges = true;\n                return null;\n            }\n        },\n    };\n    var docWithoutDirectiveSubtrees = visit(doc, {\n        // These two AST node types share the same implementation, defined above.\n        Field: fieldOrInlineFragmentVisitor,\n        InlineFragment: fieldOrInlineFragmentVisitor,\n        VariableDefinition: {\n            enter: function () {\n                // VariableDefinition nodes do not count as variables in use, though\n                // they do contain Variable nodes that might be visited below. To avoid\n                // counting variable declarations as usages, we skip visiting the\n                // contents of this VariableDefinition node by returning false.\n                return false;\n            },\n        },\n        Variable: {\n            enter: function (node, _key, _parent, _path, ancestors) {\n                var inUse = getInUse(ancestors);\n                if (inUse) {\n                    inUse.variables.add(node.name.value);\n                }\n            },\n        },\n        FragmentSpread: {\n            enter: function (node, _key, _parent, _path, ancestors) {\n                if (shouldRemoveField(node.directives)) {\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n                var inUse = getInUse(ancestors);\n                if (inUse) {\n                    inUse.fragmentSpreads.add(node.name.value);\n                }\n                // We might like to remove this FragmentSpread by returning null here if\n                // the corresponding FragmentDefinition node is also going to be removed\n                // by the logic below, but we can't control the relative order of those\n                // events, so we have to postpone the removal of dangling FragmentSpread\n                // nodes until after the current visit of the document has finished.\n            },\n        },\n        FragmentDefinition: {\n            enter: function (node, _key, _parent, path) {\n                originalFragmentDefsByPath.set(JSON.stringify(path), node);\n            },\n            leave: function (node, _key, _parent, path) {\n                var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));\n                if (node === originalNode) {\n                    // If the FragmentNode received by this leave function is identical to\n                    // the one received by the corresponding enter function (above), then\n                    // the visitor must not have made any changes within this\n                    // FragmentDefinition node. This fragment definition may still be\n                    // removed if there are no ...spread references to it, but it won't be\n                    // removed just because it has only a __typename field.\n                    return node;\n                }\n                if (\n                // This logic applies only if the document contains one or more\n                // operations, since removing all fragments from a document containing\n                // only fragments makes the document useless.\n                operationCount > 0 &&\n                    node.selectionSet.selections.every(function (selection) {\n                        return selection.kind === Kind.FIELD &&\n                            selection.name.value === \"__typename\";\n                    })) {\n                    // This is a somewhat opinionated choice: if a FragmentDefinition ends\n                    // up having no fields other than __typename, we remove the whole\n                    // fragment definition, and later prune ...spread references to it.\n                    getInUseByFragmentName(node.name.value).removed = true;\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n            },\n        },\n        Directive: {\n            leave: function (node) {\n                // If a matching directive is found, remove the directive itself. Note\n                // that this does not remove the target (field, argument, etc) of the\n                // directive, but only the directive itself.\n                if (directiveMatcher(node)) {\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n            },\n        },\n    });\n    if (!firstVisitMadeChanges) {\n        // If our first pass did not change anything about the document, then there\n        // is no cleanup we need to do, and we can return the original doc.\n        return doc;\n    }\n    // Utility for making sure inUse.transitiveVars is recursively populated.\n    // Because this logic assumes inUse.fragmentSpreads has been completely\n    // populated and inUse.removed has been set if appropriate,\n    // populateTransitiveVars must be called after that information has been\n    // collected by the first traversal of the document.\n    var populateTransitiveVars = function (inUse) {\n        if (!inUse.transitiveVars) {\n            inUse.transitiveVars = new Set(inUse.variables);\n            if (!inUse.removed) {\n                inUse.fragmentSpreads.forEach(function (childFragmentName) {\n                    populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function (varName) {\n                        inUse.transitiveVars.add(varName);\n                    });\n                });\n            }\n        }\n        return inUse;\n    };\n    // Since we've been keeping track of fragment spreads used by particular\n    // operations and fragment definitions, we now need to compute the set of all\n    // spreads used (transitively) by any operations in the document.\n    var allFragmentNamesUsed = new Set();\n    docWithoutDirectiveSubtrees.definitions.forEach(function (def) {\n        if (def.kind === Kind.OPERATION_DEFINITION) {\n            populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function (childFragmentName) {\n                allFragmentNamesUsed.add(childFragmentName);\n            });\n        }\n        else if (def.kind === Kind.FRAGMENT_DEFINITION &&\n            // If there are no operations in the document, then all fragment\n            // definitions count as usages of their own fragment names. This heuristic\n            // prevents accidentally removing all fragment definitions from the\n            // document just because it contains no operations that use the fragments.\n            operationCount === 0 &&\n            !getInUseByFragmentName(def.name.value).removed) {\n            allFragmentNamesUsed.add(def.name.value);\n        }\n    });\n    // Now that we have added all fragment spreads used by operations to the\n    // allFragmentNamesUsed set, we can complete the set by transitively adding\n    // all fragment spreads used by those fragments, and so on.\n    allFragmentNamesUsed.forEach(function (fragmentName) {\n        // Once all the childFragmentName strings added here have been seen already,\n        // the top-level allFragmentNamesUsed.forEach loop will terminate.\n        populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function (childFragmentName) {\n            allFragmentNamesUsed.add(childFragmentName);\n        });\n    });\n    var fragmentWillBeRemoved = function (fragmentName) {\n        return !!(\n        // A fragment definition will be removed if there are no spreads that refer\n        // to it, or the fragment was explicitly removed because it had no fields\n        // other than __typename.\n        (!allFragmentNamesUsed.has(fragmentName) ||\n            getInUseByFragmentName(fragmentName).removed));\n    };\n    var enterVisitor = {\n        enter: function (node) {\n            if (fragmentWillBeRemoved(node.name.value)) {\n                return null;\n            }\n        },\n    };\n    return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {\n        // If the fragment is going to be removed, then leaving any dangling\n        // FragmentSpread nodes with the same name would be a mistake.\n        FragmentSpread: enterVisitor,\n        // This is where the fragment definition is actually removed.\n        FragmentDefinition: enterVisitor,\n        OperationDefinition: {\n            leave: function (node) {\n                // Upon leaving each operation in the depth-first AST traversal, prune\n                // any variables that are declared by the operation but unused within.\n                if (node.variableDefinitions) {\n                    var usedVariableNames_1 = populateTransitiveVars(\n                    // If an operation is anonymous, we use the empty string as its key.\n                    getInUseByOperationName(node.name && node.name.value)).transitiveVars;\n                    // According to the GraphQL spec, all variables declared by an\n                    // operation must either be used by that operation or used by some\n                    // fragment included transitively into that operation:\n                    // https://spec.graphql.org/draft/#sec-All-Variables-Used\n                    //\n                    // To stay on the right side of this validation rule, if/when we\n                    // remove the last $var references from an operation or its fragments,\n                    // we must also remove the corresponding $var declaration from the\n                    // enclosing operation. This pruning applies only to operations and\n                    // not fragment definitions, at the moment. Fragments may be able to\n                    // declare variables eventually, but today they can only consume them.\n                    if (usedVariableNames_1.size < node.variableDefinitions.length) {\n                        return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function (varDef) {\n                                return usedVariableNames_1.has(varDef.variable.name.value);\n                            }) });\n                    }\n                }\n            },\n        },\n    }));\n}\nexport var addTypenameToDocument = Object.assign(function (doc) {\n    return visit(doc, {\n        SelectionSet: {\n            enter: function (node, _key, parent) {\n                // Don't add __typename to OperationDefinitions.\n                if (parent &&\n                    parent.kind ===\n                        Kind.OPERATION_DEFINITION) {\n                    return;\n                }\n                // No changes if no selections.\n                var selections = node.selections;\n                if (!selections) {\n                    return;\n                }\n                // If selections already have a __typename, or are part of an\n                // introspection query, do nothing.\n                var skip = selections.some(function (selection) {\n                    return (isField(selection) &&\n                        (selection.name.value === \"__typename\" ||\n                            selection.name.value.lastIndexOf(\"__\", 0) === 0));\n                });\n                if (skip) {\n                    return;\n                }\n                // If this SelectionSet is @export-ed as an input variable, it should\n                // not have a __typename field (see issue #4691).\n                var field = parent;\n                if (isField(field) &&\n                    field.directives &&\n                    field.directives.some(function (d) { return d.name.value === \"export\"; })) {\n                    return;\n                }\n                // Create and return a new SelectionSet with a __typename Field.\n                return __assign(__assign({}, node), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });\n            },\n        },\n    });\n}, {\n    added: function (field) {\n        return field === TYPENAME_FIELD;\n    },\n});\nvar connectionRemoveConfig = {\n    test: function (directive) {\n        var willRemove = directive.name.value === \"connection\";\n        if (willRemove) {\n            if (!directive.arguments ||\n                !directive.arguments.some(function (arg) { return arg.name.value === \"key\"; })) {\n                globalThis.__DEV__ !== false && invariant.warn(83);\n            }\n        }\n        return willRemove;\n    },\n};\nexport function removeConnectionDirectiveFromDocument(doc) {\n    return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\n}\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n    if (nestedCheck === void 0) { nestedCheck = true; }\n    return (!!selectionSet &&\n        selectionSet.selections &&\n        selectionSet.selections.some(function (selection) {\n            return hasDirectivesInSelection(directives, selection, nestedCheck);\n        }));\n}\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n    if (nestedCheck === void 0) { nestedCheck = true; }\n    if (!isField(selection)) {\n        return true;\n    }\n    if (!selection.directives) {\n        return false;\n    }\n    return (selection.directives.some(getDirectiveMatcher(directives)) ||\n        (nestedCheck &&\n            hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck)));\n}\nfunction getArgumentMatcher(config) {\n    return function argumentMatcher(argument) {\n        return config.some(function (aConfig) {\n            return argument.value &&\n                argument.value.kind === Kind.VARIABLE &&\n                argument.value.name &&\n                (aConfig.name === argument.value.name.value ||\n                    (aConfig.test && aConfig.test(argument)));\n        });\n    };\n}\nexport function removeArgumentsFromDocument(config, doc) {\n    var argMatcher = getArgumentMatcher(config);\n    return nullIfDocIsEmpty(visit(doc, {\n        OperationDefinition: {\n            enter: function (node) {\n                return __assign(__assign({}, node), { \n                    // Remove matching top level variables definitions.\n                    variableDefinitions: node.variableDefinitions ?\n                        node.variableDefinitions.filter(function (varDef) {\n                            return !config.some(function (arg) { return arg.name === varDef.variable.name.value; });\n                        })\n                        : [] });\n            },\n        },\n        Field: {\n            enter: function (node) {\n                // If `remove` is set to true for an argument, and an argument match\n                // is found for a field, remove the field as well.\n                var shouldRemoveField = config.some(function (argConfig) { return argConfig.remove; });\n                if (shouldRemoveField) {\n                    var argMatchCount_1 = 0;\n                    if (node.arguments) {\n                        node.arguments.forEach(function (arg) {\n                            if (argMatcher(arg)) {\n                                argMatchCount_1 += 1;\n                            }\n                        });\n                    }\n                    if (argMatchCount_1 === 1) {\n                        return null;\n                    }\n                }\n            },\n        },\n        Argument: {\n            enter: function (node) {\n                // Remove all matching arguments.\n                if (argMatcher(node)) {\n                    return null;\n                }\n            },\n        },\n    }));\n}\nexport function removeFragmentSpreadFromDocument(config, doc) {\n    function enter(node) {\n        if (config.some(function (def) { return def.name === node.name.value; })) {\n            return null;\n        }\n    }\n    return nullIfDocIsEmpty(visit(doc, {\n        FragmentSpread: { enter: enter },\n        FragmentDefinition: { enter: enter },\n    }));\n}\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(document) {\n    var definition = getMainDefinition(document);\n    var definitionOperation = definition.operation;\n    if (definitionOperation === \"query\") {\n        // Already a query, so return the existing document.\n        return document;\n    }\n    // Build a new query using the selection set of the main operation.\n    var modifiedDoc = visit(document, {\n        OperationDefinition: {\n            enter: function (node) {\n                return __assign(__assign({}, node), { operation: \"query\" });\n            },\n        },\n    });\n    return modifiedDoc;\n}\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(document) {\n    checkDocument(document);\n    var modifiedDoc = removeDirectivesFromDocument([\n        {\n            test: function (directive) { return directive.name.value === \"client\"; },\n            remove: true,\n        },\n    ], document);\n    return modifiedDoc;\n}\n", "import { __assign, __spreadArray } from \"tslib\";\nimport { isNonNullObject } from \"./objects.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function mergeDeep() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    return mergeDeepArray(sources);\n}\n// In almost any situation where you could succeed in getting the\n// TypeScript compiler to infer a tuple type for the sources array, you\n// could just use mergeDeep instead of mergeDeepArray, so instead of\n// trying to convert T[] to an intersection type we just infer the array\n// element type, which works perfectly when the sources array has a\n// consistent element type.\nexport function mergeDeepArray(sources) {\n    var target = sources[0] || {};\n    var count = sources.length;\n    if (count > 1) {\n        var merger = new DeepMerger();\n        for (var i = 1; i < count; ++i) {\n            target = merger.merge(target, sources[i]);\n        }\n    }\n    return target;\n}\nvar defaultReconciler = function (target, source, property) {\n    return this.merge(target[property], source[property]);\n};\nvar DeepMerger = /** @class */ (function () {\n    function DeepMerger(reconciler) {\n        if (reconciler === void 0) { reconciler = defaultReconciler; }\n        this.reconciler = reconciler;\n        this.isObject = isNonNullObject;\n        this.pastCopies = new Set();\n    }\n    DeepMerger.prototype.merge = function (target, source) {\n        var _this = this;\n        var context = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            context[_i - 2] = arguments[_i];\n        }\n        if (isNonNullObject(source) && isNonNullObject(target)) {\n            Object.keys(source).forEach(function (sourceKey) {\n                if (hasOwnProperty.call(target, sourceKey)) {\n                    var targetValue = target[sourceKey];\n                    if (source[sourceKey] !== targetValue) {\n                        var result = _this.reconciler.apply(_this, __spreadArray([target,\n                            source,\n                            sourceKey], context, false));\n                        // A well-implemented reconciler may return targetValue to indicate\n                        // the merge changed nothing about the structure of the target.\n                        if (result !== targetValue) {\n                            target = _this.shallowCopyForMerge(target);\n                            target[sourceKey] = result;\n                        }\n                    }\n                }\n                else {\n                    // If there is no collision, the target can safely share memory with\n                    // the source, and the recursion can terminate here.\n                    target = _this.shallowCopyForMerge(target);\n                    target[sourceKey] = source[sourceKey];\n                }\n            });\n            return target;\n        }\n        // If source (or target) is not an object, let source replace target.\n        return source;\n    };\n    DeepMerger.prototype.shallowCopyForMerge = function (value) {\n        if (isNonNullObject(value)) {\n            if (!this.pastCopies.has(value)) {\n                if (Array.isArray(value)) {\n                    value = value.slice(0);\n                }\n                else {\n                    value = __assign({ __proto__: Object.getPrototypeOf(value) }, value);\n                }\n                this.pastCopies.add(value);\n            }\n        }\n        return value;\n    };\n    return DeepMerger;\n}());\nexport { DeepMerger };\n", "function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n// === Symbol Support ===\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\n\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\n\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\nvar SymbolIterator = getSymbol('iterator');\nvar SymbolObservable = getSymbol('observable');\nvar SymbolSpecies = getSymbol('species'); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n  if (value == null) return undefined;\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({\n      type: type,\n      value: value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{\n      type: type,\n      value: value\n    }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription = /*#__PURE__*/function () {\n  function Subscription(observer, subscriber) {\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  var _proto = Subscription.prototype;\n\n  _proto.unsubscribe = function unsubscribe() {\n    if (this._state !== 'closed') {\n      closeSubscription(this);\n      cleanupSubscription(this);\n    }\n  };\n\n  _createClass(Subscription, [{\n    key: \"closed\",\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver = /*#__PURE__*/function () {\n  function SubscriptionObserver(subscription) {\n    this._subscription = subscription;\n  }\n\n  var _proto2 = SubscriptionObserver.prototype;\n\n  _proto2.next = function next(value) {\n    onNotify(this._subscription, 'next', value);\n  };\n\n  _proto2.error = function error(value) {\n    onNotify(this._subscription, 'error', value);\n  };\n\n  _proto2.complete = function complete() {\n    onNotify(this._subscription, 'complete');\n  };\n\n  _createClass(SubscriptionObserver, [{\n    key: \"closed\",\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable = /*#__PURE__*/function () {\n  function Observable(subscriber) {\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n    this._subscriber = subscriber;\n  }\n\n  var _proto3 = Observable.prototype;\n\n  _proto3.subscribe = function subscribe(observer) {\n    if (typeof observer !== 'object' || observer === null) {\n      observer = {\n        next: observer,\n        error: arguments[1],\n        complete: arguments[2]\n      };\n    }\n\n    return new Subscription(observer, this._subscriber);\n  };\n\n  _proto3.forEach = function forEach(fn) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (typeof fn !== 'function') {\n        reject(new TypeError(fn + ' is not a function'));\n        return;\n      }\n\n      function done() {\n        subscription.unsubscribe();\n        resolve();\n      }\n\n      var subscription = _this.subscribe({\n        next: function (value) {\n          try {\n            fn(value, done);\n          } catch (e) {\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  };\n\n  _proto3.map = function map(fn) {\n    var _this2 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      return _this2.subscribe({\n        next: function (value) {\n          try {\n            value = fn(value);\n          } catch (e) {\n            return observer.error(e);\n          }\n\n          observer.next(value);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.filter = function filter(fn) {\n    var _this3 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      return _this3.subscribe({\n        next: function (value) {\n          try {\n            if (!fn(value)) return;\n          } catch (e) {\n            return observer.error(e);\n          }\n\n          observer.next(value);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.reduce = function reduce(fn) {\n    var _this4 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    var hasSeed = arguments.length > 1;\n    var hasValue = false;\n    var seed = arguments[1];\n    var acc = seed;\n    return new C(function (observer) {\n      return _this4.subscribe({\n        next: function (value) {\n          var first = !hasValue;\n          hasValue = true;\n\n          if (!first || hasSeed) {\n            try {\n              acc = fn(acc, value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          } else {\n            acc = value;\n          }\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n          observer.next(acc);\n          observer.complete();\n        }\n      });\n    });\n  };\n\n  _proto3.concat = function concat() {\n    var _this5 = this;\n\n    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n      sources[_key] = arguments[_key];\n    }\n\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      var subscription;\n      var index = 0;\n\n      function startNext(next) {\n        subscription = next.subscribe({\n          next: function (v) {\n            observer.next(v);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (index === sources.length) {\n              subscription = undefined;\n              observer.complete();\n            } else {\n              startNext(C.from(sources[index++]));\n            }\n          }\n        });\n      }\n\n      startNext(_this5);\n      return function () {\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = undefined;\n        }\n      };\n    });\n  };\n\n  _proto3.flatMap = function flatMap(fn) {\n    var _this6 = this;\n\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    var C = getSpecies(this);\n    return new C(function (observer) {\n      var subscriptions = [];\n\n      var outer = _this6.subscribe({\n        next: function (value) {\n          if (fn) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          }\n\n          var inner = C.from(value).subscribe({\n            next: function (value) {\n              observer.next(value);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              var i = subscriptions.indexOf(inner);\n              if (i >= 0) subscriptions.splice(i, 1);\n              completeIfDone();\n            }\n          });\n          subscriptions.push(inner);\n        },\n        error: function (e) {\n          observer.error(e);\n        },\n        complete: function () {\n          completeIfDone();\n        }\n      });\n\n      function completeIfDone() {\n        if (outer.closed && subscriptions.length === 0) observer.complete();\n      }\n\n      return function () {\n        subscriptions.forEach(function (s) {\n          return s.unsubscribe();\n        });\n        outer.unsubscribe();\n      };\n    });\n  };\n\n  _proto3[SymbolObservable] = function () {\n    return this;\n  };\n\n  Observable.from = function from(x) {\n    var C = typeof this === 'function' ? this : Observable;\n    if (x == null) throw new TypeError(x + ' is not an object');\n    var method = getMethod(x, SymbolObservable);\n\n    if (method) {\n      var observable = method.call(x);\n      if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n      if (isObservable(observable) && observable.constructor === C) return observable;\n      return new C(function (observer) {\n        return observable.subscribe(observer);\n      });\n    }\n\n    if (hasSymbol('iterator')) {\n      method = getMethod(x, SymbolIterator);\n\n      if (method) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n\n            for (var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done;) {\n              var item = _step.value;\n              observer.next(item);\n              if (observer.closed) return;\n            }\n\n            observer.complete();\n          });\n        });\n      }\n    }\n\n    if (Array.isArray(x)) {\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n\n          for (var i = 0; i < x.length; ++i) {\n            observer.next(x[i]);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      });\n    }\n\n    throw new TypeError(x + ' is not observable');\n  };\n\n  Observable.of = function of() {\n    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      items[_key2] = arguments[_key2];\n    }\n\n    var C = typeof this === 'function' ? this : Observable;\n    return new C(function (observer) {\n      enqueue(function () {\n        if (observer.closed) return;\n\n        for (var i = 0; i < items.length; ++i) {\n          observer.next(items[i]);\n          if (observer.closed) return;\n        }\n\n        observer.complete();\n      });\n    });\n  };\n\n  _createClass(Observable, null, [{\n    key: SymbolSpecies,\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError: hostReportError\n    },\n    configurable: true\n  });\n}\n\nexport { Observable };\n", "export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\n\t\t\tif (typeof Symbol.for === 'function') {\n\t\t\t\t// This just needs to be something that won't trample other user's Symbol.for use\n\t\t\t\t// It also will guide people to the source of their issues, if this is problematic.\n\t\t\t\t// META: It's a resource locator!\n\t\t\t\tresult = Symbol.for('https://github.com/benlesh/symbol-observable');\n\t\t\t} else {\n\t\t\t\t// Symbol.for didn't exist! The best we can do at this point is a totally \n\t\t\t\t// unique symbol. Note that the string argument here is a descriptor, not\n\t\t\t\t// an identifier. This symbol is unique.\n\t\t\t\tresult = Symbol('https://github.com/benlesh/symbol-observable');\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tSymbol.observable = result;\n\t\t\t} catch (err) {\n\t\t\t\t// Do nothing. In some environments, users have frozen `Symbol` for security reasons,\n\t\t\t\t// if it is frozen assigning to it will throw. In this case, we don't care, because\n\t\t\t\t// they will need to use the returned value from the ponyfill.\n\t\t\t}\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n", "/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n", "import { Observable } from \"zen-observable-ts\";\n// This simplified polyfill attempts to follow the ECMAScript Observable\n// proposal (https://github.com/zenparsing/es-observable)\nimport \"symbol-observable\";\n// The zen-observable package defines Observable.prototype[Symbol.observable]\n// when Symbol is supported, but RxJS interop depends on also setting this fake\n// '@@observable' string as a polyfill for Symbol.observable.\nvar prototype = Observable.prototype;\nvar fakeObsSymbol = \"@@observable\";\nif (!prototype[fakeObsSymbol]) {\n    // @ts-expect-error\n    prototype[fakeObsSymbol] = function () {\n        return this;\n    };\n}\nexport { Observable };\n", "var toString = Object.prototype.toString;\n/**\n * Deeply clones a value to create a new instance.\n */\nexport function cloneDeep(value) {\n    return cloneDeepHelper(value);\n}\nfunction cloneDeepHelper(val, seen) {\n    switch (toString.call(val)) {\n        case \"[object Array]\": {\n            seen = seen || new Map();\n            if (seen.has(val))\n                return seen.get(val);\n            var copy_1 = val.slice(0);\n            seen.set(val, copy_1);\n            copy_1.forEach(function (child, i) {\n                copy_1[i] = cloneDeepHelper(child, seen);\n            });\n            return copy_1;\n        }\n        case \"[object Object]\": {\n            seen = seen || new Map();\n            if (seen.has(val))\n                return seen.get(val);\n            // High fidelity polyfills of Object.create and Object.getPrototypeOf are\n            // possible in all JS environments, so we will assume they exist/work.\n            var copy_2 = Object.create(Object.getPrototypeOf(val));\n            seen.set(val, copy_2);\n            Object.keys(val).forEach(function (key) {\n                copy_2[key] = cloneDeepHelper(val[key], seen);\n            });\n            return copy_2;\n        }\n        default:\n            return val;\n    }\n}\n", "import { isNonNullObject } from \"./objects.js\";\nfunction deepFreeze(value) {\n    var workSet = new Set([value]);\n    workSet.forEach(function (obj) {\n        if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {\n            Object.getOwnPropertyNames(obj).forEach(function (name) {\n                if (isNonNullObject(obj[name]))\n                    workSet.add(obj[name]);\n            });\n        }\n    });\n    return value;\n}\nfunction shallowFreeze(obj) {\n    if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {\n        try {\n            Object.freeze(obj);\n        }\n        catch (e) {\n            // Some types like Uint8Array and Node.js's Buffer cannot be frozen, but\n            // they all throw a TypeError when you try, so we re-throw any exceptions\n            // that are not TypeErrors, since that would be unexpected.\n            if (e instanceof TypeError)\n                return null;\n            throw e;\n        }\n    }\n    return obj;\n}\nexport function maybeDeepFreeze(obj) {\n    if (globalThis.__DEV__ !== false) {\n        deepFreeze(obj);\n    }\n    return obj;\n}\n", "export function iterateObserversSafely(observers, method, argument) {\n    // In case observers is modified during iteration, we need to commit to the\n    // original elements, which also provides an opportunity to filter them down\n    // to just the observers with the given method.\n    var observersWithMethod = [];\n    observers.forEach(function (obs) { return obs[method] && observersWithMethod.push(obs); });\n    observersWithMethod.forEach(function (obs) { return obs[method](argument); });\n}\n", "import { Observable } from \"./Observable.js\";\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\nexport function asyncMap(observable, mapFn, catchFn) {\n    return new Observable(function (observer) {\n        var promiseQueue = {\n            // Normally we would initialize promiseQueue to Promise.resolve(), but\n            // in this case, for backwards compatibility, we need to be careful to\n            // invoke the first callback synchronously.\n            then: function (callback) {\n                return new Promise(function (resolve) { return resolve(callback()); });\n            },\n        };\n        function makeCallback(examiner, key) {\n            return function (arg) {\n                if (examiner) {\n                    var both = function () {\n                        // If the observer is closed, we don't want to continue calling the\n                        // mapping function - it's result will be swallowed anyways.\n                        return observer.closed ?\n                            /* will be swallowed */ 0\n                            : examiner(arg);\n                    };\n                    promiseQueue = promiseQueue.then(both, both).then(function (result) { return observer.next(result); }, function (error) { return observer.error(error); });\n                }\n                else {\n                    observer[key](arg);\n                }\n            };\n        }\n        var handler = {\n            next: makeCallback(mapFn, \"next\"),\n            error: makeCallback(catchFn, \"error\"),\n            complete: function () {\n                // no need to reassign `promiseQueue`, after `observer.complete`,\n                // the observer will be closed and short-circuit everything anyways\n                /*promiseQueue = */ promiseQueue.then(function () { return observer.complete(); });\n            },\n        };\n        var sub = observable.subscribe(handler);\n        return function () { return sub.unsubscribe(); };\n    });\n}\n", "import { Observable } from \"./Observable.js\";\nimport { canUseSymbol } from \"../common/canUse.js\";\n// Generic implementations of Observable.prototype methods like map and\n// filter need to know how to create a new Observable from an Observable\n// subclass (like Concast or ObservableQuery). Those methods assume\n// (perhaps unwisely?) that they can call the subtype's constructor with a\n// Subscriber function, even though the subclass constructor might expect\n// different parameters. Defining this static Symbol.species property on\n// the subclass is a hint to generic Observable code to use the default\n// constructor instead of trying to do `new Subclass(observer => ...)`.\nexport function fixObservableSubclass(subclass) {\n    function set(key) {\n        // Object.defineProperty is necessary because the Symbol.species\n        // property is a getter by default in modern JS environments, so we\n        // can't assign to it with a normal assignment expression.\n        Object.defineProperty(subclass, key, { value: Observable });\n    }\n    if (canUseSymbol && Symbol.species) {\n        set(Symbol.species);\n    }\n    // The \"@@species\" string is used as a fake Symbol.species value in some\n    // polyfill systems (including the SymbolSpecies variable used by\n    // zen-observable), so we should set it as well, to be safe.\n    set(\"@@species\");\n    return subclass;\n}\n", "import { __extends } from \"tslib\";\nimport { Observable } from \"./Observable.js\";\nimport { iterateObserversSafely } from \"./iteration.js\";\nimport { fixObservableSubclass } from \"./subclassing.js\";\nfunction isPromiseLike(value) {\n    return value && typeof value.then === \"function\";\n}\n// A Concast<T> observable concatenates the given sources into a single\n// non-overlapping sequence of Ts, automatically unwrapping any promises,\n// and broadcasts the T elements of that sequence to any number of\n// subscribers, all without creating a bunch of intermediary Observable\n// wrapper objects.\n//\n// Even though any number of observers can subscribe to the Concast, each\n// source observable is guaranteed to receive at most one subscribe call,\n// and the results are multicast to all observers.\n//\n// In addition to broadcasting every next/error message to this.observers,\n// the Concast stores the most recent message using this.latest, so any\n// new observers can immediately receive the latest message, even if it\n// was originally delivered in the past. This behavior means we can assume\n// every active observer in this.observers has received the same most\n// recent message.\n//\n// With the exception of this.latest replay, a Concast is a \"hot\"\n// observable in the sense that it does not replay past results from the\n// beginning of time for each new observer.\n//\n// Could we have used some existing RxJS class instead? Concast<T> is\n// similar to a BehaviorSubject<T>, because it is multicast and redelivers\n// the latest next/error message to new subscribers. Unlike Subject<T>,\n// Concast<T> does not expose an Observer<T> interface (this.handlers is\n// intentionally private), since Concast<T> gets its inputs from the\n// concatenated sources. If we ever switch to RxJS, there may be some\n// value in reusing their code, but for now we use zen-observable, which\n// does not contain any Subject implementations.\nvar Concast = /** @class */ (function (_super) {\n    __extends(Concast, _super);\n    // Not only can the individual elements of the iterable be promises, but\n    // also the iterable itself can be wrapped in a promise.\n    function Concast(sources) {\n        var _this = _super.call(this, function (observer) {\n            _this.addObserver(observer);\n            return function () { return _this.removeObserver(observer); };\n        }) || this;\n        // Active observers receiving broadcast messages. Thanks to this.latest,\n        // we can assume all observers in this Set have received the same most\n        // recent message, though possibly at different times in the past.\n        _this.observers = new Set();\n        _this.promise = new Promise(function (resolve, reject) {\n            _this.resolve = resolve;\n            _this.reject = reject;\n        });\n        // Bound handler functions that can be reused for every internal\n        // subscription.\n        _this.handlers = {\n            next: function (result) {\n                if (_this.sub !== null) {\n                    _this.latest = [\"next\", result];\n                    _this.notify(\"next\", result);\n                    iterateObserversSafely(_this.observers, \"next\", result);\n                }\n            },\n            error: function (error) {\n                var sub = _this.sub;\n                if (sub !== null) {\n                    // Delay unsubscribing from the underlying subscription slightly,\n                    // so that immediately subscribing another observer can keep the\n                    // subscription active.\n                    if (sub)\n                        setTimeout(function () { return sub.unsubscribe(); });\n                    _this.sub = null;\n                    _this.latest = [\"error\", error];\n                    _this.reject(error);\n                    _this.notify(\"error\", error);\n                    iterateObserversSafely(_this.observers, \"error\", error);\n                }\n            },\n            complete: function () {\n                var _a = _this, sub = _a.sub, _b = _a.sources, sources = _b === void 0 ? [] : _b;\n                if (sub !== null) {\n                    // If complete is called before concast.start, this.sources may be\n                    // undefined, so we use a default value of [] for sources. That works\n                    // here because it falls into the if (!value) {...} block, which\n                    // appropriately terminates the Concast, even if this.sources might\n                    // eventually have been initialized to a non-empty array.\n                    var value = sources.shift();\n                    if (!value) {\n                        if (sub)\n                            setTimeout(function () { return sub.unsubscribe(); });\n                        _this.sub = null;\n                        if (_this.latest && _this.latest[0] === \"next\") {\n                            _this.resolve(_this.latest[1]);\n                        }\n                        else {\n                            _this.resolve();\n                        }\n                        _this.notify(\"complete\");\n                        // We do not store this.latest = [\"complete\"], because doing so\n                        // discards useful information about the previous next (or\n                        // error) message. Instead, if new observers subscribe after\n                        // this Concast has completed, they will receive the final\n                        // 'next' message (unless there was an error) immediately\n                        // followed by a 'complete' message (see addObserver).\n                        iterateObserversSafely(_this.observers, \"complete\");\n                    }\n                    else if (isPromiseLike(value)) {\n                        value.then(function (obs) { return (_this.sub = obs.subscribe(_this.handlers)); });\n                    }\n                    else {\n                        _this.sub = value.subscribe(_this.handlers);\n                    }\n                }\n            },\n        };\n        _this.nextResultListeners = new Set();\n        // A public way to abort observation and broadcast.\n        _this.cancel = function (reason) {\n            _this.reject(reason);\n            _this.sources = [];\n            _this.handlers.complete();\n        };\n        // Suppress rejection warnings for this.promise, since it's perfectly\n        // acceptable to pay no attention to this.promise if you're consuming\n        // the results through the normal observable API.\n        _this.promise.catch(function (_) { });\n        // If someone accidentally tries to create a Concast using a subscriber\n        // function, recover by creating an Observable from that subscriber and\n        // using it as the source.\n        if (typeof sources === \"function\") {\n            sources = [new Observable(sources)];\n        }\n        if (isPromiseLike(sources)) {\n            sources.then(function (iterable) { return _this.start(iterable); }, _this.handlers.error);\n        }\n        else {\n            _this.start(sources);\n        }\n        return _this;\n    }\n    Concast.prototype.start = function (sources) {\n        if (this.sub !== void 0)\n            return;\n        // In practice, sources is most often simply an Array of observables.\n        // TODO Consider using sources[Symbol.iterator]() to take advantage\n        // of the laziness of non-Array iterables.\n        this.sources = Array.from(sources);\n        // Calling this.handlers.complete() kicks off consumption of the first\n        // source observable. It's tempting to do this step lazily in\n        // addObserver, but this.promise can be accessed without calling\n        // addObserver, so consumption needs to begin eagerly.\n        this.handlers.complete();\n    };\n    Concast.prototype.deliverLastMessage = function (observer) {\n        if (this.latest) {\n            var nextOrError = this.latest[0];\n            var method = observer[nextOrError];\n            if (method) {\n                method.call(observer, this.latest[1]);\n            }\n            // If the subscription is already closed, and the last message was\n            // a 'next' message, simulate delivery of the final 'complete'\n            // message again.\n            if (this.sub === null && nextOrError === \"next\" && observer.complete) {\n                observer.complete();\n            }\n        }\n    };\n    Concast.prototype.addObserver = function (observer) {\n        if (!this.observers.has(observer)) {\n            // Immediately deliver the most recent message, so we can always\n            // be sure all observers have the latest information.\n            this.deliverLastMessage(observer);\n            this.observers.add(observer);\n        }\n    };\n    Concast.prototype.removeObserver = function (observer) {\n        if (this.observers.delete(observer) && this.observers.size < 1) {\n            // In case there are still any listeners in this.nextResultListeners, and\n            // no error or completion has been broadcast yet, make sure those\n            // observers have a chance to run and then remove themselves from\n            // this.observers.\n            this.handlers.complete();\n        }\n    };\n    Concast.prototype.notify = function (method, arg) {\n        var nextResultListeners = this.nextResultListeners;\n        if (nextResultListeners.size) {\n            // Replacing this.nextResultListeners first ensures it does not grow while\n            // we are iterating over it, potentially leading to infinite loops.\n            this.nextResultListeners = new Set();\n            nextResultListeners.forEach(function (listener) { return listener(method, arg); });\n        }\n    };\n    // We need a way to run callbacks just *before* the next result (or error or\n    // completion) is delivered by this Concast, so we can be sure any code that\n    // runs as a result of delivering that result/error observes the effects of\n    // running the callback(s). It was tempting to reuse the Observer type instead\n    // of introducing NextResultListener, but that messes with the sizing and\n    // maintenance of this.observers, and ends up being more code overall.\n    Concast.prototype.beforeNext = function (callback) {\n        var called = false;\n        this.nextResultListeners.add(function (method, arg) {\n            if (!called) {\n                called = true;\n                callback(method, arg);\n            }\n        });\n    };\n    return Concast;\n}(Observable));\nexport { Concast };\n// Necessary because the Concast constructor has a different signature\n// than the Observable constructor.\nfixObservableSubclass(Concast);\n", "import { isNonNullObject } from \"./objects.js\";\nimport { isNonEmptyArray } from \"./arrays.js\";\nimport { DeepMerger } from \"./mergeDeep.js\";\nexport function isExecutionPatchIncrementalResult(value) {\n    return \"incremental\" in value;\n}\nexport function isExecutionPatchInitialResult(value) {\n    return \"hasNext\" in value && \"data\" in value;\n}\nexport function isExecutionPatchResult(value) {\n    return (isExecutionPatchIncrementalResult(value) ||\n        isExecutionPatchInitialResult(value));\n}\n// This function detects an Apollo payload result before it is transformed\n// into a FetchResult via HttpLink; it cannot detect an ApolloPayloadResult\n// once it leaves the link chain.\nexport function isApolloPayloadResult(value) {\n    return isNonNullObject(value) && \"payload\" in value;\n}\nexport function mergeIncrementalData(prevResult, result) {\n    var mergedData = prevResult;\n    var merger = new DeepMerger();\n    if (isExecutionPatchIncrementalResult(result) &&\n        isNonEmptyArray(result.incremental)) {\n        result.incremental.forEach(function (_a) {\n            var data = _a.data, path = _a.path;\n            for (var i = path.length - 1; i >= 0; --i) {\n                var key = path[i];\n                var isNumericKey = !isNaN(+key);\n                var parent_1 = isNumericKey ? [] : {};\n                parent_1[key] = data;\n                data = parent_1;\n            }\n            mergedData = merger.merge(mergedData, data);\n        });\n    }\n    return mergedData;\n}\n", "import { isNonEmptyArray } from \"./arrays.js\";\nimport { isExecutionPatchIncrementalResult } from \"./incrementalResult.js\";\nexport function graphQLResultHasError(result) {\n    var errors = getGraphQLErrorsFromResult(result);\n    return isNonEmptyArray(errors);\n}\nexport function getGraphQLErrorsFromResult(result) {\n    var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];\n    if (isExecutionPatchIncrementalResult(result) &&\n        isNonEmptyArray(result.incremental)) {\n        result.incremental.forEach(function (incrementalResult) {\n            if (incrementalResult.errors) {\n                graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);\n            }\n        });\n    }\n    return graphQLErrors;\n}\n", "/**\n * Merges the provided objects shallowly and removes\n * all properties with an `undefined` value\n */\nexport function compact() {\n    var objects = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        objects[_i] = arguments[_i];\n    }\n    var result = Object.create(null);\n    objects.forEach(function (obj) {\n        if (!obj)\n            return;\n        Object.keys(obj).forEach(function (key) {\n            var value = obj[key];\n            if (value !== void 0) {\n                result[key] = value;\n            }\n        });\n    });\n    return result;\n}\n", "import { __assign } from \"tslib\";\nimport { compact } from \"./compact.js\";\nexport function mergeOptions(defaults, options) {\n    return compact(defaults, options, options.variables && {\n        variables: compact(__assign(__assign({}, (defaults && defaults.variables)), options.variables)),\n    });\n}\n", "import { Observable } from \"../../utilities/index.js\";\nexport function fromError(errorValue) {\n    return new Observable(function (observer) {\n        observer.error(errorValue);\n    });\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nexport function toPromise(observable) {\n    var completed = false;\n    return new Promise(function (resolve, reject) {\n        observable.subscribe({\n            next: function (data) {\n                if (completed) {\n                    globalThis.__DEV__ !== false && invariant.warn(42);\n                }\n                else {\n                    completed = true;\n                    resolve(data);\n                }\n            },\n            error: reject,\n        });\n    });\n}\n", "import { Observable } from \"../../utilities/index.js\";\nexport function fromPromise(promise) {\n    return new Observable(function (observer) {\n        promise\n            .then(function (value) {\n            observer.next(value);\n            observer.complete();\n        })\n            .catch(observer.error.bind(observer));\n    });\n}\n", "export var throwServerError = function (response, result, message) {\n    var error = new Error(message);\n    error.name = \"ServerError\";\n    error.response = response;\n    error.statusCode = response.status;\n    error.result = result;\n    throw error;\n};\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\nexport function validateOperation(operation) {\n    var OPERATION_FIELDS = [\n        \"query\",\n        \"operationName\",\n        \"variables\",\n        \"extensions\",\n        \"context\",\n    ];\n    for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {\n        var key = _a[_i];\n        if (OPERATION_FIELDS.indexOf(key) < 0) {\n            throw newInvariantError(43, key);\n        }\n    }\n    return operation;\n}\n", "import { __assign } from \"tslib\";\nexport function createOperation(starting, operation) {\n    var context = __assign({}, starting);\n    var setContext = function (next) {\n        if (typeof next === \"function\") {\n            context = __assign(__assign({}, context), next(context));\n        }\n        else {\n            context = __assign(__assign({}, context), next);\n        }\n    };\n    var getContext = function () { return (__assign({}, context)); };\n    Object.defineProperty(operation, \"setContext\", {\n        enumerable: false,\n        value: setContext,\n    });\n    Object.defineProperty(operation, \"getContext\", {\n        enumerable: false,\n        value: getContext,\n    });\n    return operation;\n}\n", "import { getOperationName } from \"../../utilities/index.js\";\nexport function transformOperation(operation) {\n    var transformedOperation = {\n        variables: operation.variables || {},\n        extensions: operation.extensions || {},\n        operationName: operation.operationName,\n        query: operation.query,\n    };\n    // Best guess at an operation name\n    if (!transformedOperation.operationName) {\n        transformedOperation.operationName =\n            typeof transformedOperation.query !== \"string\" ?\n                getOperationName(transformedOperation.query) || undefined\n                : \"\";\n    }\n    return transformedOperation;\n}\n", "import { __assign } from \"tslib\";\nimport { visit } from \"graphql\";\nexport function filterOperationVariables(variables, query) {\n    var result = __assign({}, variables);\n    var unusedNames = new Set(Object.keys(variables));\n    visit(query, {\n        Variable: function (node, _key, parent) {\n            // A variable type definition at the top level of a query is not\n            // enough to silence server-side errors about the variable being\n            // unused, so variable definitions do not count as usage.\n            // https://spec.graphql.org/draft/#sec-All-Variables-Used\n            if (parent &&\n                parent.kind !== \"VariableDefinition\") {\n                unusedNames.delete(node.name.value);\n            }\n        },\n    });\n    unusedNames.forEach(function (name) {\n        delete result[name];\n    });\n    return result;\n}\n", "import { newInvariantError, invariant } from \"../../utilities/globals/index.js\";\nimport { Observable } from \"../../utilities/index.js\";\nimport { validateOperation, createOperation, transformOperation, } from \"../utils/index.js\";\nfunction passthrough(op, forward) {\n    return (forward ? forward(op) : Observable.of());\n}\nfunction toLink(handler) {\n    return typeof handler === \"function\" ? new ApolloLink(handler) : handler;\n}\nfunction isTerminating(link) {\n    return link.request.length <= 1;\n}\nvar ApolloLink = /** @class */ (function () {\n    function ApolloLink(request) {\n        if (request)\n            this.request = request;\n    }\n    ApolloLink.empty = function () {\n        return new ApolloLink(function () { return Observable.of(); });\n    };\n    ApolloLink.from = function (links) {\n        if (links.length === 0)\n            return ApolloLink.empty();\n        return links.map(toLink).reduce(function (x, y) { return x.concat(y); });\n    };\n    ApolloLink.split = function (test, left, right) {\n        var leftLink = toLink(left);\n        var rightLink = toLink(right || new ApolloLink(passthrough));\n        if (isTerminating(leftLink) && isTerminating(rightLink)) {\n            return new ApolloLink(function (operation) {\n                return test(operation) ?\n                    leftLink.request(operation) || Observable.of()\n                    : rightLink.request(operation) || Observable.of();\n            });\n        }\n        else {\n            return new ApolloLink(function (operation, forward) {\n                return test(operation) ?\n                    leftLink.request(operation, forward) || Observable.of()\n                    : rightLink.request(operation, forward) || Observable.of();\n            });\n        }\n    };\n    ApolloLink.execute = function (link, operation) {\n        return (link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of());\n    };\n    ApolloLink.concat = function (first, second) {\n        var firstLink = toLink(first);\n        if (isTerminating(firstLink)) {\n            globalThis.__DEV__ !== false && invariant.warn(35, firstLink);\n            return firstLink;\n        }\n        var nextLink = toLink(second);\n        if (isTerminating(nextLink)) {\n            return new ApolloLink(function (operation) {\n                return firstLink.request(operation, function (op) { return nextLink.request(op) || Observable.of(); }) || Observable.of();\n            });\n        }\n        else {\n            return new ApolloLink(function (operation, forward) {\n                return (firstLink.request(operation, function (op) {\n                    return nextLink.request(op, forward) || Observable.of();\n                }) || Observable.of());\n            });\n        }\n    };\n    ApolloLink.prototype.split = function (test, left, right) {\n        return this.concat(ApolloLink.split(test, left, right || new ApolloLink(passthrough)));\n    };\n    ApolloLink.prototype.concat = function (next) {\n        return ApolloLink.concat(this, next);\n    };\n    ApolloLink.prototype.request = function (operation, forward) {\n        throw newInvariantError(36);\n    };\n    ApolloLink.prototype.onError = function (error, observer) {\n        if (observer && observer.error) {\n            observer.error(error);\n            // Returning false indicates that observer.error does not need to be\n            // called again, since it was already called (on the previous line).\n            // Calling observer.error again would not cause any real problems,\n            // since only the first call matters, but custom onError functions\n            // might have other reasons for wanting to prevent the default\n            // behavior by returning false.\n            return false;\n        }\n        // Throw errors will be passed to observer.error.\n        throw error;\n    };\n    ApolloLink.prototype.setOnError = function (fn) {\n        this.onError = fn;\n        return this;\n    };\n    return ApolloLink;\n}());\nexport { ApolloLink };\n", "import { ApolloLink } from \"./ApolloLink.js\";\nexport var empty = ApolloLink.empty;\n", "import { ApolloLink } from \"./ApolloLink.js\";\nexport var from = ApolloLink.from;\n", "import { ApolloLink } from \"./ApolloLink.js\";\nexport var split = ApolloLink.split;\n", "import { ApolloLink } from \"./ApolloLink.js\";\nexport var concat = ApolloLink.concat;\n", "import { ApolloLink } from \"./ApolloLink.js\";\nexport var execute = ApolloLink.execute;\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/async.ts\n */\nexport default function asyncIterator(source) {\n    var _a;\n    var iterator = source[Symbol.asyncIterator]();\n    return _a = {\n            next: function () {\n                return iterator.next();\n            }\n        },\n        _a[Symbol.asyncIterator] = function () {\n            return this;\n        },\n        _a;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/nodeStream.ts\n */\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\nexport default function nodeStreamIterator(stream) {\n    var cleanup = null;\n    var error = null;\n    var done = false;\n    var data = [];\n    var waiting = [];\n    function onData(chunk) {\n        if (error)\n            return;\n        if (waiting.length) {\n            var shiftedArr = waiting.shift();\n            if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n                return shiftedArr[0]({ value: chunk, done: false });\n            }\n        }\n        data.push(chunk);\n    }\n    function onError(err) {\n        error = err;\n        var all = waiting.slice();\n        all.forEach(function (pair) {\n            pair[1](err);\n        });\n        !cleanup || cleanup();\n    }\n    function onEnd() {\n        done = true;\n        var all = waiting.slice();\n        all.forEach(function (pair) {\n            pair[0]({ value: undefined, done: true });\n        });\n        !cleanup || cleanup();\n    }\n    cleanup = function () {\n        cleanup = null;\n        stream.removeListener(\"data\", onData);\n        stream.removeListener(\"error\", onError);\n        stream.removeListener(\"end\", onEnd);\n        stream.removeListener(\"finish\", onEnd);\n        stream.removeListener(\"close\", onEnd);\n    };\n    stream.on(\"data\", onData);\n    stream.on(\"error\", onError);\n    stream.on(\"end\", onEnd);\n    stream.on(\"finish\", onEnd);\n    stream.on(\"close\", onEnd);\n    function getNext() {\n        return new Promise(function (resolve, reject) {\n            if (error)\n                return reject(error);\n            if (data.length)\n                return resolve({ value: data.shift(), done: false });\n            if (done)\n                return resolve({ value: undefined, done: true });\n            waiting.push([resolve, reject]);\n        });\n    }\n    var iterator = {\n        next: function () {\n            return getNext();\n        },\n    };\n    if (canUseAsyncIteratorSymbol) {\n        iterator[Symbol.asyncIterator] = function () {\n            return this;\n        };\n    }\n    return iterator;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/promise.ts\n */\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\nexport default function promiseIterator(promise) {\n    var resolved = false;\n    var iterator = {\n        next: function () {\n            if (resolved)\n                return Promise.resolve({\n                    value: undefined,\n                    done: true,\n                });\n            resolved = true;\n            return new Promise(function (resolve, reject) {\n                promise\n                    .then(function (value) {\n                    resolve({ value: value, done: false });\n                })\n                    .catch(reject);\n            });\n        },\n    };\n    if (canUseAsyncIteratorSymbol) {\n        iterator[Symbol.asyncIterator] = function () {\n            return this;\n        };\n    }\n    return iterator;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/reader.ts\n */\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\nexport default function readerIterator(reader) {\n    var iterator = {\n        next: function () {\n            return reader.read();\n        },\n    };\n    if (canUseAsyncIteratorSymbol) {\n        iterator[Symbol.asyncIterator] = function () {\n            return this;\n        };\n    }\n    return iterator;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/index.ts\n */\nimport { canUseAsyncIteratorSymbol } from \"../../utilities/index.js\";\nimport asyncIterator from \"./iterators/async.js\";\nimport nodeStreamIterator from \"./iterators/nodeStream.js\";\nimport promiseIterator from \"./iterators/promise.js\";\nimport readerIterator from \"./iterators/reader.js\";\nfunction isNodeResponse(value) {\n    return !!value.body;\n}\nfunction isReadableStream(value) {\n    return !!value.getReader;\n}\nfunction isAsyncIterableIterator(value) {\n    return !!(canUseAsyncIteratorSymbol &&\n        value[Symbol.asyncIterator]);\n}\nfunction isStreamableBlob(value) {\n    return !!value.stream;\n}\nfunction isBlob(value) {\n    return !!value.arrayBuffer;\n}\nfunction isNodeReadableStream(value) {\n    return !!value.pipe;\n}\nexport function responseIterator(response) {\n    var body = response;\n    if (isNodeResponse(response))\n        body = response.body;\n    if (isAsyncIterableIterator(body))\n        return asyncIterator(body);\n    if (isReadableStream(body))\n        return readerIterator(body.getReader());\n    // this errors without casting to ReadableStream<T>\n    // because Blob.stream() returns a NodeJS ReadableStream\n    if (isStreamableBlob(body)) {\n        return readerIterator(body.stream().getReader());\n    }\n    if (isBlob(body))\n        return promiseIterator(body.arrayBuffer());\n    if (isNodeReadableStream(body))\n        return nodeStreamIterator(body);\n    throw new Error(\"Unknown body type for responseIterator. Please pass a streamable response.\");\n}\n", "import { __extends, __spreadArray } from \"tslib\";\nimport \"../utilities/globals/index.js\";\nimport { isNonNullObject } from \"../utilities/index.js\";\n// This Symbol allows us to pass transport-specific errors from the link chain\n// into QueryManager/client internals without risking a naming collision within\n// extensions (which implementers can use as they see fit).\nexport var PROTOCOL_ERRORS_SYMBOL = Symbol();\nexport function graphQLResultHasProtocolErrors(result) {\n    if (result.extensions) {\n        return Array.isArray(result.extensions[PROTOCOL_ERRORS_SYMBOL]);\n    }\n    return false;\n}\nexport function isApolloError(err) {\n    return err.hasOwnProperty(\"graphQLErrors\");\n}\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nvar generateErrorMessage = function (err) {\n    var errors = __spreadArray(__spreadArray(__spreadArray([], err.graphQLErrors, true), err.clientErrors, true), err.protocolErrors, true);\n    if (err.networkError)\n        errors.push(err.networkError);\n    return (errors\n        // The rest of the code sometimes unsafely types non-Error objects as GraphQLErrors\n        .map(function (err) {\n        return (isNonNullObject(err) && err.message) || \"Error message not found.\";\n    })\n        .join(\"\\n\"));\n};\nvar ApolloError = /** @class */ (function (_super) {\n    __extends(ApolloError, _super);\n    // Constructs an instance of ApolloError given a GraphQLError\n    // or a network error. Note that one of these has to be a valid\n    // value or the constructed error will be meaningless.\n    function ApolloError(_a) {\n        var graphQLErrors = _a.graphQLErrors, protocolErrors = _a.protocolErrors, clientErrors = _a.clientErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;\n        var _this = _super.call(this, errorMessage) || this;\n        _this.name = \"ApolloError\";\n        _this.graphQLErrors = graphQLErrors || [];\n        _this.protocolErrors = protocolErrors || [];\n        _this.clientErrors = clientErrors || [];\n        _this.networkError = networkError || null;\n        _this.message = errorMessage || generateErrorMessage(_this);\n        _this.extraInfo = extraInfo;\n        // We're not using `Object.setPrototypeOf` here as it isn't fully\n        // supported on Android (see issue #3236).\n        _this.__proto__ = ApolloError.prototype;\n        return _this;\n    }\n    return ApolloError;\n}(Error));\nexport { ApolloError };\n", "import { __assign, __awaiter, __generator } from \"tslib\";\nimport { responseIterator } from \"./responseIterator.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function readMultipartBody(response, nextValue) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _b, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result, next;\n        var _c, _d;\n        return __generator(this, function (_e) {\n            switch (_e.label) {\n                case 0:\n                    if (TextDecoder === undefined) {\n                        throw new Error(\"TextDecoder must be defined in the environment: please import a polyfill.\");\n                    }\n                    decoder = new TextDecoder(\"utf-8\");\n                    contentType = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.get(\"content-type\");\n                    delimiter = \"boundary=\";\n                    boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ?\n                        contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['\"]/g, \"\").replace(/\\;(.*)/gm, \"\").trim()\n                        : \"-\";\n                    boundary = \"\\r\\n--\".concat(boundaryVal);\n                    buffer = \"\";\n                    iterator = responseIterator(response);\n                    running = true;\n                    _e.label = 1;\n                case 1:\n                    if (!running) return [3 /*break*/, 3];\n                    return [4 /*yield*/, iterator.next()];\n                case 2:\n                    _b = _e.sent(), value = _b.value, done = _b.done;\n                    chunk = typeof value === \"string\" ? value : decoder.decode(value);\n                    searchFrom = buffer.length - boundary.length + 1;\n                    running = !done;\n                    buffer += chunk;\n                    bi = buffer.indexOf(boundary, searchFrom);\n                    while (bi > -1) {\n                        message = void 0;\n                        _c = [\n                            buffer.slice(0, bi),\n                            buffer.slice(bi + boundary.length),\n                        ], message = _c[0], buffer = _c[1];\n                        i = message.indexOf(\"\\r\\n\\r\\n\");\n                        headers = parseHeaders(message.slice(0, i));\n                        contentType_1 = headers[\"content-type\"];\n                        if (contentType_1 &&\n                            contentType_1.toLowerCase().indexOf(\"application/json\") === -1) {\n                            throw new Error(\"Unsupported patch content type: application/json is required.\");\n                        }\n                        body = message.slice(i);\n                        if (body) {\n                            result = parseJsonBody(response, body);\n                            if (Object.keys(result).length > 1 ||\n                                \"data\" in result ||\n                                \"incremental\" in result ||\n                                \"errors\" in result ||\n                                \"payload\" in result) {\n                                if (isApolloPayloadResult(result)) {\n                                    next = {};\n                                    if (\"payload\" in result) {\n                                        next = __assign({}, result.payload);\n                                    }\n                                    if (\"errors\" in result) {\n                                        next = __assign(__assign({}, next), { extensions: __assign(__assign({}, (\"extensions\" in next ? next.extensions : null)), (_d = {}, _d[PROTOCOL_ERRORS_SYMBOL] = result.errors, _d)) });\n                                    }\n                                    nextValue(next);\n                                }\n                                else {\n                                    // for the last chunk with only `hasNext: false`\n                                    // we don't need to call observer.next as there is no data/errors\n                                    nextValue(result);\n                                }\n                            }\n                            else if (\n                            // If the chunk contains only a \"hasNext: false\", we can call\n                            // observer.complete() immediately.\n                            Object.keys(result).length === 1 &&\n                                \"hasNext\" in result &&\n                                !result.hasNext) {\n                                return [2 /*return*/];\n                            }\n                        }\n                        bi = buffer.indexOf(boundary);\n                    }\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/];\n            }\n        });\n    });\n}\nexport function parseHeaders(headerText) {\n    var headersInit = {};\n    headerText.split(\"\\n\").forEach(function (line) {\n        var i = line.indexOf(\":\");\n        if (i > -1) {\n            // normalize headers to lowercase\n            var name_1 = line.slice(0, i).trim().toLowerCase();\n            var value = line.slice(i + 1).trim();\n            headersInit[name_1] = value;\n        }\n    });\n    return headersInit;\n}\nexport function parseJsonBody(response, bodyText) {\n    if (response.status >= 300) {\n        // Network error\n        var getResult = function () {\n            try {\n                return JSON.parse(bodyText);\n            }\n            catch (err) {\n                return bodyText;\n            }\n        };\n        throwServerError(response, getResult(), \"Response not successful: Received status code \".concat(response.status));\n    }\n    try {\n        return JSON.parse(bodyText);\n    }\n    catch (err) {\n        var parseError = err;\n        parseError.name = \"ServerParseError\";\n        parseError.response = response;\n        parseError.statusCode = response.status;\n        parseError.bodyText = bodyText;\n        throw parseError;\n    }\n}\nexport function handleError(err, observer) {\n    // if it is a network error, BUT there is graphql result info fire\n    // the next observer before calling error this gives apollo-client\n    // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n    // pass to UI this should only happen if we *also* have data as\n    // part of the response key per the spec\n    if (err.result && err.result.errors && err.result.data) {\n        // if we don't call next, the UI can only show networkError\n        // because AC didn't get any graphqlErrors this is graphql\n        // execution result info (i.e errors and possibly data) this is\n        // because there is no formal spec how errors should translate to\n        // http status codes. So an auth error (401) could have both data\n        // from a public field, errors from a private field, and a status\n        // of 401\n        // {\n        //  user { // this will have errors\n        //    firstName\n        //  }\n        //  products { // this is public so will have data\n        //    cost\n        //  }\n        // }\n        //\n        // the result of above *could* look like this:\n        // {\n        //   data: { products: [{ cost: \"$10\" }] },\n        //   errors: [{\n        //      message: 'your session has timed out',\n        //      path: []\n        //   }]\n        // }\n        // status code of above would be a 401\n        // in the UI you want to show data where you can, errors as data where you can\n        // and use correct http status codes\n        observer.next(err.result);\n    }\n    observer.error(err);\n}\nexport function parseAndCheckHttpResponse(operations) {\n    return function (response) {\n        return response\n            .text()\n            .then(function (bodyText) { return parseJsonBody(response, bodyText); })\n            .then(function (result) {\n            if (!Array.isArray(result) &&\n                !hasOwnProperty.call(result, \"data\") &&\n                !hasOwnProperty.call(result, \"errors\")) {\n                // Data error\n                throwServerError(response, result, \"Server response was missing for query '\".concat(Array.isArray(operations) ?\n                    operations.map(function (op) { return op.operationName; })\n                    : operations.operationName, \"'.\"));\n            }\n            return result;\n        });\n    };\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\nexport var serializeFetchParameter = function (p, label) {\n    var serialized;\n    try {\n        serialized = JSON.stringify(p);\n    }\n    catch (e) {\n        var parseError = newInvariantError(39, label, e.message);\n        parseError.parseError = e;\n        throw parseError;\n    }\n    return serialized;\n};\n", "import { __assign, __spreadArray } from \"tslib\";\nimport { print } from \"../../utilities/index.js\";\nvar defaultHttpOptions = {\n    includeQuery: true,\n    includeExtensions: false,\n    preserveHeaderCase: false,\n};\nvar defaultHeaders = {\n    // headers are case insensitive (https://stackoverflow.com/a/5259004)\n    accept: \"*/*\",\n    // The content-type header describes the type of the body of the request, and\n    // so it typically only is sent with requests that actually have bodies. One\n    // could imagine that Apollo Client would remove this header when constructing\n    // a GET request (which has no body), but we historically have not done that.\n    // This means that browsers will preflight all Apollo Client requests (even\n    // GET requests). Apollo Server's CSRF prevention feature (introduced in\n    // AS3.7) takes advantage of this fact and does not block requests with this\n    // header. If you want to drop this header from GET requests, then you should\n    // probably replace it with a `apollo-require-preflight` header, or servers\n    // with CSRF prevention enabled might block your GET request. See\n    // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf\n    // for more details.\n    \"content-type\": \"application/json\",\n};\nvar defaultOptions = {\n    method: \"POST\",\n};\nexport var fallbackHttpConfig = {\n    http: defaultHttpOptions,\n    headers: defaultHeaders,\n    options: defaultOptions,\n};\nexport var defaultPrinter = function (ast, printer) { return printer(ast); };\nexport function selectHttpOptionsAndBody(operation, fallbackConfig) {\n    var configs = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        configs[_i - 2] = arguments[_i];\n    }\n    configs.unshift(fallbackConfig);\n    return selectHttpOptionsAndBodyInternal.apply(void 0, __spreadArray([operation,\n        defaultPrinter], configs, false));\n}\nexport function selectHttpOptionsAndBodyInternal(operation, printer) {\n    var configs = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        configs[_i - 2] = arguments[_i];\n    }\n    var options = {};\n    var http = {};\n    configs.forEach(function (config) {\n        options = __assign(__assign(__assign({}, options), config.options), { headers: __assign(__assign({}, options.headers), config.headers) });\n        if (config.credentials) {\n            options.credentials = config.credentials;\n        }\n        http = __assign(__assign({}, http), config.http);\n    });\n    if (options.headers) {\n        options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);\n    }\n    //The body depends on the http options\n    var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;\n    var body = { operationName: operationName, variables: variables };\n    if (http.includeExtensions)\n        body.extensions = extensions;\n    // not sending the query (i.e persisted queries)\n    if (http.includeQuery)\n        body.query = printer(query, print);\n    return {\n        options: options,\n        body: body,\n    };\n}\n// Remove potential duplicate header names, preserving last (by insertion order).\n// This is done to prevent unintentionally duplicating a header instead of\n// overwriting it (See #8447 and #8449).\nfunction removeDuplicateHeaders(headers, preserveHeaderCase) {\n    // If we're not preserving the case, just remove duplicates w/ normalization.\n    if (!preserveHeaderCase) {\n        var normalizedHeaders_1 = Object.create(null);\n        Object.keys(Object(headers)).forEach(function (name) {\n            normalizedHeaders_1[name.toLowerCase()] = headers[name];\n        });\n        return normalizedHeaders_1;\n    }\n    // If we are preserving the case, remove duplicates w/ normalization,\n    // preserving the original name.\n    // This allows for non-http-spec-compliant servers that expect intentionally\n    // capitalized header names (See #6741).\n    var headerData = Object.create(null);\n    Object.keys(Object(headers)).forEach(function (name) {\n        headerData[name.toLowerCase()] = {\n            originalName: name,\n            value: headers[name],\n        };\n    });\n    var normalizedHeaders = Object.create(null);\n    Object.keys(headerData).forEach(function (name) {\n        normalizedHeaders[headerData[name].originalName] = headerData[name].value;\n    });\n    return normalizedHeaders;\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\nexport var checkFetcher = function (fetcher) {\n    if (!fetcher && typeof fetch === \"undefined\") {\n        throw newInvariantError(37);\n    }\n};\n", "/**\n * @deprecated\n * This is not used internally any more and will be removed in\n * the next major version of Apollo Client.\n */\nexport var createSignalIfSupported = function () {\n    if (typeof AbortController === \"undefined\")\n        return { controller: false, signal: false };\n    var controller = new AbortController();\n    var signal = controller.signal;\n    return { controller: controller, signal: signal };\n};\n", "export var selectURI = function (operation, fallbackURI) {\n    var context = operation.getContext();\n    var contextURI = context.uri;\n    if (contextURI) {\n        return contextURI;\n    }\n    else if (typeof fallbackURI === \"function\") {\n        return fallbackURI(operation);\n    }\n    else {\n        return fallbackURI || \"/graphql\";\n    }\n};\n", "import { serializeFetchParameter } from \"./serializeFetchParameter.js\";\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nexport function rewriteURIForGET(chosenURI, body) {\n    // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n    // the extra level of JSON serialization!\n    var queryParams = [];\n    var addQueryParam = function (key, value) {\n        queryParams.push(\"\".concat(key, \"=\").concat(encodeURIComponent(value)));\n    };\n    if (\"query\" in body) {\n        addQueryParam(\"query\", body.query);\n    }\n    if (body.operationName) {\n        addQueryParam(\"operationName\", body.operationName);\n    }\n    if (body.variables) {\n        var serializedVariables = void 0;\n        try {\n            serializedVariables = serializeFetchParameter(body.variables, \"Variables map\");\n        }\n        catch (parseError) {\n            return { parseError: parseError };\n        }\n        addQueryParam(\"variables\", serializedVariables);\n    }\n    if (body.extensions) {\n        var serializedExtensions = void 0;\n        try {\n            serializedExtensions = serializeFetchParameter(body.extensions, \"Extensions map\");\n        }\n        catch (parseError) {\n            return { parseError: parseError };\n        }\n        addQueryParam(\"extensions\", serializedExtensions);\n    }\n    // Reconstruct the URI with added query params.\n    // XXX This assumes that the URI is well-formed and that it doesn't\n    //     already contain any of these query params. We could instead use the\n    //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n    //     don't support URLSearchParams. Note that some browsers (and\n    //     versions of whatwg-url) support URL but not URLSearchParams!\n    var fragment = \"\", preFragment = chosenURI;\n    var fragmentStart = chosenURI.indexOf(\"#\");\n    if (fragmentStart !== -1) {\n        fragment = chosenURI.substr(fragmentStart);\n        preFragment = chosenURI.substr(0, fragmentStart);\n    }\n    var queryParamsPrefix = preFragment.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n    var newURI = preFragment + queryParamsPrefix + queryParams.join(\"&\") + fragment;\n    return { newURI: newURI };\n}\n", "import { __assign, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { ApolloLink } from \"../core/index.js\";\nimport { Observable, hasDirectives } from \"../../utilities/index.js\";\nimport { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport { selectURI } from \"./selectURI.js\";\nimport { handleError, readMultipartBody, parseAndCheckHttpResponse, } from \"./parseAndCheckHttpResponse.js\";\nimport { checkFetcher } from \"./checkFetcher.js\";\nimport { selectHttpOptionsAndBodyInternal, defaultPrinter, fallbackHttpConfig, } from \"./selectHttpOptionsAndBody.js\";\nimport { rewriteURIForGET } from \"./rewriteURIForGET.js\";\nimport { fromError, filterOperationVariables } from \"../utils/index.js\";\nimport { maybe, getMainDefinition, removeClientSetsFromDocument, } from \"../../utilities/index.js\";\nvar backupFetch = maybe(function () { return fetch; });\nexport var createHttpLink = function (linkOptions) {\n    if (linkOptions === void 0) { linkOptions = {}; }\n    var _a = linkOptions.uri, uri = _a === void 0 ? \"/graphql\" : _a, \n    // use default global fetch if nothing passed in\n    preferredFetch = linkOptions.fetch, _b = linkOptions.print, print = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = __rest(linkOptions, [\"uri\", \"fetch\", \"print\", \"includeExtensions\", \"preserveHeaderCase\", \"useGETForQueries\", \"includeUnusedVariables\"]);\n    if (globalThis.__DEV__ !== false) {\n        // Make sure at least one of preferredFetch, window.fetch, or backupFetch is\n        // defined, so requests won't fail at runtime.\n        checkFetcher(preferredFetch || backupFetch);\n    }\n    var linkConfig = {\n        http: { includeExtensions: includeExtensions, preserveHeaderCase: preserveHeaderCase },\n        options: requestOptions.fetchOptions,\n        credentials: requestOptions.credentials,\n        headers: requestOptions.headers,\n    };\n    return new ApolloLink(function (operation) {\n        var chosenURI = selectURI(operation, uri);\n        var context = operation.getContext();\n        // `apollographql-client-*` headers are automatically set if a\n        // `clientAwareness` object is found in the context. These headers are\n        // set first, followed by the rest of the headers pulled from\n        // `context.headers`. If desired, `apollographql-client-*` headers set by\n        // the `clientAwareness` object can be overridden by\n        // `apollographql-client-*` headers set in `context.headers`.\n        var clientAwarenessHeaders = {};\n        if (context.clientAwareness) {\n            var _a = context.clientAwareness, name_1 = _a.name, version = _a.version;\n            if (name_1) {\n                clientAwarenessHeaders[\"apollographql-client-name\"] = name_1;\n            }\n            if (version) {\n                clientAwarenessHeaders[\"apollographql-client-version\"] = version;\n            }\n        }\n        var contextHeaders = __assign(__assign({}, clientAwarenessHeaders), context.headers);\n        var contextConfig = {\n            http: context.http,\n            options: context.fetchOptions,\n            credentials: context.credentials,\n            headers: contextHeaders,\n        };\n        if (hasDirectives([\"client\"], operation.query)) {\n            var transformedQuery = removeClientSetsFromDocument(operation.query);\n            if (!transformedQuery) {\n                return fromError(new Error(\"HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`.\"));\n            }\n            operation.query = transformedQuery;\n        }\n        //uses fallback, link, and then context to build options\n        var _b = selectHttpOptionsAndBodyInternal(operation, print, fallbackHttpConfig, linkConfig, contextConfig), options = _b.options, body = _b.body;\n        if (body.variables && !includeUnusedVariables) {\n            body.variables = filterOperationVariables(body.variables, operation.query);\n        }\n        var controller;\n        if (!options.signal && typeof AbortController !== \"undefined\") {\n            controller = new AbortController();\n            options.signal = controller.signal;\n        }\n        // If requested, set method to GET if there are no mutations.\n        var definitionIsMutation = function (d) {\n            return d.kind === \"OperationDefinition\" && d.operation === \"mutation\";\n        };\n        var definitionIsSubscription = function (d) {\n            return d.kind === \"OperationDefinition\" && d.operation === \"subscription\";\n        };\n        var isSubscription = definitionIsSubscription(getMainDefinition(operation.query));\n        // does not match custom directives beginning with @defer\n        var hasDefer = hasDirectives([\"defer\"], operation.query);\n        if (useGETForQueries &&\n            !operation.query.definitions.some(definitionIsMutation)) {\n            options.method = \"GET\";\n        }\n        if (hasDefer || isSubscription) {\n            options.headers = options.headers || {};\n            var acceptHeader = \"multipart/mixed;\";\n            // Omit defer-specific headers if the user attempts to defer a selection\n            // set on a subscription and log a warning.\n            if (isSubscription && hasDefer) {\n                globalThis.__DEV__ !== false && invariant.warn(38);\n            }\n            if (isSubscription) {\n                acceptHeader +=\n                    \"boundary=graphql;subscriptionSpec=1.0,application/json\";\n            }\n            else if (hasDefer) {\n                acceptHeader += \"deferSpec=20220824,application/json\";\n            }\n            options.headers.accept = acceptHeader;\n        }\n        if (options.method === \"GET\") {\n            var _c = rewriteURIForGET(chosenURI, body), newURI = _c.newURI, parseError = _c.parseError;\n            if (parseError) {\n                return fromError(parseError);\n            }\n            chosenURI = newURI;\n        }\n        else {\n            try {\n                options.body = serializeFetchParameter(body, \"Payload\");\n            }\n            catch (parseError) {\n                return fromError(parseError);\n            }\n        }\n        return new Observable(function (observer) {\n            // Prefer linkOptions.fetch (preferredFetch) if provided, and otherwise\n            // fall back to the *current* global window.fetch function (see issue\n            // #7832), or (if all else fails) the backupFetch function we saved when\n            // this module was first evaluated. This last option protects against the\n            // removal of window.fetch, which is unlikely but not impossible.\n            var currentFetch = preferredFetch || maybe(function () { return fetch; }) || backupFetch;\n            var observerNext = observer.next.bind(observer);\n            currentFetch(chosenURI, options)\n                .then(function (response) {\n                var _a;\n                operation.setContext({ response: response });\n                var ctype = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.get(\"content-type\");\n                if (ctype !== null && /^multipart\\/mixed/i.test(ctype)) {\n                    return readMultipartBody(response, observerNext);\n                }\n                else {\n                    return parseAndCheckHttpResponse(operation)(response).then(observerNext);\n                }\n            })\n                .then(function () {\n                controller = undefined;\n                observer.complete();\n            })\n                .catch(function (err) {\n                controller = undefined;\n                handleError(err, observer);\n            });\n            return function () {\n                // XXX support canceling this request\n                // https://developers.google.com/web/updates/2017/09/abortable-fetch\n                if (controller)\n                    controller.abort();\n            };\n        });\n    });\n};\n", "import { __extends } from \"tslib\";\nimport { ApolloLink } from \"../core/index.js\";\nimport { createHttpLink } from \"./createHttpLink.js\";\nvar HttpLink = /** @class */ (function (_super) {\n    __extends(HttpLink, _super);\n    function HttpLink(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, createHttpLink(options).request) || this;\n        _this.options = options;\n        return _this;\n    }\n    return HttpLink;\n}(ApolloLink));\nexport { HttpLink };\n", "const { toString, hasOwnProperty } = Object.prototype;\nconst fnToStr = Function.prototype.toString;\nconst previousComparisons = new Map();\n/**\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\n */\nexport function equal(a, b) {\n    try {\n        return check(a, b);\n    }\n    finally {\n        previousComparisons.clear();\n    }\n}\n// Allow default imports as well.\nexport default equal;\nfunction check(a, b) {\n    // If the two values are strictly equal, our job is easy.\n    if (a === b) {\n        return true;\n    }\n    // Object.prototype.toString returns a representation of the runtime type of\n    // the given value that is considerably more precise than typeof.\n    const aTag = toString.call(a);\n    const bTag = toString.call(b);\n    // If the runtime types of a and b are different, they could maybe be equal\n    // under some interpretation of equality, but for simplicity and performance\n    // we just return false instead.\n    if (aTag !== bTag) {\n        return false;\n    }\n    switch (aTag) {\n        case '[object Array]':\n            // Arrays are a lot like other objects, but we can cheaply compare their\n            // lengths as a short-cut before comparing their elements.\n            if (a.length !== b.length)\n                return false;\n        // Fall through to object case...\n        case '[object Object]': {\n            if (previouslyCompared(a, b))\n                return true;\n            const aKeys = definedKeys(a);\n            const bKeys = definedKeys(b);\n            // If `a` and `b` have a different number of enumerable keys, they\n            // must be different.\n            const keyCount = aKeys.length;\n            if (keyCount !== bKeys.length)\n                return false;\n            // Now make sure they have the same keys.\n            for (let k = 0; k < keyCount; ++k) {\n                if (!hasOwnProperty.call(b, aKeys[k])) {\n                    return false;\n                }\n            }\n            // Finally, check deep equality of all child properties.\n            for (let k = 0; k < keyCount; ++k) {\n                const key = aKeys[k];\n                if (!check(a[key], b[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        case '[object Error]':\n            return a.name === b.name && a.message === b.message;\n        case '[object Number]':\n            // Handle NaN, which is !== itself.\n            if (a !== a)\n                return b !== b;\n        // Fall through to shared +a === +b case...\n        case '[object Boolean]':\n        case '[object Date]':\n            return +a === +b;\n        case '[object RegExp]':\n        case '[object String]':\n            return a == `${b}`;\n        case '[object Map]':\n        case '[object Set]': {\n            if (a.size !== b.size)\n                return false;\n            if (previouslyCompared(a, b))\n                return true;\n            const aIterator = a.entries();\n            const isMap = aTag === '[object Map]';\n            while (true) {\n                const info = aIterator.next();\n                if (info.done)\n                    break;\n                // If a instanceof Set, aValue === aKey.\n                const [aKey, aValue] = info.value;\n                // So this works the same way for both Set and Map.\n                if (!b.has(aKey)) {\n                    return false;\n                }\n                // However, we care about deep equality of values only when dealing\n                // with Map structures.\n                if (isMap && !check(aValue, b.get(aKey))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        case '[object Uint16Array]':\n        case '[object Uint8Array]': // Buffer, in Node.js.\n        case '[object Uint32Array]':\n        case '[object Int32Array]':\n        case '[object Int8Array]':\n        case '[object Int16Array]':\n        case '[object ArrayBuffer]':\n            // DataView doesn't need these conversions, but the equality check is\n            // otherwise the same.\n            a = new Uint8Array(a);\n            b = new Uint8Array(b);\n        // Fall through...\n        case '[object DataView]': {\n            let len = a.byteLength;\n            if (len === b.byteLength) {\n                while (len-- && a[len] === b[len]) {\n                    // Keep looping as long as the bytes are equal.\n                }\n            }\n            return len === -1;\n        }\n        case '[object AsyncFunction]':\n        case '[object GeneratorFunction]':\n        case '[object AsyncGeneratorFunction]':\n        case '[object Function]': {\n            const aCode = fnToStr.call(a);\n            if (aCode !== fnToStr.call(b)) {\n                return false;\n            }\n            // We consider non-native functions equal if they have the same code\n            // (native functions require === because their code is censored).\n            // Note that this behavior is not entirely sound, since !== function\n            // objects with the same code can behave differently depending on\n            // their closure scope. However, any function can behave differently\n            // depending on the values of its input arguments (including this)\n            // and its calling context (including its closure scope), even\n            // though the function object is === to itself; and it is entirely\n            // possible for functions that are not === to behave exactly the\n            // same under all conceivable circumstances. Because none of these\n            // factors are statically decidable in JavaScript, JS function\n            // equality is not well-defined. This ambiguity allows us to\n            // consider the best possible heuristic among various imperfect\n            // options, and equating non-native functions that have the same\n            // code has enormous practical benefits, such as when comparing\n            // functions that are repeatedly passed as fresh function\n            // expressions within objects that are otherwise deeply equal. Since\n            // any function created from the same syntactic expression (in the\n            // same code location) will always stringify to the same code\n            // according to fnToStr.call, we can reasonably expect these\n            // repeatedly passed function expressions to have the same code, and\n            // thus behave \"the same\" (with all the caveats mentioned above),\n            // even though the runtime function objects are !== to one another.\n            return !endsWith(aCode, nativeCodeSuffix);\n        }\n    }\n    // Otherwise the values are not equal.\n    return false;\n}\nfunction definedKeys(obj) {\n    // Remember that the second argument to Array.prototype.filter will be\n    // used as `this` within the callback function.\n    return Object.keys(obj).filter(isDefinedKey, obj);\n}\nfunction isDefinedKey(key) {\n    return this[key] !== void 0;\n}\nconst nativeCodeSuffix = \"{ [native code] }\";\nfunction endsWith(full, suffix) {\n    const fromIndex = full.length - suffix.length;\n    return fromIndex >= 0 &&\n        full.indexOf(suffix, fromIndex) === fromIndex;\n}\nfunction previouslyCompared(a, b) {\n    // Though cyclic references can make an object graph appear infinite from the\n    // perspective of a depth-first traversal, the graph still contains a finite\n    // number of distinct object references. We use the previousComparisons cache\n    // to avoid comparing the same pair of object references more than once, which\n    // guarantees termination (even if we end up comparing every object in one\n    // graph to every object in the other graph, which is extremely unlikely),\n    // while still allowing weird isomorphic structures (like rings with different\n    // lengths) a chance to pass the equality test.\n    let bSet = previousComparisons.get(a);\n    if (bSet) {\n        // Return true here because we can be sure false will be returned somewhere\n        // else if the objects are not equivalent.\n        if (bSet.has(b))\n            return true;\n    }\n    else {\n        previousComparisons.set(a, bSet = new Set);\n    }\n    bSet.add(b);\n    return false;\n}\n", "// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\nconst { hasOwnProperty } = Object.prototype;\nexport class Trie {\n    constructor(weakness = true, makeData = defaultMakeData) {\n        this.weakness = weakness;\n        this.makeData = makeData;\n    }\n    lookup(...array) {\n        return this.lookupArray(array);\n    }\n    lookupArray(array) {\n        let node = this;\n        forEach.call(array, key => node = node.getChildTrie(key));\n        return hasOwnProperty.call(node, \"data\")\n            ? node.data\n            : node.data = this.makeData(slice.call(array));\n    }\n    peek(...array) {\n        return this.peekArray(array);\n    }\n    peekArray(array) {\n        let node = this;\n        for (let i = 0, len = array.length; node && i < len; ++i) {\n            const map = this.weakness && isObjRef(array[i]) ? node.weak : node.strong;\n            node = map && map.get(array[i]);\n        }\n        return node && node.data;\n    }\n    getChildTrie(key) {\n        const map = this.weakness && isObjRef(key)\n            ? this.weak || (this.weak = new WeakMap())\n            : this.strong || (this.strong = new Map());\n        let child = map.get(key);\n        if (!child)\n            map.set(key, child = new Trie(this.weakness, this.makeData));\n        return child;\n    }\n}\nfunction isObjRef(value) {\n    switch (typeof value) {\n        case \"object\":\n            if (value === null)\n                break;\n        // Fall through to return true...\n        case \"function\":\n            return true;\n    }\n    return false;\n}\n", "function defaultDispose() { }\nexport class StrongCache {\n    constructor(max = Infinity, dispose = defaultDispose) {\n        this.max = max;\n        this.dispose = dispose;\n        this.map = new Map();\n        this.newest = null;\n        this.oldest = null;\n    }\n    has(key) {\n        return this.map.has(key);\n    }\n    get(key) {\n        const node = this.getNode(key);\n        return node && node.value;\n    }\n    get size() {\n        return this.map.size;\n    }\n    getNode(key) {\n        const node = this.map.get(key);\n        if (node && node !== this.newest) {\n            const { older, newer } = node;\n            if (newer) {\n                newer.older = older;\n            }\n            if (older) {\n                older.newer = newer;\n            }\n            node.older = this.newest;\n            node.older.newer = node;\n            node.newer = null;\n            this.newest = node;\n            if (node === this.oldest) {\n                this.oldest = newer;\n            }\n        }\n        return node;\n    }\n    set(key, value) {\n        let node = this.getNode(key);\n        if (node) {\n            return node.value = value;\n        }\n        node = {\n            key,\n            value,\n            newer: null,\n            older: this.newest\n        };\n        if (this.newest) {\n            this.newest.newer = node;\n        }\n        this.newest = node;\n        this.oldest = this.oldest || node;\n        this.map.set(key, node);\n        return node.value;\n    }\n    clean() {\n        while (this.oldest && this.map.size > this.max) {\n            this.delete(this.oldest.key);\n        }\n    }\n    delete(key) {\n        const node = this.map.get(key);\n        if (node) {\n            if (node === this.newest) {\n                this.newest = node.older;\n            }\n            if (node === this.oldest) {\n                this.oldest = node.newer;\n            }\n            if (node.newer) {\n                node.newer.older = node.older;\n            }\n            if (node.older) {\n                node.older.newer = node.newer;\n            }\n            this.map.delete(key);\n            this.dispose(node.value, key);\n            return true;\n        }\n        return false;\n    }\n}\n", "// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext = null;\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE = {};\nlet idCounter = 1;\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = () => class Slot {\n    constructor() {\n        // If you have a Slot object, you can find out its slot.id, but you cannot\n        // guess the slot.id of a Slot you don't have access to, thanks to the\n        // randomized suffix.\n        this.id = [\n            \"slot\",\n            idCounter++,\n            Date.now(),\n            Math.random().toString(36).slice(2),\n        ].join(\":\");\n    }\n    hasValue() {\n        for (let context = currentContext; context; context = context.parent) {\n            // We use the Slot object iself as a key to its value, which means the\n            // value cannot be obtained without a reference to the Slot object.\n            if (this.id in context.slots) {\n                const value = context.slots[this.id];\n                if (value === MISSING_VALUE)\n                    break;\n                if (context !== currentContext) {\n                    // Cache the value in currentContext.slots so the next lookup will\n                    // be faster. This caching is safe because the tree of contexts and\n                    // the values of the slots are logically immutable.\n                    currentContext.slots[this.id] = value;\n                }\n                return true;\n            }\n        }\n        if (currentContext) {\n            // If a value was not found for this Slot, it's never going to be found\n            // no matter how many times we look it up, so we might as well cache\n            // the absence of the value, too.\n            currentContext.slots[this.id] = MISSING_VALUE;\n        }\n        return false;\n    }\n    getValue() {\n        if (this.hasValue()) {\n            return currentContext.slots[this.id];\n        }\n    }\n    withValue(value, callback, \n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args, thisArg) {\n        const slots = {\n            __proto__: null,\n            [this.id]: value,\n        };\n        const parent = currentContext;\n        currentContext = { parent, slots };\n        try {\n            // Function.prototype.apply allows the arguments array argument to be\n            // omitted or undefined, so args! is fine here.\n            return callback.apply(thisArg, args);\n        }\n        finally {\n            currentContext = parent;\n        }\n    }\n    // Capture the current context and wrap a callback function so that it\n    // reestablishes the captured context when called.\n    static bind(callback) {\n        const context = currentContext;\n        return function () {\n            const saved = currentContext;\n            try {\n                currentContext = context;\n                return callback.apply(this, arguments);\n            }\n            finally {\n                currentContext = saved;\n            }\n        };\n    }\n    // Immediately run a callback function without any captured context.\n    static noContext(callback, \n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args, thisArg) {\n        if (currentContext) {\n            const saved = currentContext;\n            try {\n                currentContext = null;\n                // Function.prototype.apply allows the arguments array argument to be\n                // omitted or undefined, so args! is fine here.\n                return callback.apply(thisArg, args);\n            }\n            finally {\n                currentContext = saved;\n            }\n        }\n        else {\n            return callback.apply(thisArg, args);\n        }\n    }\n};\nfunction maybe(fn) {\n    try {\n        return fn();\n    }\n    catch (ignored) { }\n}\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable property of the globalThis object. This obfuscation does\n// nothing to prevent access to the Slot class, but at least it ensures the\n// implementation (i.e. currentContext) cannot be tampered with, and all copies\n// of the @wry/context package (hopefully just one) will share the same Slot\n// implementation. Since the first copy of the @wry/context package to be\n// imported wins, this technique imposes a steep cost for any future breaking\n// changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\nconst host = \n// Prefer globalThis when available.\n// https://github.com/benjamn/wryware/issues/347\nmaybe(() => globalThis) ||\n    // Fall back to global, which works in Node.js and may be converted by some\n    // bundlers to the appropriate identifier (window, self, ...) depending on the\n    // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224\n    maybe(() => global) ||\n    // Otherwise, use a dummy host that's local to this module. We used to fall\n    // back to using the Array constructor as a namespace, but that was flagged in\n    // https://github.com/benjamn/wryware/issues/347, and can be avoided.\n    Object.create(null);\n// Whichever globalHost we're using, make TypeScript happy about the additional\n// globalKey property.\nconst globalHost = host;\nexport const Slot = globalHost[globalKey] ||\n    // Earlier versions of this package stored the globalKey property on the Array\n    // constructor, so we check there as well, to prevent Slot class duplication.\n    Array[globalKey] ||\n    (function (Slot) {\n        try {\n            Object.defineProperty(globalHost, globalKey, {\n                value: Slot,\n                enumerable: false,\n                writable: false,\n                // When it was possible for globalHost to be the Array constructor (a\n                // legacy Slot dedup strategy), it was important for the property to be\n                // configurable:true so it could be deleted. That does not seem to be as\n                // important when globalHost is the global object, but I don't want to\n                // cause similar problems again, and configurable:true seems safest.\n                // https://github.com/endojs/endo/issues/576#issuecomment-1178274008\n                configurable: true\n            });\n        }\n        finally {\n            return Slot;\n        }\n    })(makeSlotClass());\n", "import { Slot } from \"./slot.js\";\nexport { Slot };\nexport const { bind, noContext } = Slot;\n// Like global.setTimeout, except the callback runs with captured context.\nexport { setTimeoutWithContext as setTimeout };\nfunction setTimeoutWithContext(callback, delay) {\n    return setTimeout(bind(callback), delay);\n}\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nexport function asyncFromGen(genFn) {\n    return function () {\n        const gen = genFn.apply(this, arguments);\n        const boundNext = bind(gen.next);\n        const boundThrow = bind(gen.throw);\n        return new Promise((resolve, reject) => {\n            function invoke(method, argument) {\n                try {\n                    var result = method.call(gen, argument);\n                }\n                catch (error) {\n                    return reject(error);\n                }\n                const next = result.done ? resolve : invokeNext;\n                if (isPromiseLike(result.value)) {\n                    result.value.then(next, result.done ? reject : invokeThrow);\n                }\n                else {\n                    next(result.value);\n                }\n            }\n            const invokeNext = (value) => invoke(boundNext, value);\n            const invokeThrow = (error) => invoke(boundThrow, error);\n            invokeNext();\n        });\n    };\n}\nfunction isPromiseLike(value) {\n    return value && typeof value.then === \"function\";\n}\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nconst wrappedFibers = [];\nexport function wrapYieldingFiberMethods(Fiber) {\n    // There can be only one implementation of Fiber per process, so this array\n    // should never grow longer than one element.\n    if (wrappedFibers.indexOf(Fiber) < 0) {\n        const wrap = (obj, method) => {\n            const fn = obj[method];\n            obj[method] = function () {\n                return noContext(fn, arguments, this);\n            };\n        };\n        // These methods can yield, according to\n        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n        wrap(Fiber, \"yield\");\n        wrap(Fiber.prototype, \"run\");\n        wrap(Fiber.prototype, \"throwInto\");\n        wrappedFibers.push(Fiber);\n    }\n    return Fiber;\n}\n", "import { Slot } from \"@wry/context\";\nexport const parentEntrySlot = new Slot();\nexport function nonReactive(fn) {\n    return parentEntrySlot.withValue(void 0, fn);\n}\nexport { Slot };\nexport { bind as bindContext, noContext, setTimeout, asyncFromGen, } from \"@wry/context\";\n", "export const { hasOwnProperty, } = Object.prototype;\nexport const arrayFromSet = Array.from ||\n    function (set) {\n        const array = [];\n        set.forEach(item => array.push(item));\n        return array;\n    };\nexport function maybeUnsubscribe(entryOrDep) {\n    const { unsubscribe } = entryOrDep;\n    if (typeof unsubscribe === \"function\") {\n        entryOrDep.unsubscribe = void 0;\n        unsubscribe();\n    }\n}\n", "import { parentEntrySlot } from \"./context.js\";\nimport { maybeUnsubscribe, arrayFromSet } from \"./helpers.js\";\nconst emptySetPool = [];\nconst POOL_TARGET_SIZE = 100;\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition, optionalMessage) {\n    if (!condition) {\n        throw new Error(optionalMessage || \"assertion failure\");\n    }\n}\nfunction valueIs(a, b) {\n    const len = a.length;\n    return (\n    // Unknown values are not equal to each other.\n    len > 0 &&\n        // Both values must be ordinary (or both exceptional) to be equal.\n        len === b.length &&\n        // The underlying value or exception must be the same.\n        a[len - 1] === b[len - 1]);\n}\nfunction valueGet(value) {\n    switch (value.length) {\n        case 0: throw new Error(\"unknown value\");\n        case 1: return value[0];\n        case 2: throw value[1];\n    }\n}\nfunction valueCopy(value) {\n    return value.slice(0);\n}\nexport class Entry {\n    constructor(fn) {\n        this.fn = fn;\n        this.parents = new Set();\n        this.childValues = new Map();\n        // When this Entry has children that are dirty, this property becomes\n        // a Set containing other Entry objects, borrowed from emptySetPool.\n        // When the set becomes empty, it gets recycled back to emptySetPool.\n        this.dirtyChildren = null;\n        this.dirty = true;\n        this.recomputing = false;\n        this.value = [];\n        this.deps = null;\n        ++Entry.count;\n    }\n    peek() {\n        if (this.value.length === 1 && !mightBeDirty(this)) {\n            rememberParent(this);\n            return this.value[0];\n        }\n    }\n    // This is the most important method of the Entry API, because it\n    // determines whether the cached this.value can be returned immediately,\n    // or must be recomputed. The overall performance of the caching system\n    // depends on the truth of the following observations: (1) this.dirty is\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n    // (3) valueGet(this.value) is usually returned without recomputation.\n    recompute(args) {\n        assert(!this.recomputing, \"already recomputing\");\n        rememberParent(this);\n        return mightBeDirty(this)\n            ? reallyRecompute(this, args)\n            : valueGet(this.value);\n    }\n    setDirty() {\n        if (this.dirty)\n            return;\n        this.dirty = true;\n        reportDirty(this);\n        // We can go ahead and unsubscribe here, since any further dirty\n        // notifications we receive will be redundant, and unsubscribing may\n        // free up some resources, e.g. file watchers.\n        maybeUnsubscribe(this);\n    }\n    dispose() {\n        this.setDirty();\n        // Sever any dependency relationships with our own children, so those\n        // children don't retain this parent Entry in their child.parents sets,\n        // thereby preventing it from being fully garbage collected.\n        forgetChildren(this);\n        // Because this entry has been kicked out of the cache (in index.js),\n        // we've lost the ability to find out if/when this entry becomes dirty,\n        // whether that happens through a subscription, because of a direct call\n        // to entry.setDirty(), or because one of its children becomes dirty.\n        // Because of this loss of future information, we have to assume the\n        // worst (that this entry might have become dirty very soon), so we must\n        // immediately mark this entry's parents as dirty. Normally we could\n        // just call entry.setDirty() rather than calling parent.setDirty() for\n        // each parent, but that would leave this entry in parent.childValues\n        // and parent.dirtyChildren, which would prevent the child from being\n        // truly forgotten.\n        eachParent(this, (parent, child) => {\n            parent.setDirty();\n            forgetChild(parent, this);\n        });\n    }\n    forget() {\n        // The code that creates Entry objects in index.ts will replace this method\n        // with one that actually removes the Entry from the cache, which will also\n        // trigger the entry.dispose method.\n        this.dispose();\n    }\n    dependOn(dep) {\n        dep.add(this);\n        if (!this.deps) {\n            this.deps = emptySetPool.pop() || new Set();\n        }\n        this.deps.add(dep);\n    }\n    forgetDeps() {\n        if (this.deps) {\n            arrayFromSet(this.deps).forEach(dep => dep.delete(this));\n            this.deps.clear();\n            emptySetPool.push(this.deps);\n            this.deps = null;\n        }\n    }\n}\nEntry.count = 0;\nfunction rememberParent(child) {\n    const parent = parentEntrySlot.getValue();\n    if (parent) {\n        child.parents.add(parent);\n        if (!parent.childValues.has(child)) {\n            parent.childValues.set(child, []);\n        }\n        if (mightBeDirty(child)) {\n            reportDirtyChild(parent, child);\n        }\n        else {\n            reportCleanChild(parent, child);\n        }\n        return parent;\n    }\n}\nfunction reallyRecompute(entry, args) {\n    forgetChildren(entry);\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\n    parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);\n    if (maybeSubscribe(entry, args)) {\n        // If we successfully recomputed entry.value and did not fail to\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\n        setClean(entry);\n    }\n    return valueGet(entry.value);\n}\nfunction recomputeNewValue(entry, args) {\n    entry.recomputing = true;\n    const { normalizeResult } = entry;\n    let oldValueCopy;\n    if (normalizeResult && entry.value.length === 1) {\n        oldValueCopy = valueCopy(entry.value);\n    }\n    // Make entry.value an empty array, representing an unknown value.\n    entry.value.length = 0;\n    try {\n        // If entry.fn succeeds, entry.value will become a normal Value.\n        entry.value[0] = entry.fn.apply(null, args);\n        // If we have a viable oldValueCopy to compare with the (successfully\n        // recomputed) new entry.value, and they are not already === identical, give\n        // normalizeResult a chance to pick/choose/reuse parts of oldValueCopy[0]\n        // and/or entry.value[0] to determine the final cached entry.value.\n        if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {\n            try {\n                entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);\n            }\n            catch (_a) {\n                // If normalizeResult throws, just use the newer value, rather than\n                // saving the exception as entry.value[1].\n            }\n        }\n    }\n    catch (e) {\n        // If entry.fn throws, entry.value will hold that exception.\n        entry.value[1] = e;\n    }\n    // Either way, this line is always reached.\n    entry.recomputing = false;\n}\nfunction mightBeDirty(entry) {\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\nfunction setClean(entry) {\n    entry.dirty = false;\n    if (mightBeDirty(entry)) {\n        // This Entry may still have dirty children, in which case we can't\n        // let our parents know we're clean just yet.\n        return;\n    }\n    reportClean(entry);\n}\nfunction reportDirty(child) {\n    eachParent(child, reportDirtyChild);\n}\nfunction reportClean(child) {\n    eachParent(child, reportCleanChild);\n}\nfunction eachParent(child, callback) {\n    const parentCount = child.parents.size;\n    if (parentCount) {\n        const parents = arrayFromSet(child.parents);\n        for (let i = 0; i < parentCount; ++i) {\n            callback(parents[i], child);\n        }\n    }\n}\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(parent, child) {\n    // Must have called rememberParent(child) before calling\n    // reportDirtyChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(mightBeDirty(child));\n    const parentWasClean = !mightBeDirty(parent);\n    if (!parent.dirtyChildren) {\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\n    }\n    else if (parent.dirtyChildren.has(child)) {\n        // If we already know this child is dirty, then we must have already\n        // informed our own parents that we are dirty, so we can terminate\n        // the recursion early.\n        return;\n    }\n    parent.dirtyChildren.add(child);\n    // If parent was clean before, it just became (possibly) dirty (according to\n    // mightBeDirty), since we just added child to parent.dirtyChildren.\n    if (parentWasClean) {\n        reportDirty(parent);\n    }\n}\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(parent, child) {\n    // Must have called rememberChild(child) before calling\n    // reportCleanChild(parent, child).\n    assert(parent.childValues.has(child));\n    assert(!mightBeDirty(child));\n    const childValue = parent.childValues.get(child);\n    if (childValue.length === 0) {\n        parent.childValues.set(child, valueCopy(child.value));\n    }\n    else if (!valueIs(childValue, child.value)) {\n        parent.setDirty();\n    }\n    removeDirtyChild(parent, child);\n    if (mightBeDirty(parent)) {\n        return;\n    }\n    reportClean(parent);\n}\nfunction removeDirtyChild(parent, child) {\n    const dc = parent.dirtyChildren;\n    if (dc) {\n        dc.delete(child);\n        if (dc.size === 0) {\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\n                emptySetPool.push(dc);\n            }\n            parent.dirtyChildren = null;\n        }\n    }\n}\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(parent) {\n    if (parent.childValues.size > 0) {\n        parent.childValues.forEach((_value, child) => {\n            forgetChild(parent, child);\n        });\n    }\n    // Remove this parent Entry from any sets to which it was added by the\n    // addToSet method.\n    parent.forgetDeps();\n    // After we forget all our children, this.dirtyChildren must be empty\n    // and therefore must have been reset to null.\n    assert(parent.dirtyChildren === null);\n}\nfunction forgetChild(parent, child) {\n    child.parents.delete(parent);\n    parent.childValues.delete(child);\n    removeDirtyChild(parent, child);\n}\nfunction maybeSubscribe(entry, args) {\n    if (typeof entry.subscribe === \"function\") {\n        try {\n            maybeUnsubscribe(entry); // Prevent double subscriptions.\n            entry.unsubscribe = entry.subscribe.apply(null, args);\n        }\n        catch (e) {\n            // If this Entry has a subscribe function and it threw an exception\n            // (or an unsubscribe function it previously returned now throws),\n            // return false to indicate that we were not able to subscribe (or\n            // unsubscribe), and this Entry should remain dirty.\n            entry.setDirty();\n            return false;\n        }\n    }\n    // Returning true indicates either that there was no entry.subscribe\n    // function or that it succeeded.\n    return true;\n}\n", "import { parentEntrySlot } from \"./context.js\";\nimport { hasOwnProperty, maybeUnsubscribe, arrayFromSet, } from \"./helpers.js\";\nconst EntryMethods = {\n    setDirty: true,\n    dispose: true,\n    forget: true, // Fully remove parent Entry from LRU cache and computation graph\n};\nexport function dep(options) {\n    const depsByKey = new Map();\n    const subscribe = options && options.subscribe;\n    function depend(key) {\n        const parent = parentEntrySlot.getValue();\n        if (parent) {\n            let dep = depsByKey.get(key);\n            if (!dep) {\n                depsByKey.set(key, dep = new Set);\n            }\n            parent.dependOn(dep);\n            if (typeof subscribe === \"function\") {\n                maybeUnsubscribe(dep);\n                dep.unsubscribe = subscribe(key);\n            }\n        }\n    }\n    depend.dirty = function dirty(key, entryMethodName) {\n        const dep = depsByKey.get(key);\n        if (dep) {\n            const m = (entryMethodName &&\n                hasOwnProperty.call(EntryMethods, entryMethodName)) ? entryMethodName : \"setDirty\";\n            // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n            // because modifying a Set while iterating over it can cause elements in\n            // the Set to be removed from the Set before they've been iterated over.\n            arrayFromSet(dep).forEach(entry => entry[m]());\n            depsByKey.delete(key);\n            maybeUnsubscribe(dep);\n        }\n    };\n    return depend;\n}\n", "import { Trie } from \"@wry/trie\";\nimport { StrongCache } from \"@wry/caches\";\nimport { Entry } from \"./entry.js\";\nimport { parentEntrySlot } from \"./context.js\";\n// These helper functions are important for making optimism work with\n// asynchronous code. In order to register parent-child dependencies,\n// optimism needs to know about any currently active parent computations.\n// In ordinary synchronous code, the parent context is implicit in the\n// execution stack, but asynchronous code requires some extra guidance in\n// order to propagate context from one async task segment to the next.\nexport { bindContext, noContext, nonReactive, setTimeout, asyncFromGen, Slot, } from \"./context.js\";\n// A lighter-weight dependency, similar to OptimisticWrapperFunction, except\n// with only one argument, no makeCacheKey, no wrapped function to recompute,\n// and no result value. Useful for representing dependency leaves in the graph\n// of computation. Subscriptions are supported.\nexport { dep } from \"./dep.js\";\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\n// a unique object for any shallow-identical list of arguments. If you need\n// to implement a custom makeCacheKey function, you may find it helpful to\n// delegate the final work to defaultMakeCacheKey, which is why we export it\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\n// does not support WeakMap, or you have the ability to return a string key.\n// In those cases, just write your own custom makeCacheKey functions.\nlet defaultKeyTrie;\nexport function defaultMakeCacheKey(...args) {\n    const trie = defaultKeyTrie || (defaultKeyTrie = new Trie(typeof WeakMap === \"function\"));\n    return trie.lookupArray(args);\n}\n// If you're paranoid about memory leaks, or you want to avoid using WeakMap\n// under the hood, but you still need the behavior of defaultMakeCacheKey,\n// import this constructor to create your own tries.\nexport { Trie as KeyTrie };\n;\nconst caches = new Set();\nexport function wrap(originalFunction, { max = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe, cache: cacheOption = StrongCache, } = Object.create(null)) {\n    const cache = typeof cacheOption === \"function\"\n        ? new cacheOption(max, entry => entry.dispose())\n        : cacheOption;\n    const optimistic = function () {\n        const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);\n        if (key === void 0) {\n            return originalFunction.apply(null, arguments);\n        }\n        let entry = cache.get(key);\n        if (!entry) {\n            cache.set(key, entry = new Entry(originalFunction));\n            entry.normalizeResult = normalizeResult;\n            entry.subscribe = subscribe;\n            // Give the Entry the ability to trigger cache.delete(key), even though\n            // the Entry itself does not know about key or cache.\n            entry.forget = () => cache.delete(key);\n        }\n        const value = entry.recompute(Array.prototype.slice.call(arguments));\n        // Move this entry to the front of the least-recently used queue,\n        // since we just finished computing its value.\n        cache.set(key, entry);\n        caches.add(cache);\n        // Clean up any excess entries in the cache, but only if there is no\n        // active parent entry, meaning we're not in the middle of a larger\n        // computation that might be flummoxed by the cleaning.\n        if (!parentEntrySlot.hasValue()) {\n            caches.forEach(cache => cache.clean());\n            caches.clear();\n        }\n        return value;\n    };\n    Object.defineProperty(optimistic, \"size\", {\n        get: () => cache.size,\n        configurable: false,\n        enumerable: false,\n    });\n    Object.freeze(optimistic.options = {\n        max,\n        keyArgs,\n        makeCacheKey,\n        normalizeResult,\n        subscribe,\n        cache,\n    });\n    function dirtyKey(key) {\n        const entry = key && cache.get(key);\n        if (entry) {\n            entry.setDirty();\n        }\n    }\n    optimistic.dirtyKey = dirtyKey;\n    optimistic.dirty = function dirty() {\n        dirtyKey(makeCacheKey.apply(null, arguments));\n    };\n    function peekKey(key) {\n        const entry = key && cache.get(key);\n        if (entry) {\n            return entry.peek();\n        }\n    }\n    optimistic.peekKey = peekKey;\n    optimistic.peek = function peek() {\n        return peekKey(makeCacheKey.apply(null, arguments));\n    };\n    function forgetKey(key) {\n        return key ? cache.delete(key) : false;\n    }\n    optimistic.forgetKey = forgetKey;\n    optimistic.forget = function forget() {\n        return forgetKey(makeCacheKey.apply(null, arguments));\n    };\n    optimistic.makeCacheKey = makeCacheKey;\n    optimistic.getKey = keyArgs ? function getKey() {\n        return makeCacheKey.apply(null, keyArgs.apply(null, arguments));\n    } : makeCacheKey;\n    return Object.freeze(optimistic);\n}\n", "import { __assign, __rest } from \"tslib\";\nimport { wrap } from \"optimism\";\nimport { getFragmentQueryDocument } from \"../../utilities/index.js\";\nvar ApolloCache = /** @class */ (function () {\n    function ApolloCache() {\n        this.assumeImmutableResults = false;\n        // Make sure we compute the same (===) fragment query document every\n        // time we receive the same fragment in readFragment.\n        this.getFragmentDoc = wrap(getFragmentQueryDocument);\n    }\n    // Transactional API\n    // The batch method is intended to replace/subsume both performTransaction\n    // and recordOptimisticTransaction, but performTransaction came first, so we\n    // provide a default batch implementation that's just another way of calling\n    // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can\n    // override the batch method to do more interesting things with its options.\n    ApolloCache.prototype.batch = function (options) {\n        var _this = this;\n        var optimisticId = typeof options.optimistic === \"string\" ? options.optimistic\n            : options.optimistic === false ? null\n                : void 0;\n        var updateResult;\n        this.performTransaction(function () { return (updateResult = options.update(_this)); }, optimisticId);\n        return updateResult;\n    };\n    ApolloCache.prototype.recordOptimisticTransaction = function (transaction, optimisticId) {\n        this.performTransaction(transaction, optimisticId);\n    };\n    // Optional API\n    // Called once per input document, allowing the cache to make static changes\n    // to the query, such as adding __typename fields.\n    ApolloCache.prototype.transformDocument = function (document) {\n        return document;\n    };\n    // Called before each ApolloLink request, allowing the cache to make dynamic\n    // changes to the query, such as filling in missing fragment definitions.\n    ApolloCache.prototype.transformForLink = function (document) {\n        return document;\n    };\n    ApolloCache.prototype.identify = function (object) {\n        return;\n    };\n    ApolloCache.prototype.gc = function () {\n        return [];\n    };\n    ApolloCache.prototype.modify = function (options) {\n        return false;\n    };\n    // DataProxy API\n    ApolloCache.prototype.readQuery = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = !!options.optimistic; }\n        return this.read(__assign(__assign({}, options), { rootId: options.id || \"ROOT_QUERY\", optimistic: optimistic }));\n    };\n    ApolloCache.prototype.readFragment = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = !!options.optimistic; }\n        return this.read(__assign(__assign({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic: optimistic }));\n    };\n    ApolloCache.prototype.writeQuery = function (_a) {\n        var id = _a.id, data = _a.data, options = __rest(_a, [\"id\", \"data\"]);\n        return this.write(Object.assign(options, {\n            dataId: id || \"ROOT_QUERY\",\n            result: data,\n        }));\n    };\n    ApolloCache.prototype.writeFragment = function (_a) {\n        var id = _a.id, data = _a.data, fragment = _a.fragment, fragmentName = _a.fragmentName, options = __rest(_a, [\"id\", \"data\", \"fragment\", \"fragmentName\"]);\n        return this.write(Object.assign(options, {\n            query: this.getFragmentDoc(fragment, fragmentName),\n            dataId: id,\n            result: data,\n        }));\n    };\n    ApolloCache.prototype.updateQuery = function (options, update) {\n        return this.batch({\n            update: function (cache) {\n                var value = cache.readQuery(options);\n                var data = update(value);\n                if (data === void 0 || data === null)\n                    return value;\n                cache.writeQuery(__assign(__assign({}, options), { data: data }));\n                return data;\n            },\n        });\n    };\n    ApolloCache.prototype.updateFragment = function (options, update) {\n        return this.batch({\n            update: function (cache) {\n                var value = cache.readFragment(options);\n                var data = update(value);\n                if (data === void 0 || data === null)\n                    return value;\n                cache.writeFragment(__assign(__assign({}, options), { data: data }));\n                return data;\n            },\n        });\n    };\n    return ApolloCache;\n}());\nexport { ApolloCache };\n", "export var Cache;\n(function (Cache) {\n})(Cache || (Cache = {}));\n", "import { __extends } from \"tslib\";\nvar MissingFieldError = /** @class */ (function (_super) {\n    __extends(MissingFieldError, _super);\n    function MissingFieldError(message, path, query, variables) {\n        var _a;\n        // 'Error' breaks prototype chain here\n        var _this = _super.call(this, message) || this;\n        _this.message = message;\n        _this.path = path;\n        _this.query = query;\n        _this.variables = variables;\n        if (Array.isArray(_this.path)) {\n            _this.missing = _this.message;\n            for (var i = _this.path.length - 1; i >= 0; --i) {\n                _this.missing = (_a = {}, _a[_this.path[i]] = _this.missing, _a);\n            }\n        }\n        else {\n            _this.missing = _this.path;\n        }\n        // We're not using `Object.setPrototypeOf` here as it isn't fully supported\n        // on Android (see issue #3236).\n        _this.__proto__ = MissingFieldError.prototype;\n        return _this;\n    }\n    return MissingFieldError;\n}(Error));\nexport { MissingFieldError };\n", "import { isReference, isField, DeepMerger, resultKeyNameFromField, shouldInclude, isNonNullObject, compact, createFragmentMap, getFragmentDefinitions, isArray, } from \"../../utilities/index.js\";\nexport var hasOwn = Object.prototype.hasOwnProperty;\nexport function isNullish(value) {\n    return value === null || value === void 0;\n}\nexport { isArray };\nexport function defaultDataIdFromObject(_a, context) {\n    var __typename = _a.__typename, id = _a.id, _id = _a._id;\n    if (typeof __typename === \"string\") {\n        if (context) {\n            context.keyObject =\n                !isNullish(id) ? { id: id }\n                    : !isNullish(_id) ? { _id: _id }\n                        : void 0;\n        }\n        // If there is no object.id, fall back to object._id.\n        if (isNullish(id) && !isNullish(_id)) {\n            id = _id;\n        }\n        if (!isNullish(id)) {\n            return \"\".concat(__typename, \":\").concat(typeof id === \"number\" || typeof id === \"string\" ?\n                id\n                : JSON.stringify(id));\n        }\n    }\n}\nvar defaultConfig = {\n    dataIdFromObject: defaultDataIdFromObject,\n    addTypename: true,\n    resultCaching: true,\n    // Thanks to the shouldCanonizeResults helper, this should be the only line\n    // you have to change to reenable canonization by default in the future.\n    canonizeResults: false,\n};\nexport function normalizeConfig(config) {\n    return compact(defaultConfig, config);\n}\nexport function shouldCanonizeResults(config) {\n    var value = config.canonizeResults;\n    return value === void 0 ? defaultConfig.canonizeResults : value;\n}\nexport function getTypenameFromStoreObject(store, objectOrReference) {\n    return isReference(objectOrReference) ?\n        store.get(objectOrReference.__ref, \"__typename\")\n        : objectOrReference && objectOrReference.__typename;\n}\nexport var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nexport function fieldNameFromStoreName(storeFieldName) {\n    var match = storeFieldName.match(TypeOrFieldNameRegExp);\n    return match ? match[0] : storeFieldName;\n}\nexport function selectionSetMatchesResult(selectionSet, result, variables) {\n    if (isNonNullObject(result)) {\n        return isArray(result) ?\n            result.every(function (item) {\n                return selectionSetMatchesResult(selectionSet, item, variables);\n            })\n            : selectionSet.selections.every(function (field) {\n                if (isField(field) && shouldInclude(field, variables)) {\n                    var key = resultKeyNameFromField(field);\n                    return (hasOwn.call(result, key) &&\n                        (!field.selectionSet ||\n                            selectionSetMatchesResult(field.selectionSet, result[key], variables)));\n                }\n                // If the selection has been skipped with @skip(true) or\n                // @include(false), it should not count against the matching. If\n                // the selection is not a field, it must be a fragment (inline or\n                // named). We will determine if selectionSetMatchesResult for that\n                // fragment when we get to it, so for now we return true.\n                return true;\n            });\n    }\n    return false;\n}\nexport function storeValueIsStoreObject(value) {\n    return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\nexport function makeProcessedFieldsMerger() {\n    return new DeepMerger();\n}\nexport function extractFragmentContext(document, fragments) {\n    // FragmentMap consisting only of fragments defined directly in document, not\n    // including other fragments registered in the FragmentRegistry.\n    var fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n    return {\n        fragmentMap: fragmentMap,\n        lookupFragment: function (name) {\n            var def = fragmentMap[name];\n            if (!def && fragments) {\n                def = fragments.lookup(name);\n            }\n            return def || null;\n        },\n    };\n}\n", "import { __assign, __extends, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { dep } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { isReference, makeReference, DeepMerger, maybeDeepFreeze, canUseWeakMap, isNonNullObject, } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName } from \"./helpers.js\";\nvar DELETE = Object.create(null);\nvar delModifier = function () { return DELETE; };\nvar INVALIDATE = Object.create(null);\nvar EntityStore = /** @class */ (function () {\n    function EntityStore(policies, group) {\n        var _this = this;\n        this.policies = policies;\n        this.group = group;\n        this.data = Object.create(null);\n        // Maps root entity IDs to the number of times they have been retained, minus\n        // the number of times they have been released. Retained entities keep other\n        // entities they reference (even indirectly) from being garbage collected.\n        this.rootIds = Object.create(null);\n        // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\n        this.refs = Object.create(null);\n        // Bound function that can be passed around to provide easy access to fields\n        // of Reference objects as well as ordinary objects.\n        this.getFieldValue = function (objectOrReference, storeFieldName) {\n            return maybeDeepFreeze(isReference(objectOrReference) ?\n                _this.get(objectOrReference.__ref, storeFieldName)\n                : objectOrReference && objectOrReference[storeFieldName]);\n        };\n        // Returns true for non-normalized StoreObjects and non-dangling\n        // References, indicating that readField(name, objOrRef) has a chance of\n        // working. Useful for filtering out dangling references from lists.\n        this.canRead = function (objOrRef) {\n            return isReference(objOrRef) ?\n                _this.has(objOrRef.__ref)\n                : typeof objOrRef === \"object\";\n        };\n        // Bound function that converts an id or an object with a __typename and\n        // primary key fields to a Reference object. If called with a Reference object,\n        // that same Reference object is returned. Pass true for mergeIntoStore to persist\n        // an object into the store.\n        this.toReference = function (objOrIdOrRef, mergeIntoStore) {\n            if (typeof objOrIdOrRef === \"string\") {\n                return makeReference(objOrIdOrRef);\n            }\n            if (isReference(objOrIdOrRef)) {\n                return objOrIdOrRef;\n            }\n            var id = _this.policies.identify(objOrIdOrRef)[0];\n            if (id) {\n                var ref = makeReference(id);\n                if (mergeIntoStore) {\n                    _this.merge(id, objOrIdOrRef);\n                }\n                return ref;\n            }\n        };\n    }\n    // Although the EntityStore class is abstract, it contains concrete\n    // implementations of the various NormalizedCache interface methods that\n    // are inherited by the Root and Layer subclasses.\n    EntityStore.prototype.toObject = function () {\n        return __assign({}, this.data);\n    };\n    EntityStore.prototype.has = function (dataId) {\n        return this.lookup(dataId, true) !== void 0;\n    };\n    EntityStore.prototype.get = function (dataId, fieldName) {\n        this.group.depend(dataId, fieldName);\n        if (hasOwn.call(this.data, dataId)) {\n            var storeObject = this.data[dataId];\n            if (storeObject && hasOwn.call(storeObject, fieldName)) {\n                return storeObject[fieldName];\n            }\n        }\n        if (fieldName === \"__typename\" &&\n            hasOwn.call(this.policies.rootTypenamesById, dataId)) {\n            return this.policies.rootTypenamesById[dataId];\n        }\n        if (this instanceof Layer) {\n            return this.parent.get(dataId, fieldName);\n        }\n    };\n    EntityStore.prototype.lookup = function (dataId, dependOnExistence) {\n        // The has method (above) calls lookup with dependOnExistence = true, so\n        // that it can later be invalidated when we add or remove a StoreObject for\n        // this dataId. Any consumer who cares about the contents of the StoreObject\n        // should not rely on this dependency, since the contents could change\n        // without the object being added or removed.\n        if (dependOnExistence)\n            this.group.depend(dataId, \"__exists\");\n        if (hasOwn.call(this.data, dataId)) {\n            return this.data[dataId];\n        }\n        if (this instanceof Layer) {\n            return this.parent.lookup(dataId, dependOnExistence);\n        }\n        if (this.policies.rootTypenamesById[dataId]) {\n            return Object.create(null);\n        }\n    };\n    EntityStore.prototype.merge = function (older, newer) {\n        var _this = this;\n        var dataId;\n        // Convert unexpected references to ID strings.\n        if (isReference(older))\n            older = older.__ref;\n        if (isReference(newer))\n            newer = newer.__ref;\n        var existing = typeof older === \"string\" ? this.lookup((dataId = older)) : older;\n        var incoming = typeof newer === \"string\" ? this.lookup((dataId = newer)) : newer;\n        // If newer was a string ID, but that ID was not defined in this store,\n        // then there are no fields to be merged, so we're done.\n        if (!incoming)\n            return;\n        invariant(typeof dataId === \"string\", 1);\n        var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);\n        // Even if merged === existing, existing may have come from a lower\n        // layer, so we always need to set this.data[dataId] on this level.\n        this.data[dataId] = merged;\n        if (merged !== existing) {\n            delete this.refs[dataId];\n            if (this.group.caching) {\n                var fieldsToDirty_1 = Object.create(null);\n                // If we added a new StoreObject where there was previously none, dirty\n                // anything that depended on the existence of this dataId, such as the\n                // EntityStore#has method.\n                if (!existing)\n                    fieldsToDirty_1.__exists = 1;\n                // Now invalidate dependents who called getFieldValue for any fields\n                // that are changing as a result of this merge.\n                Object.keys(incoming).forEach(function (storeFieldName) {\n                    if (!existing ||\n                        existing[storeFieldName] !== merged[storeFieldName]) {\n                        // Always dirty the full storeFieldName, which may include\n                        // serialized arguments following the fieldName prefix.\n                        fieldsToDirty_1[storeFieldName] = 1;\n                        // Also dirty fieldNameFromStoreName(storeFieldName) if it's\n                        // different from storeFieldName and this field does not have\n                        // keyArgs configured, because that means the cache can't make\n                        // any assumptions about how field values with the same field\n                        // name but different arguments might be interrelated, so it\n                        // must err on the side of invalidating all field values that\n                        // share the same short fieldName, regardless of arguments.\n                        var fieldName = fieldNameFromStoreName(storeFieldName);\n                        if (fieldName !== storeFieldName &&\n                            !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {\n                            fieldsToDirty_1[fieldName] = 1;\n                        }\n                        // If merged[storeFieldName] has become undefined, and this is the\n                        // Root layer, actually delete the property from the merged object,\n                        // which is guaranteed to have been created fresh in this method.\n                        if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {\n                            delete merged[storeFieldName];\n                        }\n                    }\n                });\n                if (fieldsToDirty_1.__typename &&\n                    !(existing && existing.__typename) &&\n                    // Since we return default root __typename strings\n                    // automatically from store.get, we don't need to dirty the\n                    // ROOT_QUERY.__typename field if merged.__typename is equal\n                    // to the default string (usually \"Query\").\n                    this.policies.rootTypenamesById[dataId] === merged.__typename) {\n                    delete fieldsToDirty_1.__typename;\n                }\n                Object.keys(fieldsToDirty_1).forEach(function (fieldName) {\n                    return _this.group.dirty(dataId, fieldName);\n                });\n            }\n        }\n    };\n    EntityStore.prototype.modify = function (dataId, fields) {\n        var _this = this;\n        var storeObject = this.lookup(dataId);\n        if (storeObject) {\n            var changedFields_1 = Object.create(null);\n            var needToMerge_1 = false;\n            var allDeleted_1 = true;\n            var sharedDetails_1 = {\n                DELETE: DELETE,\n                INVALIDATE: INVALIDATE,\n                isReference: isReference,\n                toReference: this.toReference,\n                canRead: this.canRead,\n                readField: function (fieldNameOrOptions, from) {\n                    return _this.policies.readField(typeof fieldNameOrOptions === \"string\" ?\n                        {\n                            fieldName: fieldNameOrOptions,\n                            from: from || makeReference(dataId),\n                        }\n                        : fieldNameOrOptions, { store: _this });\n                },\n            };\n            Object.keys(storeObject).forEach(function (storeFieldName) {\n                var fieldName = fieldNameFromStoreName(storeFieldName);\n                var fieldValue = storeObject[storeFieldName];\n                if (fieldValue === void 0)\n                    return;\n                var modify = typeof fields === \"function\" ? fields : (fields[storeFieldName] || fields[fieldName]);\n                if (modify) {\n                    var newValue = modify === delModifier ? DELETE : (modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), { fieldName: fieldName, storeFieldName: storeFieldName, storage: _this.getStorage(dataId, storeFieldName) })));\n                    if (newValue === INVALIDATE) {\n                        _this.group.dirty(dataId, storeFieldName);\n                    }\n                    else {\n                        if (newValue === DELETE)\n                            newValue = void 0;\n                        if (newValue !== fieldValue) {\n                            changedFields_1[storeFieldName] = newValue;\n                            needToMerge_1 = true;\n                            fieldValue = newValue;\n                            if (globalThis.__DEV__ !== false) {\n                                var checkReference = function (ref) {\n                                    if (_this.lookup(ref.__ref) === undefined) {\n                                        globalThis.__DEV__ !== false && invariant.warn(2, ref);\n                                        return true;\n                                    }\n                                };\n                                if (isReference(newValue)) {\n                                    checkReference(newValue);\n                                }\n                                else if (Array.isArray(newValue)) {\n                                    // Warn about writing \"mixed\" arrays of Reference and non-Reference objects\n                                    var seenReference = false;\n                                    var someNonReference = void 0;\n                                    for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {\n                                        var value = newValue_1[_i];\n                                        if (isReference(value)) {\n                                            seenReference = true;\n                                            if (checkReference(value))\n                                                break;\n                                        }\n                                        else {\n                                            // Do not warn on primitive values, since those could never be represented\n                                            // by a reference. This is a valid (albeit uncommon) use case.\n                                            if (typeof value === \"object\" && !!value) {\n                                                var id = _this.policies.identify(value)[0];\n                                                // check if object could even be referenced, otherwise we are not interested in it for this warning\n                                                if (id) {\n                                                    someNonReference = value;\n                                                }\n                                            }\n                                        }\n                                        if (seenReference && someNonReference !== undefined) {\n                                            globalThis.__DEV__ !== false && invariant.warn(3, someNonReference);\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (fieldValue !== void 0) {\n                    allDeleted_1 = false;\n                }\n            });\n            if (needToMerge_1) {\n                this.merge(dataId, changedFields_1);\n                if (allDeleted_1) {\n                    if (this instanceof Layer) {\n                        this.data[dataId] = void 0;\n                    }\n                    else {\n                        delete this.data[dataId];\n                    }\n                    this.group.dirty(dataId, \"__exists\");\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    // If called with only one argument, removes the entire entity\n    // identified by dataId. If called with a fieldName as well, removes all\n    // fields of that entity whose names match fieldName according to the\n    // fieldNameFromStoreName helper function. If called with a fieldName\n    // and variables, removes all fields of that entity whose names match fieldName\n    // and whose arguments when cached exactly match the variables passed.\n    EntityStore.prototype.delete = function (dataId, fieldName, args) {\n        var _a;\n        var storeObject = this.lookup(dataId);\n        if (storeObject) {\n            var typename = this.getFieldValue(storeObject, \"__typename\");\n            var storeFieldName = fieldName && args ?\n                this.policies.getStoreFieldName({ typename: typename, fieldName: fieldName, args: args })\n                : fieldName;\n            return this.modify(dataId, storeFieldName ? (_a = {},\n                _a[storeFieldName] = delModifier,\n                _a) : delModifier);\n        }\n        return false;\n    };\n    EntityStore.prototype.evict = function (options, limit) {\n        var evicted = false;\n        if (options.id) {\n            if (hasOwn.call(this.data, options.id)) {\n                evicted = this.delete(options.id, options.fieldName, options.args);\n            }\n            if (this instanceof Layer && this !== limit) {\n                evicted = this.parent.evict(options, limit) || evicted;\n            }\n            // Always invalidate the field to trigger rereading of watched\n            // queries, even if no cache data was modified by the eviction,\n            // because queries may depend on computed fields with custom read\n            // functions, whose values are not stored in the EntityStore.\n            if (options.fieldName || evicted) {\n                this.group.dirty(options.id, options.fieldName || \"__exists\");\n            }\n        }\n        return evicted;\n    };\n    EntityStore.prototype.clear = function () {\n        this.replace(null);\n    };\n    EntityStore.prototype.extract = function () {\n        var _this = this;\n        var obj = this.toObject();\n        var extraRootIds = [];\n        this.getRootIdSet().forEach(function (id) {\n            if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {\n                extraRootIds.push(id);\n            }\n        });\n        if (extraRootIds.length) {\n            obj.__META = { extraRootIds: extraRootIds.sort() };\n        }\n        return obj;\n    };\n    EntityStore.prototype.replace = function (newData) {\n        var _this = this;\n        Object.keys(this.data).forEach(function (dataId) {\n            if (!(newData && hasOwn.call(newData, dataId))) {\n                _this.delete(dataId);\n            }\n        });\n        if (newData) {\n            var __META = newData.__META, rest_1 = __rest(newData, [\"__META\"]);\n            Object.keys(rest_1).forEach(function (dataId) {\n                _this.merge(dataId, rest_1[dataId]);\n            });\n            if (__META) {\n                __META.extraRootIds.forEach(this.retain, this);\n            }\n        }\n    };\n    EntityStore.prototype.retain = function (rootId) {\n        return (this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1);\n    };\n    EntityStore.prototype.release = function (rootId) {\n        if (this.rootIds[rootId] > 0) {\n            var count = --this.rootIds[rootId];\n            if (!count)\n                delete this.rootIds[rootId];\n            return count;\n        }\n        return 0;\n    };\n    // Return a Set<string> of all the ID strings that have been retained by\n    // this layer/root *and* any layers/roots beneath it.\n    EntityStore.prototype.getRootIdSet = function (ids) {\n        if (ids === void 0) { ids = new Set(); }\n        Object.keys(this.rootIds).forEach(ids.add, ids);\n        if (this instanceof Layer) {\n            this.parent.getRootIdSet(ids);\n        }\n        else {\n            // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\n            // always considered roots for garbage collection, regardless of\n            // their retainment counts in this.rootIds.\n            Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n        }\n        return ids;\n    };\n    // The goal of garbage collection is to remove IDs from the Root layer of the\n    // store that are no longer reachable starting from any IDs that have been\n    // explicitly retained (see retain and release, above). Returns an array of\n    // dataId strings that were removed from the store.\n    EntityStore.prototype.gc = function () {\n        var _this = this;\n        var ids = this.getRootIdSet();\n        var snapshot = this.toObject();\n        ids.forEach(function (id) {\n            if (hasOwn.call(snapshot, id)) {\n                // Because we are iterating over an ECMAScript Set, the IDs we add here\n                // will be visited in later iterations of the forEach loop only if they\n                // were not previously contained by the Set.\n                Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);\n                // By removing IDs from the snapshot object here, we protect them from\n                // getting removed from the root store layer below.\n                delete snapshot[id];\n            }\n        });\n        var idsToRemove = Object.keys(snapshot);\n        if (idsToRemove.length) {\n            var root_1 = this;\n            while (root_1 instanceof Layer)\n                root_1 = root_1.parent;\n            idsToRemove.forEach(function (id) { return root_1.delete(id); });\n        }\n        return idsToRemove;\n    };\n    EntityStore.prototype.findChildRefIds = function (dataId) {\n        if (!hasOwn.call(this.refs, dataId)) {\n            var found_1 = (this.refs[dataId] = Object.create(null));\n            var root = this.data[dataId];\n            if (!root)\n                return found_1;\n            var workSet_1 = new Set([root]);\n            // Within the store, only arrays and objects can contain child entity\n            // references, so we can prune the traversal using this predicate:\n            workSet_1.forEach(function (obj) {\n                if (isReference(obj)) {\n                    found_1[obj.__ref] = true;\n                    // In rare cases, a { __ref } Reference object may have other fields.\n                    // This often indicates a mismerging of References with StoreObjects,\n                    // but garbage collection should not be fooled by a stray __ref\n                    // property in a StoreObject (ignoring all the other fields just\n                    // because the StoreObject looks like a Reference). To avoid this\n                    // premature termination of findChildRefIds recursion, we fall through\n                    // to the code below, which will handle any other properties of obj.\n                }\n                if (isNonNullObject(obj)) {\n                    Object.keys(obj).forEach(function (key) {\n                        var child = obj[key];\n                        // No need to add primitive values to the workSet, since they cannot\n                        // contain reference objects.\n                        if (isNonNullObject(child)) {\n                            workSet_1.add(child);\n                        }\n                    });\n                }\n            });\n        }\n        return this.refs[dataId];\n    };\n    EntityStore.prototype.makeCacheKey = function () {\n        return this.group.keyMaker.lookupArray(arguments);\n    };\n    return EntityStore;\n}());\nexport { EntityStore };\n// A single CacheGroup represents a set of one or more EntityStore objects,\n// typically the Root store in a CacheGroup by itself, and all active Layer\n// stores in a group together. A single EntityStore object belongs to only\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\n// dependencies, so store.group is helpful for generating unique keys for\n// cached results that need to be invalidated when/if those dependencies\n// change. If we used the EntityStore objects themselves as cache keys (that\n// is, store rather than store.group), the cache would become unnecessarily\n// fragmented by all the different Layer objects. Instead, the CacheGroup\n// approach allows all optimistic Layer objects in the same linked list to\n// belong to one CacheGroup, with the non-optimistic Root object belonging\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\n// separately for optimistic and non-optimistic entity data.\nvar CacheGroup = /** @class */ (function () {\n    function CacheGroup(caching, parent) {\n        if (parent === void 0) { parent = null; }\n        this.caching = caching;\n        this.parent = parent;\n        this.d = null;\n        this.resetCaching();\n    }\n    CacheGroup.prototype.resetCaching = function () {\n        this.d = this.caching ? dep() : null;\n        this.keyMaker = new Trie(canUseWeakMap);\n    };\n    CacheGroup.prototype.depend = function (dataId, storeFieldName) {\n        if (this.d) {\n            this.d(makeDepKey(dataId, storeFieldName));\n            var fieldName = fieldNameFromStoreName(storeFieldName);\n            if (fieldName !== storeFieldName) {\n                // Fields with arguments that contribute extra identifying\n                // information to the fieldName (thus forming the storeFieldName)\n                // depend not only on the full storeFieldName but also on the\n                // short fieldName, so the field can be invalidated using either\n                // level of specificity.\n                this.d(makeDepKey(dataId, fieldName));\n            }\n            if (this.parent) {\n                this.parent.depend(dataId, storeFieldName);\n            }\n        }\n    };\n    CacheGroup.prototype.dirty = function (dataId, storeFieldName) {\n        if (this.d) {\n            this.d.dirty(makeDepKey(dataId, storeFieldName), \n            // When storeFieldName === \"__exists\", that means the entity identified\n            // by dataId has either disappeared from the cache or was newly added,\n            // so the result caching system would do well to \"forget everything it\n            // knows\" about that object. To achieve that kind of invalidation, we\n            // not only dirty the associated result cache entry, but also remove it\n            // completely from the dependency graph. For the optimism implementation\n            // details, see https://github.com/benjamn/optimism/pull/195.\n            storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\");\n        }\n    };\n    return CacheGroup;\n}());\nfunction makeDepKey(dataId, storeFieldName) {\n    // Since field names cannot have '#' characters in them, this method\n    // of joining the field name and the ID should be unambiguous, and much\n    // cheaper than JSON.stringify([dataId, fieldName]).\n    return storeFieldName + \"#\" + dataId;\n}\nexport function maybeDependOnExistenceOfEntity(store, entityId) {\n    if (supportsResultCaching(store)) {\n        // We use this pseudo-field __exists elsewhere in the EntityStore code to\n        // represent changes in the existence of the entity object identified by\n        // entityId. This dependency gets reliably dirtied whenever an object with\n        // this ID is deleted (or newly created) within this group, so any result\n        // cache entries (for example, StoreReader#executeSelectionSet results) that\n        // depend on __exists for this entityId will get dirtied as well, leading to\n        // the eventual recomputation (instead of reuse) of those result objects the\n        // next time someone reads them from the cache.\n        store.group.depend(entityId, \"__exists\");\n    }\n}\n(function (EntityStore) {\n    // Refer to this class as EntityStore.Root outside this namespace.\n    var Root = /** @class */ (function (_super) {\n        __extends(Root, _super);\n        function Root(_a) {\n            var policies = _a.policies, _b = _a.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a.seed;\n            var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;\n            _this.stump = new Stump(_this);\n            _this.storageTrie = new Trie(canUseWeakMap);\n            if (seed)\n                _this.replace(seed);\n            return _this;\n        }\n        Root.prototype.addLayer = function (layerId, replay) {\n            // Adding an optimistic Layer on top of the Root actually adds the Layer\n            // on top of the Stump, so the Stump always comes between the Root and\n            // any Layer objects that we've added.\n            return this.stump.addLayer(layerId, replay);\n        };\n        Root.prototype.removeLayer = function () {\n            // Never remove the root layer.\n            return this;\n        };\n        Root.prototype.getStorage = function () {\n            return this.storageTrie.lookupArray(arguments);\n        };\n        return Root;\n    }(EntityStore));\n    EntityStore.Root = Root;\n})(EntityStore || (EntityStore = {}));\n// Not exported, since all Layer instances are created by the addLayer method\n// of the EntityStore.Root class.\nvar Layer = /** @class */ (function (_super) {\n    __extends(Layer, _super);\n    function Layer(id, parent, replay, group) {\n        var _this = _super.call(this, parent.policies, group) || this;\n        _this.id = id;\n        _this.parent = parent;\n        _this.replay = replay;\n        _this.group = group;\n        replay(_this);\n        return _this;\n    }\n    Layer.prototype.addLayer = function (layerId, replay) {\n        return new Layer(layerId, this, replay, this.group);\n    };\n    Layer.prototype.removeLayer = function (layerId) {\n        var _this = this;\n        // Remove all instances of the given id, not just the first one.\n        var parent = this.parent.removeLayer(layerId);\n        if (layerId === this.id) {\n            if (this.group.caching) {\n                // Dirty every ID we're removing. Technically we might be able to avoid\n                // dirtying fields that have values in higher layers, but we don't have\n                // easy access to higher layers here, and we're about to recreate those\n                // layers anyway (see parent.addLayer below).\n                Object.keys(this.data).forEach(function (dataId) {\n                    var ownStoreObject = _this.data[dataId];\n                    var parentStoreObject = parent[\"lookup\"](dataId);\n                    if (!parentStoreObject) {\n                        // The StoreObject identified by dataId was defined in this layer\n                        // but will be undefined in the parent layer, so we can delete the\n                        // whole entity using this.delete(dataId). Since we're about to\n                        // throw this layer away, the only goal of this deletion is to dirty\n                        // the removed fields.\n                        _this.delete(dataId);\n                    }\n                    else if (!ownStoreObject) {\n                        // This layer had an entry for dataId but it was undefined, which\n                        // means the entity was deleted in this layer, and it's about to\n                        // become undeleted when we remove this layer, so we need to dirty\n                        // all fields that are about to be reexposed.\n                        _this.group.dirty(dataId, \"__exists\");\n                        Object.keys(parentStoreObject).forEach(function (storeFieldName) {\n                            _this.group.dirty(dataId, storeFieldName);\n                        });\n                    }\n                    else if (ownStoreObject !== parentStoreObject) {\n                        // If ownStoreObject is not exactly the same as parentStoreObject,\n                        // dirty any fields whose values will change as a result of this\n                        // removal.\n                        Object.keys(ownStoreObject).forEach(function (storeFieldName) {\n                            if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {\n                                _this.group.dirty(dataId, storeFieldName);\n                            }\n                        });\n                    }\n                });\n            }\n            return parent;\n        }\n        // No changes are necessary if the parent chain remains identical.\n        if (parent === this.parent)\n            return this;\n        // Recreate this layer on top of the new parent.\n        return parent.addLayer(this.id, this.replay);\n    };\n    Layer.prototype.toObject = function () {\n        return __assign(__assign({}, this.parent.toObject()), this.data);\n    };\n    Layer.prototype.findChildRefIds = function (dataId) {\n        var fromParent = this.parent.findChildRefIds(dataId);\n        return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;\n    };\n    Layer.prototype.getStorage = function () {\n        var p = this.parent;\n        while (p.parent)\n            p = p.parent;\n        return p.getStorage.apply(p, \n        // @ts-expect-error\n        arguments);\n    };\n    return Layer;\n}(EntityStore));\n// Represents a Layer permanently installed just above the Root, which allows\n// reading optimistically (and registering optimistic dependencies) even when\n// no optimistic layers are currently active. The stump.group CacheGroup object\n// is shared by any/all Layer objects added on top of the Stump.\nvar Stump = /** @class */ (function (_super) {\n    __extends(Stump, _super);\n    function Stump(root) {\n        return _super.call(this, \"EntityStore.Stump\", root, function () { }, new CacheGroup(root.group.caching, root.group)) || this;\n    }\n    Stump.prototype.removeLayer = function () {\n        // Never remove the Stump layer.\n        return this;\n    };\n    Stump.prototype.merge = function (older, newer) {\n        // We never want to write any data into the Stump, so we forward any merge\n        // calls to the Root instead. Another option here would be to throw an\n        // exception, but the toReference(object, true) function can sometimes\n        // trigger Stump writes (which used to be Root writes, before the Stump\n        // concept was introduced).\n        return this.parent.merge(older, newer);\n    };\n    return Stump;\n}(Layer));\nfunction storeObjectReconciler(existingObject, incomingObject, property) {\n    var existingValue = existingObject[property];\n    var incomingValue = incomingObject[property];\n    // Wherever there is a key collision, prefer the incoming value, unless\n    // it is deeply equal to the existing value. It's worth checking deep\n    // equality here (even though blindly returning incoming would be\n    // logically correct) because preserving the referential identity of\n    // existing data can prevent needless rereading and rerendering.\n    return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\nexport function supportsResultCaching(store) {\n    // When result caching is disabled, store.depend will be null.\n    return !!(store instanceof EntityStore && store.group.caching);\n}\n", "import { __assign } from \"tslib\";\nimport { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet, isNonNullObject as isObjectOrArray, } from \"../../utilities/index.js\";\nimport { isArray } from \"./helpers.js\";\nfunction shallowCopy(value) {\n    if (isObjectOrArray(value)) {\n        return isArray(value) ?\n            value.slice(0)\n            : __assign({ __proto__: Object.getPrototypeOf(value) }, value);\n    }\n    return value;\n}\n// When programmers talk about the \"canonical form\" of an object, they\n// usually have the following meaning in mind, which I've copied from\n// https://en.wiktionary.org/wiki/canonical_form:\n//\n// 1. A standard or normal presentation of a mathematical entity [or\n//    object]. A canonical form is an element of a set of representatives\n//    of equivalence classes of forms such that there is a function or\n//    procedure which projects every element of each equivalence class\n//    onto that one element, the canonical form of that equivalence\n//    class. The canonical form is expected to be simpler than the rest of\n//    the forms in some way.\n//\n// That's a long-winded way of saying any two objects that have the same\n// canonical form may be considered equivalent, even if they are !==,\n// which usually means the objects are structurally equivalent (deeply\n// equal), but don't necessarily use the same memory.\n//\n// Like a literary or musical canon, this ObjectCanon class represents a\n// collection of unique canonical items (JavaScript objects), with the\n// important property that canon.admit(a) === canon.admit(b) if a and b\n// are deeply equal to each other. In terms of the definition above, the\n// canon.admit method is the \"function or procedure which projects every\"\n// object \"onto that one element, the canonical form.\"\n//\n// In the worst case, the canonicalization process may involve looking at\n// every property in the provided object tree, so it takes the same order\n// of time as deep equality checking. Fortunately, already-canonicalized\n// objects are returned immediately from canon.admit, so the presence of\n// canonical subtrees tends to speed up canonicalization.\n//\n// Since consumers of canonical objects can check for deep equality in\n// constant time, canonicalizing cache results can massively improve the\n// performance of application code that skips re-rendering unchanged\n// results, such as \"pure\" UI components in a framework like React.\n//\n// Of course, since canonical objects may be shared widely between\n// unrelated consumers, it's important to think of them as immutable, even\n// though they are not actually frozen with Object.freeze in production,\n// due to the extra performance overhead that comes with frozen objects.\n//\n// Custom scalar objects whose internal class name is neither Array nor\n// Object can be included safely in the admitted tree, but they will not\n// be replaced with a canonical version (to put it another way, they are\n// assumed to be canonical already).\n//\n// If we ignore custom objects, no detection of cycles or repeated object\n// references is currently required by the StoreReader class, since\n// GraphQL result objects are JSON-serializable trees (and thus contain\n// neither cycles nor repeated subtrees), so we can avoid the complexity\n// of keeping track of objects we've already seen during the recursion of\n// the admit method.\n//\n// In the future, we may consider adding additional cases to the switch\n// statement to handle other common object types, such as \"[object Date]\"\n// objects, as needed.\nvar ObjectCanon = /** @class */ (function () {\n    function ObjectCanon() {\n        // Set of all canonical objects this ObjectCanon has admitted, allowing\n        // canon.admit to return previously-canonicalized objects immediately.\n        this.known = new (canUseWeakSet ? WeakSet : Set)();\n        // Efficient storage/lookup structure for canonical objects.\n        this.pool = new Trie(canUseWeakMap);\n        // Make the ObjectCanon assume this value has already been\n        // canonicalized.\n        this.passes = new WeakMap();\n        // Arrays that contain the same elements in a different order can share\n        // the same SortedKeysInfo object, to save memory.\n        this.keysByJSON = new Map();\n        // This has to come last because it depends on keysByJSON.\n        this.empty = this.admit({});\n    }\n    ObjectCanon.prototype.isKnown = function (value) {\n        return isObjectOrArray(value) && this.known.has(value);\n    };\n    ObjectCanon.prototype.pass = function (value) {\n        if (isObjectOrArray(value)) {\n            var copy = shallowCopy(value);\n            this.passes.set(copy, value);\n            return copy;\n        }\n        return value;\n    };\n    ObjectCanon.prototype.admit = function (value) {\n        var _this = this;\n        if (isObjectOrArray(value)) {\n            var original = this.passes.get(value);\n            if (original)\n                return original;\n            var proto = Object.getPrototypeOf(value);\n            switch (proto) {\n                case Array.prototype: {\n                    if (this.known.has(value))\n                        return value;\n                    var array = value.map(this.admit, this);\n                    // Arrays are looked up in the Trie using their recursively\n                    // canonicalized elements, and the known version of the array is\n                    // preserved as node.array.\n                    var node = this.pool.lookupArray(array);\n                    if (!node.array) {\n                        this.known.add((node.array = array));\n                        // Since canonical arrays may be shared widely between\n                        // unrelated consumers, it's important to regard them as\n                        // immutable, even if they are not frozen in production.\n                        if (globalThis.__DEV__ !== false) {\n                            Object.freeze(array);\n                        }\n                    }\n                    return node.array;\n                }\n                case null:\n                case Object.prototype: {\n                    if (this.known.has(value))\n                        return value;\n                    var proto_1 = Object.getPrototypeOf(value);\n                    var array_1 = [proto_1];\n                    var keys = this.sortedKeys(value);\n                    array_1.push(keys.json);\n                    var firstValueIndex_1 = array_1.length;\n                    keys.sorted.forEach(function (key) {\n                        array_1.push(_this.admit(value[key]));\n                    });\n                    // Objects are looked up in the Trie by their prototype (which\n                    // is *not* recursively canonicalized), followed by a JSON\n                    // representation of their (sorted) keys, followed by the\n                    // sequence of recursively canonicalized values corresponding to\n                    // those keys. To keep the final results unambiguous with other\n                    // sequences (such as arrays that just happen to contain [proto,\n                    // keys.json, value1, value2, ...]), the known version of the\n                    // object is stored as node.object.\n                    var node = this.pool.lookupArray(array_1);\n                    if (!node.object) {\n                        var obj_1 = (node.object = Object.create(proto_1));\n                        this.known.add(obj_1);\n                        keys.sorted.forEach(function (key, i) {\n                            obj_1[key] = array_1[firstValueIndex_1 + i];\n                        });\n                        // Since canonical objects may be shared widely between\n                        // unrelated consumers, it's important to regard them as\n                        // immutable, even if they are not frozen in production.\n                        if (globalThis.__DEV__ !== false) {\n                            Object.freeze(obj_1);\n                        }\n                    }\n                    return node.object;\n                }\n            }\n        }\n        return value;\n    };\n    // It's worthwhile to cache the sorting of arrays of strings, since the\n    // same initial unsorted arrays tend to be encountered many times.\n    // Fortunately, we can reuse the Trie machinery to look up the sorted\n    // arrays in linear time (which is faster than sorting large arrays).\n    ObjectCanon.prototype.sortedKeys = function (obj) {\n        var keys = Object.keys(obj);\n        var node = this.pool.lookupArray(keys);\n        if (!node.keys) {\n            keys.sort();\n            var json = JSON.stringify(keys);\n            if (!(node.keys = this.keysByJSON.get(json))) {\n                this.keysByJSON.set(json, (node.keys = { sorted: keys, json: json }));\n            }\n        }\n        return node.keys;\n    };\n    return ObjectCanon;\n}());\nexport { ObjectCanon };\n// Since the keys of canonical objects are always created in lexicographically\n// sorted order, we can use the ObjectCanon to implement a fast and stable\n// version of JSON.stringify, which automatically sorts object keys.\nexport var canonicalStringify = Object.assign(function (value) {\n    if (isObjectOrArray(value)) {\n        if (stringifyCanon === void 0) {\n            resetCanonicalStringify();\n        }\n        var canonical = stringifyCanon.admit(value);\n        var json = stringifyCache.get(canonical);\n        if (json === void 0) {\n            stringifyCache.set(canonical, (json = JSON.stringify(canonical)));\n        }\n        return json;\n    }\n    return JSON.stringify(value);\n}, {\n    reset: resetCanonicalStringify,\n});\n// Can be reset by calling canonicalStringify.reset().\nvar stringifyCanon;\nvar stringifyCache;\nfunction resetCanonicalStringify() {\n    stringifyCanon = new ObjectCanon();\n    stringifyCache = new (canUseWeakMap ? WeakMap : Map)();\n}\n", "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { Kind } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { isField, resultKeyNameFromField, isReference, makeReference, shouldInclude, addTypenameToDocument, getDefaultValues, getMainDefinition, getQueryDefinition, getFragmentFromSelection, maybeDeepFreeze, mergeDeepArray, DeepMerger, isNonNullObject, canUseWeakMap, compact, } from \"../../utilities/index.js\";\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching, } from \"./entityStore.js\";\nimport { isArray, extractFragmentContext, getTypenameFromStoreObject, shouldCanonizeResults, } from \"./helpers.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { canonicalStringify, ObjectCanon } from \"./object-canon.js\";\nfunction execSelectionSetKeyArgs(options) {\n    return [\n        options.selectionSet,\n        options.objectOrReference,\n        options.context,\n        // We split out this property so we can pass different values\n        // independently without modifying options.context itself.\n        options.context.canonizeResults,\n    ];\n}\nvar StoreReader = /** @class */ (function () {\n    function StoreReader(config) {\n        var _this = this;\n        this.knownResults = new (canUseWeakMap ? WeakMap : Map)();\n        this.config = compact(config, {\n            addTypename: config.addTypename !== false,\n            canonizeResults: shouldCanonizeResults(config),\n        });\n        this.canon = config.canon || new ObjectCanon();\n        this.executeSelectionSet = wrap(function (options) {\n            var _a;\n            var canonizeResults = options.context.canonizeResults;\n            var peekArgs = execSelectionSetKeyArgs(options);\n            // Negate this boolean option so we can find out if we've already read\n            // this result using the other boolean value.\n            peekArgs[3] = !canonizeResults;\n            var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n            if (other) {\n                if (canonizeResults) {\n                    return __assign(__assign({}, other), { \n                        // If we previously read this result without canonizing it, we can\n                        // reuse that result simply by canonizing it now.\n                        result: _this.canon.admit(other.result) });\n                }\n                // If we previously read this result with canonization enabled, we can\n                // return that canonized result as-is.\n                return other;\n            }\n            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n            // Finally, if we didn't find any useful previous results, run the real\n            // execSelectionSetImpl method with the given options.\n            return _this.execSelectionSetImpl(options);\n        }, {\n            max: this.config.resultCacheMaxSize,\n            keyArgs: execSelectionSetKeyArgs,\n            // Note that the parameters of makeCacheKey are determined by the\n            // array returned by keyArgs.\n            makeCacheKey: function (selectionSet, parent, context, canonizeResults) {\n                if (supportsResultCaching(context.store)) {\n                    return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n                }\n            },\n        });\n        this.executeSubSelectedArray = wrap(function (options) {\n            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n            return _this.execSubSelectedArrayImpl(options);\n        }, {\n            max: this.config.resultCacheMaxSize,\n            makeCacheKey: function (_a) {\n                var field = _a.field, array = _a.array, context = _a.context;\n                if (supportsResultCaching(context.store)) {\n                    return context.store.makeCacheKey(field, array, context.varString);\n                }\n            },\n        });\n    }\n    StoreReader.prototype.resetCanon = function () {\n        this.canon = new ObjectCanon();\n    };\n    /**\n     * Given a store and a query, return as much of the result as possible and\n     * identify if any data was missing from the store.\n     */\n    StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n        var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? \"ROOT_QUERY\" : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\n        var policies = this.config.cache.policies;\n        variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\n        var rootRef = makeReference(rootId);\n        var execResult = this.executeSelectionSet({\n            selectionSet: getMainDefinition(query).selectionSet,\n            objectOrReference: rootRef,\n            enclosingRef: rootRef,\n            context: __assign({ store: store, query: query, policies: policies, variables: variables, varString: canonicalStringify(variables), canonizeResults: canonizeResults }, extractFragmentContext(query, this.config.fragments)),\n        });\n        var missing;\n        if (execResult.missing) {\n            // For backwards compatibility we still report an array of\n            // MissingFieldError objects, even though there will only ever be at most\n            // one of them, now that all missing field error messages are grouped\n            // together in the execResult.missing tree.\n            missing = [\n                new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables),\n            ];\n            if (!returnPartialData) {\n                throw missing[0];\n            }\n        }\n        return {\n            result: execResult.result,\n            complete: !missing,\n            missing: missing,\n        };\n    };\n    StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n        if (supportsResultCaching(context.store) &&\n            this.knownResults.get(result) === selectionSet) {\n            var latest = this.executeSelectionSet.peek(selectionSet, parent, context, \n            // If result is canonical, then it could only have been previously\n            // cached by the canonizing version of executeSelectionSet, so we can\n            // avoid checking both possibilities here.\n            this.canon.isKnown(result));\n            if (latest && result === latest.result) {\n                return true;\n            }\n        }\n        return false;\n    };\n    // Uncached version of executeSelectionSet.\n    StoreReader.prototype.execSelectionSetImpl = function (_a) {\n        var _this = this;\n        var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context = _a.context;\n        if (isReference(objectOrReference) &&\n            !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n            !context.store.has(objectOrReference.__ref)) {\n            return {\n                result: this.canon.empty,\n                missing: \"Dangling reference to missing \".concat(objectOrReference.__ref, \" object\"),\n            };\n        }\n        var variables = context.variables, policies = context.policies, store = context.store;\n        var typename = store.getFieldValue(objectOrReference, \"__typename\");\n        var objectsToMerge = [];\n        var missing;\n        var missingMerger = new DeepMerger();\n        if (this.config.addTypename &&\n            typeof typename === \"string\" &&\n            !policies.rootIdsByTypename[typename]) {\n            // Ensure we always include a default value for the __typename\n            // field, if we have one, and this.config.addTypename is true. Note\n            // that this field can be overridden by other merged objects.\n            objectsToMerge.push({ __typename: typename });\n        }\n        function handleMissing(result, resultName) {\n            var _a;\n            if (result.missing) {\n                missing = missingMerger.merge(missing, (_a = {},\n                    _a[resultName] = result.missing,\n                    _a));\n            }\n            return result.result;\n        }\n        var workSet = new Set(selectionSet.selections);\n        workSet.forEach(function (selection) {\n            var _a, _b;\n            // Omit fields with directives @skip(if: <truthy value>) or\n            // @include(if: <falsy value>).\n            if (!shouldInclude(selection, variables))\n                return;\n            if (isField(selection)) {\n                var fieldValue = policies.readField({\n                    fieldName: selection.name.value,\n                    field: selection,\n                    variables: context.variables,\n                    from: objectOrReference,\n                }, context);\n                var resultName = resultKeyNameFromField(selection);\n                if (fieldValue === void 0) {\n                    if (!addTypenameToDocument.added(selection)) {\n                        missing = missingMerger.merge(missing, (_a = {},\n                            _a[resultName] = \"Can't find field '\".concat(selection.name.value, \"' on \").concat(isReference(objectOrReference) ?\n                                objectOrReference.__ref + \" object\"\n                                : \"object \" + JSON.stringify(objectOrReference, null, 2)),\n                            _a));\n                    }\n                }\n                else if (isArray(fieldValue)) {\n                    fieldValue = handleMissing(_this.executeSubSelectedArray({\n                        field: selection,\n                        array: fieldValue,\n                        enclosingRef: enclosingRef,\n                        context: context,\n                    }), resultName);\n                }\n                else if (!selection.selectionSet) {\n                    // If the field does not have a selection set, then we handle it\n                    // as a scalar value. To keep this.canon from canonicalizing\n                    // this value, we use this.canon.pass to wrap fieldValue in a\n                    // Pass object that this.canon.admit will later unwrap as-is.\n                    if (context.canonizeResults) {\n                        fieldValue = _this.canon.pass(fieldValue);\n                    }\n                }\n                else if (fieldValue != null) {\n                    // In this case, because we know the field has a selection set,\n                    // it must be trying to query a GraphQLObjectType, which is why\n                    // fieldValue must be != null.\n                    fieldValue = handleMissing(_this.executeSelectionSet({\n                        selectionSet: selection.selectionSet,\n                        objectOrReference: fieldValue,\n                        enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n                        context: context,\n                    }), resultName);\n                }\n                if (fieldValue !== void 0) {\n                    objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));\n                }\n            }\n            else {\n                var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n                if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n                    throw newInvariantError(9, selection.name.value);\n                }\n                if (fragment && policies.fragmentMatches(fragment, typename)) {\n                    fragment.selectionSet.selections.forEach(workSet.add, workSet);\n                }\n            }\n        });\n        var result = mergeDeepArray(objectsToMerge);\n        var finalResult = { result: result, missing: missing };\n        var frozen = context.canonizeResults ?\n            this.canon.admit(finalResult)\n            // Since this.canon is normally responsible for freezing results (only in\n            // development), freeze them manually if canonization is disabled.\n            : maybeDeepFreeze(finalResult);\n        // Store this result with its selection set so that we can quickly\n        // recognize it again in the StoreReader#isFresh method.\n        if (frozen.result) {\n            this.knownResults.set(frozen.result, selectionSet);\n        }\n        return frozen;\n    };\n    // Uncached version of executeSubSelectedArray.\n    StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n        var _this = this;\n        var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context = _a.context;\n        var missing;\n        var missingMerger = new DeepMerger();\n        function handleMissing(childResult, i) {\n            var _a;\n            if (childResult.missing) {\n                missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));\n            }\n            return childResult.result;\n        }\n        if (field.selectionSet) {\n            array = array.filter(context.store.canRead);\n        }\n        array = array.map(function (item, i) {\n            // null value in array\n            if (item === null) {\n                return null;\n            }\n            // This is a nested array, recurse\n            if (isArray(item)) {\n                return handleMissing(_this.executeSubSelectedArray({\n                    field: field,\n                    array: item,\n                    enclosingRef: enclosingRef,\n                    context: context,\n                }), i);\n            }\n            // This is an object, run the selection set on it\n            if (field.selectionSet) {\n                return handleMissing(_this.executeSelectionSet({\n                    selectionSet: field.selectionSet,\n                    objectOrReference: item,\n                    enclosingRef: isReference(item) ? item : enclosingRef,\n                    context: context,\n                }), i);\n            }\n            if (globalThis.__DEV__ !== false) {\n                assertSelectionSetForIdValue(context.store, field, item);\n            }\n            return item;\n        });\n        return {\n            result: context.canonizeResults ? this.canon.admit(array) : array,\n            missing: missing,\n        };\n    };\n    return StoreReader;\n}());\nexport { StoreReader };\nfunction firstMissing(tree) {\n    try {\n        JSON.stringify(tree, function (_, value) {\n            if (typeof value === \"string\")\n                throw value;\n            return value;\n        });\n    }\n    catch (result) {\n        return result;\n    }\n}\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n    if (!field.selectionSet) {\n        var workSet_1 = new Set([fieldValue]);\n        workSet_1.forEach(function (value) {\n            if (isNonNullObject(value)) {\n                invariant(\n                    !isReference(value),\n                    10,\n                    getTypenameFromStoreObject(store, value),\n                    field.name.value\n                );\n                Object.values(value).forEach(workSet_1.add, workSet_1);\n            }\n        });\n    }\n}\n", "import { dep, Slot } from \"optimism\";\n// Contextual Slot that acquires its value when custom read functions are\n// called in Policies#readField.\nexport var cacheSlot = new Slot();\nvar cacheInfoMap = new WeakMap();\nfunction getCacheInfo(cache) {\n    var info = cacheInfoMap.get(cache);\n    if (!info) {\n        cacheInfoMap.set(cache, (info = {\n            vars: new Set(),\n            dep: dep(),\n        }));\n    }\n    return info;\n}\nexport function forgetCache(cache) {\n    getCacheInfo(cache).vars.forEach(function (rv) { return rv.forgetCache(cache); });\n}\n// Calling forgetCache(cache) serves to silence broadcasts and allows the\n// cache to be garbage collected. However, the varsByCache WeakMap\n// preserves the set of reactive variables that were previously associated\n// with this cache, which makes it possible to \"recall\" the cache at a\n// later time, by reattaching it to those variables. If the cache has been\n// garbage collected in the meantime, because it is no longer reachable,\n// you won't be able to call recallCache(cache), and the cache will\n// automatically disappear from the varsByCache WeakMap.\nexport function recallCache(cache) {\n    getCacheInfo(cache).vars.forEach(function (rv) { return rv.attachCache(cache); });\n}\nexport function makeVar(value) {\n    var caches = new Set();\n    var listeners = new Set();\n    var rv = function (newValue) {\n        if (arguments.length > 0) {\n            if (value !== newValue) {\n                value = newValue;\n                caches.forEach(function (cache) {\n                    // Invalidate any fields with custom read functions that\n                    // consumed this variable, so query results involving those\n                    // fields will be recomputed the next time we read them.\n                    getCacheInfo(cache).dep.dirty(rv);\n                    // Broadcast changes to any caches that have previously read\n                    // from this variable.\n                    broadcast(cache);\n                });\n                // Finally, notify any listeners added via rv.onNextChange.\n                var oldListeners = Array.from(listeners);\n                listeners.clear();\n                oldListeners.forEach(function (listener) { return listener(value); });\n            }\n        }\n        else {\n            // When reading from the variable, obtain the current cache from\n            // context via cacheSlot. This isn't entirely foolproof, but it's\n            // the same system that powers varDep.\n            var cache = cacheSlot.getValue();\n            if (cache) {\n                attach(cache);\n                getCacheInfo(cache).dep(rv);\n            }\n        }\n        return value;\n    };\n    rv.onNextChange = function (listener) {\n        listeners.add(listener);\n        return function () {\n            listeners.delete(listener);\n        };\n    };\n    var attach = (rv.attachCache = function (cache) {\n        caches.add(cache);\n        getCacheInfo(cache).vars.add(rv);\n        return rv;\n    });\n    rv.forgetCache = function (cache) { return caches.delete(cache); };\n    return rv;\n}\nfunction broadcast(cache) {\n    if (cache.broadcastWatches) {\n        cache.broadcastWatches();\n    }\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport { argumentsObjectFromField, DeepMerger, isNonEmptyArray, isNonNullObject, } from \"../../utilities/index.js\";\nimport { hasOwn, isArray } from \"./helpers.js\";\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nvar specifierInfoCache = Object.create(null);\nfunction lookupSpecifierInfo(spec) {\n    // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n    // just arrays of strings or nested KeySpecifier arrays, and the order of the\n    // array elements is important (and suitably preserved by JSON.stringify).\n    var cacheKey = JSON.stringify(spec);\n    return (specifierInfoCache[cacheKey] ||\n        (specifierInfoCache[cacheKey] = Object.create(null)));\n}\nexport function keyFieldsFnFromSpecifier(specifier) {\n    var info = lookupSpecifierInfo(specifier);\n    return (info.keyFieldsFn || (info.keyFieldsFn = function (object, context) {\n            var extract = function (from, key) {\n                return context.readField(key, from);\n            };\n            var keyObject = (context.keyObject = collectSpecifierPaths(specifier, function (schemaKeyPath) {\n                var extracted = extractKeyPath(context.storeObject, schemaKeyPath, \n                // Using context.readField to extract paths from context.storeObject\n                // allows the extraction to see through Reference objects and respect\n                // custom read functions.\n                extract);\n                if (extracted === void 0 &&\n                    object !== context.storeObject &&\n                    hasOwn.call(object, schemaKeyPath[0])) {\n                    // If context.storeObject fails to provide a value for the requested\n                    // path, fall back to the raw result object, if it has a top-level key\n                    // matching the first key in the path (schemaKeyPath[0]). This allows\n                    // key fields included in the written data to be saved in the cache\n                    // even if they are not selected explicitly in context.selectionSet.\n                    // Not being mentioned by context.selectionSet is convenient here,\n                    // since it means these extra fields cannot be affected by field\n                    // aliasing, which is why we can use extractKey instead of\n                    // context.readField for this extraction.\n                    extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n                }\n                invariant(extracted !== void 0, 4, schemaKeyPath.join(\".\"), object);\n                return extracted;\n            }));\n            return \"\".concat(context.typename, \":\").concat(JSON.stringify(keyObject));\n        }));\n}\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nexport function keyArgsFnFromSpecifier(specifier) {\n    var info = lookupSpecifierInfo(specifier);\n    return (info.keyArgsFn ||\n        (info.keyArgsFn = function (args, _a) {\n            var field = _a.field, variables = _a.variables, fieldName = _a.fieldName;\n            var collected = collectSpecifierPaths(specifier, function (keyPath) {\n                var firstKey = keyPath[0];\n                var firstChar = firstKey.charAt(0);\n                if (firstChar === \"@\") {\n                    if (field && isNonEmptyArray(field.directives)) {\n                        var directiveName_1 = firstKey.slice(1);\n                        // If the directive appears multiple times, only the first\n                        // occurrence's arguments will be used. TODO Allow repetition?\n                        // TODO Cache this work somehow, a la aliasMap?\n                        var d = field.directives.find(function (d) { return d.name.value === directiveName_1; });\n                        // Fortunately argumentsObjectFromField works for DirectiveNode!\n                        var directiveArgs = d && argumentsObjectFromField(d, variables);\n                        // For directives without arguments (d defined, but directiveArgs ===\n                        // null), the presence or absence of the directive still counts as\n                        // part of the field key, so we return null in those cases. If no\n                        // directive with this name was found for this field (d undefined and\n                        // thus directiveArgs undefined), we return undefined, which causes\n                        // this value to be omitted from the key object returned by\n                        // collectSpecifierPaths.\n                        return (directiveArgs &&\n                            extractKeyPath(directiveArgs, \n                            // If keyPath.length === 1, this code calls extractKeyPath with an\n                            // empty path, which works because it uses directiveArgs as the\n                            // extracted value.\n                            keyPath.slice(1)));\n                    }\n                    // If the key started with @ but there was no corresponding directive,\n                    // we want to omit this value from the key object, not fall through to\n                    // treating @whatever as a normal argument name.\n                    return;\n                }\n                if (firstChar === \"$\") {\n                    var variableName = firstKey.slice(1);\n                    if (variables && hasOwn.call(variables, variableName)) {\n                        var varKeyPath = keyPath.slice(0);\n                        varKeyPath[0] = variableName;\n                        return extractKeyPath(variables, varKeyPath);\n                    }\n                    // If the key started with $ but there was no corresponding variable, we\n                    // want to omit this value from the key object, not fall through to\n                    // treating $whatever as a normal argument name.\n                    return;\n                }\n                if (args) {\n                    return extractKeyPath(args, keyPath);\n                }\n            });\n            var suffix = JSON.stringify(collected);\n            // If no arguments were passed to this field, and it didn't have any other\n            // field key contributions from directives or variables, hide the empty\n            // :{} suffix from the field key. However, a field passed no arguments can\n            // still end up with a non-empty :{...} suffix if its key configuration\n            // refers to directives or variables.\n            if (args || suffix !== \"{}\") {\n                fieldName += \":\" + suffix;\n            }\n            return fieldName;\n        }));\n}\nexport function collectSpecifierPaths(specifier, extractor) {\n    // For each path specified by specifier, invoke the extractor, and repeatedly\n    // merge the results together, with appropriate ancestor context.\n    var merger = new DeepMerger();\n    return getSpecifierPaths(specifier).reduce(function (collected, path) {\n        var _a;\n        var toMerge = extractor(path);\n        if (toMerge !== void 0) {\n            // This path is not expected to contain array indexes, so the toMerge\n            // reconstruction will not contain arrays. TODO Fix this?\n            for (var i = path.length - 1; i >= 0; --i) {\n                toMerge = (_a = {}, _a[path[i]] = toMerge, _a);\n            }\n            collected = merger.merge(collected, toMerge);\n        }\n        return collected;\n    }, Object.create(null));\n}\nexport function getSpecifierPaths(spec) {\n    var info = lookupSpecifierInfo(spec);\n    if (!info.paths) {\n        var paths_1 = (info.paths = []);\n        var currentPath_1 = [];\n        spec.forEach(function (s, i) {\n            if (isArray(s)) {\n                getSpecifierPaths(s).forEach(function (p) { return paths_1.push(currentPath_1.concat(p)); });\n                currentPath_1.length = 0;\n            }\n            else {\n                currentPath_1.push(s);\n                if (!isArray(spec[i + 1])) {\n                    paths_1.push(currentPath_1.slice(0));\n                    currentPath_1.length = 0;\n                }\n            }\n        });\n    }\n    return info.paths;\n}\nfunction extractKey(object, key) {\n    return object[key];\n}\nexport function extractKeyPath(object, path, extract) {\n    // For each key in path, extract the corresponding child property from obj,\n    // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n    // possible). The final result of path.reduce is normalized so unexpected leaf\n    // objects have their keys safely sorted. That final result is difficult to\n    // type as anything other than any. You're welcome to try to improve the\n    // return type, but keep in mind extractKeyPath is not a public function\n    // (exported only for testing), so the effort may not be worthwhile unless the\n    // limited set of actual callers (see above) pass arguments that TypeScript\n    // can statically type. If we know only that path is some array of strings\n    // (and not, say, a specific tuple of statically known strings), any (or\n    // possibly unknown) is the honest answer.\n    extract = extract || extractKey;\n    return normalize(path.reduce(function reducer(obj, key) {\n        return isArray(obj) ?\n            obj.map(function (child) { return reducer(child, key); })\n            : obj && extract(obj, key);\n    }, object));\n}\nfunction normalize(value) {\n    // Usually the extracted value will be a scalar value, since most primary\n    // key fields are scalar, but just in case we get an object or an array, we\n    // need to do some normalization of the order of (nested) keys.\n    if (isNonNullObject(value)) {\n        if (isArray(value)) {\n            return value.map(normalize);\n        }\n        return collectSpecifierPaths(Object.keys(value).sort(), function (path) {\n            return extractKeyPath(value, path);\n        });\n    }\n    return value;\n}\n", "import { __assign, __rest } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, isNonNullObject, stringifyForDisplay, } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp, defaultDataIdFromObject, isArray, } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\n// Upgrade to a faster version of the default stable JSON.stringify function\n// used by getStoreKeyName. This function is used when computing storeFieldName\n// strings (when no keyArgs has been configured for a field).\nimport { canonicalStringify } from \"./object-canon.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier, } from \"./key-extractor.js\";\ngetStoreKeyName.setStringify(canonicalStringify);\nfunction argsFromFieldSpecifier(spec) {\n    return (spec.args !== void 0 ? spec.args\n        : spec.field ? argumentsObjectFromField(spec.field, spec.variables)\n            : null);\n}\nvar nullKeyFieldsFn = function () { return void 0; };\nvar simpleKeyArgsFn = function (_args, context) { return context.fieldName; };\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nvar mergeTrueFn = function (existing, incoming, _a) {\n    var mergeObjects = _a.mergeObjects;\n    return mergeObjects(existing, incoming);\n};\nvar mergeFalseFn = function (_, incoming) { return incoming; };\nvar Policies = /** @class */ (function () {\n    function Policies(config) {\n        this.config = config;\n        this.typePolicies = Object.create(null);\n        this.toBeAdded = Object.create(null);\n        // Map from subtype names to sets of supertype names. Note that this\n        // representation inverts the structure of possibleTypes (whose keys are\n        // supertypes and whose values are arrays of subtypes) because it tends\n        // to be much more efficient to search upwards than downwards.\n        this.supertypeMap = new Map();\n        // Any fuzzy subtypes specified by possibleTypes will be converted to\n        // RegExp objects and recorded here. Every key of this map can also be\n        // found in supertypeMap. In many cases this Map will be empty, which\n        // means no fuzzy subtype checking will happen in fragmentMatches.\n        this.fuzzySubtypes = new Map();\n        this.rootIdsByTypename = Object.create(null);\n        this.rootTypenamesById = Object.create(null);\n        this.usingPossibleTypes = false;\n        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);\n        this.cache = this.config.cache;\n        this.setRootTypename(\"Query\");\n        this.setRootTypename(\"Mutation\");\n        this.setRootTypename(\"Subscription\");\n        if (config.possibleTypes) {\n            this.addPossibleTypes(config.possibleTypes);\n        }\n        if (config.typePolicies) {\n            this.addTypePolicies(config.typePolicies);\n        }\n    }\n    Policies.prototype.identify = function (object, partialContext) {\n        var _a;\n        var policies = this;\n        var typename = (partialContext &&\n            (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename))) ||\n            object.__typename;\n        // It should be possible to write root Query fields with writeFragment,\n        // using { __typename: \"Query\", ... } as the data, but it does not make\n        // sense to allow the same identification behavior for the Mutation and\n        // Subscription types, since application code should never be writing\n        // directly to (or reading directly from) those root objects.\n        if (typename === this.rootTypenamesById.ROOT_QUERY) {\n            return [\"ROOT_QUERY\"];\n        }\n        // Default context.storeObject to object if not otherwise provided.\n        var storeObject = (partialContext && partialContext.storeObject) || object;\n        var context = __assign(__assign({}, partialContext), { typename: typename, storeObject: storeObject, readField: (partialContext && partialContext.readField) ||\n                function () {\n                    var options = normalizeReadFieldOptions(arguments, storeObject);\n                    return policies.readField(options, {\n                        store: policies.cache[\"data\"],\n                        variables: options.variables,\n                    });\n                } });\n        var id;\n        var policy = typename && this.getTypePolicy(typename);\n        var keyFn = (policy && policy.keyFn) || this.config.dataIdFromObject;\n        while (keyFn) {\n            var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);\n            if (isArray(specifierOrId)) {\n                keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n            }\n            else {\n                id = specifierOrId;\n                break;\n            }\n        }\n        id = id ? String(id) : void 0;\n        return context.keyObject ? [id, context.keyObject] : [id];\n    };\n    Policies.prototype.addTypePolicies = function (typePolicies) {\n        var _this = this;\n        Object.keys(typePolicies).forEach(function (typename) {\n            var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = __rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]);\n            // Though {query,mutation,subscription}Type configurations are rare,\n            // it's important to call setRootTypename as early as possible,\n            // since these configurations should apply consistently for the\n            // entire lifetime of the cache. Also, since only one __typename can\n            // qualify as one of these root types, these three properties cannot\n            // be inherited, unlike the rest of the incoming properties. That\n            // restriction is convenient, because the purpose of this.toBeAdded\n            // is to delay the processing of type/field policies until the first\n            // time they're used, allowing policies to be added in any order as\n            // long as all relevant policies (including policies for supertypes)\n            // have been added by the time a given policy is used for the first\n            // time. In other words, since inheritance doesn't matter for these\n            // properties, there's also no need to delay their processing using\n            // the this.toBeAdded queue.\n            if (queryType)\n                _this.setRootTypename(\"Query\", typename);\n            if (mutationType)\n                _this.setRootTypename(\"Mutation\", typename);\n            if (subscriptionType)\n                _this.setRootTypename(\"Subscription\", typename);\n            if (hasOwn.call(_this.toBeAdded, typename)) {\n                _this.toBeAdded[typename].push(incoming);\n            }\n            else {\n                _this.toBeAdded[typename] = [incoming];\n            }\n        });\n    };\n    Policies.prototype.updateTypePolicy = function (typename, incoming) {\n        var _this = this;\n        var existing = this.getTypePolicy(typename);\n        var keyFields = incoming.keyFields, fields = incoming.fields;\n        function setMerge(existing, merge) {\n            existing.merge =\n                typeof merge === \"function\" ? merge\n                    // Pass merge:true as a shorthand for a merge implementation\n                    // that returns options.mergeObjects(existing, incoming).\n                    : merge === true ? mergeTrueFn\n                        // Pass merge:false to make incoming always replace existing\n                        // without any warnings about data clobbering.\n                        : merge === false ? mergeFalseFn\n                            : existing.merge;\n        }\n        // Type policies can define merge functions, as an alternative to\n        // using field policies to merge child objects.\n        setMerge(existing, incoming.merge);\n        existing.keyFn =\n            // Pass false to disable normalization for this typename.\n            keyFields === false ? nullKeyFieldsFn\n                // Pass an array of strings to use those fields to compute a\n                // composite ID for objects of this typename.\n                : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\n                    // Pass a function to take full control over identification.\n                    : typeof keyFields === \"function\" ? keyFields\n                        // Leave existing.keyFn unchanged if above cases fail.\n                        : existing.keyFn;\n        if (fields) {\n            Object.keys(fields).forEach(function (fieldName) {\n                var existing = _this.getFieldPolicy(typename, fieldName, true);\n                var incoming = fields[fieldName];\n                if (typeof incoming === \"function\") {\n                    existing.read = incoming;\n                }\n                else {\n                    var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;\n                    existing.keyFn =\n                        // Pass false to disable argument-based differentiation of\n                        // field identities.\n                        keyArgs === false ? simpleKeyArgsFn\n                            // Pass an array of strings to use named arguments to\n                            // compute a composite identity for the field.\n                            : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\n                                // Pass a function to take full control over field identity.\n                                : typeof keyArgs === \"function\" ? keyArgs\n                                    // Leave existing.keyFn unchanged if above cases fail.\n                                    : existing.keyFn;\n                    if (typeof read === \"function\") {\n                        existing.read = read;\n                    }\n                    setMerge(existing, merge);\n                }\n                if (existing.read && existing.merge) {\n                    // If we have both a read and a merge function, assume\n                    // keyArgs:false, because read and merge together can take\n                    // responsibility for interpreting arguments in and out. This\n                    // default assumption can always be overridden by specifying\n                    // keyArgs explicitly in the FieldPolicy.\n                    existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n                }\n            });\n        }\n    };\n    Policies.prototype.setRootTypename = function (which, typename) {\n        if (typename === void 0) { typename = which; }\n        var rootId = \"ROOT_\" + which.toUpperCase();\n        var old = this.rootTypenamesById[rootId];\n        if (typename !== old) {\n            invariant(!old || old === which, 5, which);\n            // First, delete any old __typename associated with this rootId from\n            // rootIdsByTypename.\n            if (old)\n                delete this.rootIdsByTypename[old];\n            // Now make this the only __typename that maps to this rootId.\n            this.rootIdsByTypename[typename] = rootId;\n            // Finally, update the __typename associated with this rootId.\n            this.rootTypenamesById[rootId] = typename;\n        }\n    };\n    Policies.prototype.addPossibleTypes = function (possibleTypes) {\n        var _this = this;\n        this.usingPossibleTypes = true;\n        Object.keys(possibleTypes).forEach(function (supertype) {\n            // Make sure all types have an entry in this.supertypeMap, even if\n            // their supertype set is empty, so we can return false immediately\n            // from policies.fragmentMatches for unknown supertypes.\n            _this.getSupertypeSet(supertype, true);\n            possibleTypes[supertype].forEach(function (subtype) {\n                _this.getSupertypeSet(subtype, true).add(supertype);\n                var match = subtype.match(TypeOrFieldNameRegExp);\n                if (!match || match[0] !== subtype) {\n                    // TODO Don't interpret just any invalid typename as a RegExp.\n                    _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n                }\n            });\n        });\n    };\n    Policies.prototype.getTypePolicy = function (typename) {\n        var _this = this;\n        if (!hasOwn.call(this.typePolicies, typename)) {\n            var policy_1 = (this.typePolicies[typename] = Object.create(null));\n            policy_1.fields = Object.create(null);\n            // When the TypePolicy for typename is first accessed, instead of\n            // starting with an empty policy object, inherit any properties or\n            // fields from the type policies of the supertypes of typename.\n            //\n            // Any properties or fields defined explicitly within the TypePolicy\n            // for typename will take precedence, and if there are multiple\n            // supertypes, the properties of policies whose types were added\n            // later via addPossibleTypes will take precedence over those of\n            // earlier supertypes. TODO Perhaps we should warn about these\n            // conflicts in development, and recommend defining the property\n            // explicitly in the subtype policy?\n            //\n            // Field policy inheritance is atomic/shallow: you can't inherit a\n            // field policy and then override just its read function, since read\n            // and merge functions often need to cooperate, so changing only one\n            // of them would be a recipe for inconsistency.\n            //\n            // Once the TypePolicy for typename has been accessed, its properties can\n            // still be updated directly using addTypePolicies, but future changes to\n            // inherited supertype policies will not be reflected in this subtype\n            // policy, because this code runs at most once per typename.\n            var supertypes_1 = this.supertypeMap.get(typename);\n            if (!supertypes_1 && this.fuzzySubtypes.size) {\n                // To make the inheritance logic work for unknown typename strings that\n                // may have fuzzy supertypes, we give this typename an empty supertype\n                // set and then populate it with any fuzzy supertypes that match.\n                supertypes_1 = this.getSupertypeSet(typename, true);\n                // This only works for typenames that are directly matched by a fuzzy\n                // supertype. What if there is an intermediate chain of supertypes?\n                // While possible, that situation can only be solved effectively by\n                // specifying the intermediate relationships via possibleTypes, manually\n                // and in a non-fuzzy way.\n                this.fuzzySubtypes.forEach(function (regExp, fuzzy) {\n                    if (regExp.test(typename)) {\n                        // The fuzzy parameter is just the original string version of regExp\n                        // (not a valid __typename string), but we can look up the\n                        // associated supertype(s) in this.supertypeMap.\n                        var fuzzySupertypes = _this.supertypeMap.get(fuzzy);\n                        if (fuzzySupertypes) {\n                            fuzzySupertypes.forEach(function (supertype) {\n                                return supertypes_1.add(supertype);\n                            });\n                        }\n                    }\n                });\n            }\n            if (supertypes_1 && supertypes_1.size) {\n                supertypes_1.forEach(function (supertype) {\n                    var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = __rest(_a, [\"fields\"]);\n                    Object.assign(policy_1, rest);\n                    Object.assign(policy_1.fields, fields);\n                });\n            }\n        }\n        var inbox = this.toBeAdded[typename];\n        if (inbox && inbox.length) {\n            // Merge the pending policies into this.typePolicies, in the order they\n            // were originally passed to addTypePolicy.\n            inbox.splice(0).forEach(function (policy) {\n                _this.updateTypePolicy(typename, policy);\n            });\n        }\n        return this.typePolicies[typename];\n    };\n    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n        if (typename) {\n            var fieldPolicies = this.getTypePolicy(typename).fields;\n            return (fieldPolicies[fieldName] ||\n                (createIfMissing && (fieldPolicies[fieldName] = Object.create(null))));\n        }\n    };\n    Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n        var supertypeSet = this.supertypeMap.get(subtype);\n        if (!supertypeSet && createIfMissing) {\n            this.supertypeMap.set(subtype, (supertypeSet = new Set()));\n        }\n        return supertypeSet;\n    };\n    Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n        var _this = this;\n        if (!fragment.typeCondition)\n            return true;\n        // If the fragment has a type condition but the object we're matching\n        // against does not have a __typename, the fragment cannot match.\n        if (!typename)\n            return false;\n        var supertype = fragment.typeCondition.name.value;\n        // Common case: fragment type condition and __typename are the same.\n        if (typename === supertype)\n            return true;\n        if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n            var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n            var workQueue_1 = [typenameSupertypeSet];\n            var maybeEnqueue_1 = function (subtype) {\n                var supertypeSet = _this.getSupertypeSet(subtype, false);\n                if (supertypeSet &&\n                    supertypeSet.size &&\n                    workQueue_1.indexOf(supertypeSet) < 0) {\n                    workQueue_1.push(supertypeSet);\n                }\n            };\n            // We need to check fuzzy subtypes only if we encountered fuzzy\n            // subtype strings in addPossibleTypes, and only while writing to\n            // the cache, since that's when selectionSetMatchesResult gives a\n            // strong signal of fragment matching. The StoreReader class calls\n            // policies.fragmentMatches without passing a result object, so\n            // needToCheckFuzzySubtypes is always false while reading.\n            var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n            var checkingFuzzySubtypes = false;\n            // It's important to keep evaluating workQueue.length each time through\n            // the loop, because the queue can grow while we're iterating over it.\n            for (var i = 0; i < workQueue_1.length; ++i) {\n                var supertypeSet = workQueue_1[i];\n                if (supertypeSet.has(supertype)) {\n                    if (!typenameSupertypeSet.has(supertype)) {\n                        if (checkingFuzzySubtypes) {\n                            globalThis.__DEV__ !== false && invariant.warn(6, typename, supertype);\n                        }\n                        // Record positive results for faster future lookup.\n                        // Unfortunately, we cannot safely cache negative results,\n                        // because new possibleTypes data could always be added to the\n                        // Policies class.\n                        typenameSupertypeSet.add(supertype);\n                    }\n                    return true;\n                }\n                supertypeSet.forEach(maybeEnqueue_1);\n                if (needToCheckFuzzySubtypes &&\n                    // Start checking fuzzy subtypes only after exhausting all\n                    // non-fuzzy subtypes (after the final iteration of the loop).\n                    i === workQueue_1.length - 1 &&\n                    // We could wait to compare fragment.selectionSet to result\n                    // after we verify the supertype, but this check is often less\n                    // expensive than that search, and we will have to do the\n                    // comparison anyway whenever we find a potential match.\n                    selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n                    // We don't always need to check fuzzy subtypes (if no result\n                    // was provided, or !this.fuzzySubtypes.size), but, when we do,\n                    // we only want to check them once.\n                    needToCheckFuzzySubtypes = false;\n                    checkingFuzzySubtypes = true;\n                    // If we find any fuzzy subtypes that match typename, extend the\n                    // workQueue to search through the supertypes of those fuzzy\n                    // subtypes. Otherwise the for-loop will terminate and we'll\n                    // return false below.\n                    this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n                        var match = typename.match(regExp);\n                        if (match && match[0] === typename) {\n                            maybeEnqueue_1(fuzzyString);\n                        }\n                    });\n                }\n            }\n        }\n        return false;\n    };\n    Policies.prototype.hasKeyArgs = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return !!(policy && policy.keyFn);\n    };\n    Policies.prototype.getStoreFieldName = function (fieldSpec) {\n        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        var storeFieldName;\n        var keyFn = policy && policy.keyFn;\n        if (keyFn && typename) {\n            var context = {\n                typename: typename,\n                fieldName: fieldName,\n                field: fieldSpec.field || null,\n                variables: fieldSpec.variables,\n            };\n            var args = argsFromFieldSpecifier(fieldSpec);\n            while (keyFn) {\n                var specifierOrString = keyFn(args, context);\n                if (isArray(specifierOrString)) {\n                    keyFn = keyArgsFnFromSpecifier(specifierOrString);\n                }\n                else {\n                    // If the custom keyFn returns a falsy value, fall back to\n                    // fieldName instead.\n                    storeFieldName = specifierOrString || fieldName;\n                    break;\n                }\n            }\n        }\n        if (storeFieldName === void 0) {\n            storeFieldName =\n                fieldSpec.field ?\n                    storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n                    : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n        }\n        // Returning false from a keyArgs function is like configuring\n        // keyArgs: false, but more dynamic.\n        if (storeFieldName === false) {\n            return fieldName;\n        }\n        // Make sure custom field names start with the actual field.name.value\n        // of the field, so we can always figure out which properties of a\n        // StoreObject correspond to which original field names.\n        return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName\n            : fieldName + \":\" + storeFieldName;\n    };\n    Policies.prototype.readField = function (options, context) {\n        var objectOrReference = options.from;\n        if (!objectOrReference)\n            return;\n        var nameOrField = options.field || options.fieldName;\n        if (!nameOrField)\n            return;\n        if (options.typename === void 0) {\n            var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n            if (typename)\n                options.typename = typename;\n        }\n        var storeFieldName = this.getStoreFieldName(options);\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n        var policy = this.getFieldPolicy(options.typename, fieldName, false);\n        var read = policy && policy.read;\n        if (read) {\n            var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ?\n                objectOrReference.__ref\n                : objectOrReference, storeFieldName));\n            // Call read(existing, readOptions) with cacheSlot holding this.cache.\n            return cacheSlot.withValue(this.cache, read, [\n                existing,\n                readOptions,\n            ]);\n        }\n        return existing;\n    };\n    Policies.prototype.getReadFunction = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return policy && policy.read;\n    };\n    Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\n        var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n        var merge = policy && policy.merge;\n        if (!merge && childTypename) {\n            policy = this.getTypePolicy(childTypename);\n            merge = policy && policy.merge;\n        }\n        return merge;\n    };\n    Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\n        var field = _a.field, typename = _a.typename, merge = _a.merge;\n        if (merge === mergeTrueFn) {\n            // Instead of going to the trouble of creating a full\n            // FieldFunctionOptions object and calling mergeTrueFn, we can\n            // simply call mergeObjects, as mergeTrueFn would.\n            return makeMergeObjectsFunction(context.store)(existing, incoming);\n        }\n        if (merge === mergeFalseFn) {\n            // Likewise for mergeFalseFn, whose implementation is even simpler.\n            return incoming;\n        }\n        // If cache.writeQuery or cache.writeFragment was called with\n        // options.overwrite set to true, we still call merge functions, but\n        // the existing data is always undefined, so the merge function will\n        // not attempt to combine the incoming data with the existing data.\n        if (context.overwrite) {\n            existing = void 0;\n        }\n        return merge(existing, incoming, makeFieldFunctionOptions(this, \n        // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0, {\n            typename: typename,\n            fieldName: field.name.value,\n            field: field,\n            variables: context.variables,\n        }, context, storage || Object.create(null)));\n    };\n    return Policies;\n}());\nexport { Policies };\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n    var storeFieldName = policies.getStoreFieldName(fieldSpec);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var variables = fieldSpec.variables || context.variables;\n    var _a = context.store, toReference = _a.toReference, canRead = _a.canRead;\n    return {\n        args: argsFromFieldSpecifier(fieldSpec),\n        field: fieldSpec.field || null,\n        fieldName: fieldName,\n        storeFieldName: storeFieldName,\n        variables: variables,\n        isReference: isReference,\n        toReference: toReference,\n        storage: storage,\n        cache: policies.cache,\n        canRead: canRead,\n        readField: function () {\n            return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);\n        },\n        mergeObjects: makeMergeObjectsFunction(context.store),\n    };\n}\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n    var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;\n    var options;\n    if (typeof fieldNameOrOptions === \"string\") {\n        options = {\n            fieldName: fieldNameOrOptions,\n            // Default to objectOrReference only when no second argument was\n            // passed for the from parameter, not when undefined is explicitly\n            // passed as the second argument.\n            from: argc > 1 ? from : objectOrReference,\n        };\n    }\n    else {\n        options = __assign({}, fieldNameOrOptions);\n        // Default to objectOrReference only when fieldNameOrOptions.from is\n        // actually omitted, rather than just undefined.\n        if (!hasOwn.call(options, \"from\")) {\n            options.from = objectOrReference;\n        }\n    }\n    if (globalThis.__DEV__ !== false && options.from === void 0) {\n        globalThis.__DEV__ !== false && invariant.warn(7, stringifyForDisplay(Array.from(readFieldArgs)));\n    }\n    if (void 0 === options.variables) {\n        options.variables = variables;\n    }\n    return options;\n}\nfunction makeMergeObjectsFunction(store) {\n    return function mergeObjects(existing, incoming) {\n        if (isArray(existing) || isArray(incoming)) {\n            throw newInvariantError(8);\n        }\n        // These dynamic checks are necessary because the parameters of a\n        // custom merge function can easily have the any type, so the type\n        // system cannot always enforce the StoreObject | Reference parameter\n        // types of options.mergeObjects.\n        if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n            var eType = store.getFieldValue(existing, \"__typename\");\n            var iType = store.getFieldValue(incoming, \"__typename\");\n            var typesDiffer = eType && iType && eType !== iType;\n            if (typesDiffer) {\n                return incoming;\n            }\n            if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n                // Update the normalized EntityStore for the entity identified by\n                // existing.__ref, preferring/overwriting any fields contributed by the\n                // newer incoming StoreObject.\n                store.merge(existing.__ref, incoming);\n                return existing;\n            }\n            if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n                // Update the normalized EntityStore for the entity identified by\n                // incoming.__ref, taking fields from the older existing object only if\n                // those fields are not already present in the newer StoreObject\n                // identified by incoming.__ref.\n                store.merge(existing, incoming.__ref);\n                return incoming;\n            }\n            if (storeValueIsStoreObject(existing) &&\n                storeValueIsStoreObject(incoming)) {\n                return __assign(__assign({}, existing), incoming);\n            }\n        }\n        return incoming;\n    };\n}\n", "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { Kind } from \"graphql\";\nimport { getFragmentFromSelection, getDefaultValues, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField, } from \"../../utilities/index.js\";\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext, } from \"./helpers.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor(context, clientOnly, deferred) {\n    var key = \"\".concat(clientOnly).concat(deferred);\n    var flavored = context.flavors.get(key);\n    if (!flavored) {\n        context.flavors.set(key, (flavored =\n            context.clientOnly === clientOnly && context.deferred === deferred ?\n                context\n                : __assign(__assign({}, context), { clientOnly: clientOnly, deferred: deferred })));\n    }\n    return flavored;\n}\nvar StoreWriter = /** @class */ (function () {\n    function StoreWriter(cache, reader, fragments) {\n        this.cache = cache;\n        this.reader = reader;\n        this.fragments = fragments;\n    }\n    StoreWriter.prototype.writeToStore = function (store, _a) {\n        var _this = this;\n        var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;\n        var operationDefinition = getOperationDefinition(query);\n        var merger = makeProcessedFieldsMerger();\n        variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n        var context = __assign(__assign({ store: store, written: Object.create(null), merge: function (existing, incoming) {\n                return merger.merge(existing, incoming);\n            }, variables: variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: new Map(), clientOnly: false, deferred: false, flavors: new Map() });\n        var ref = this.processSelectionSet({\n            result: result || Object.create(null),\n            dataId: dataId,\n            selectionSet: operationDefinition.selectionSet,\n            mergeTree: { map: new Map() },\n            context: context,\n        });\n        if (!isReference(ref)) {\n            throw newInvariantError(11, result);\n        }\n        // So far, the store has not been modified, so now it's time to process\n        // context.incomingById and merge those incoming fields into context.store.\n        context.incomingById.forEach(function (_a, dataId) {\n            var storeObject = _a.storeObject, mergeTree = _a.mergeTree, fieldNodeSet = _a.fieldNodeSet;\n            var entityRef = makeReference(dataId);\n            if (mergeTree && mergeTree.map.size) {\n                var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n                if (isReference(applied)) {\n                    // Assume References returned by applyMerges have already been merged\n                    // into the store. See makeMergeObjectsFunction in policies.ts for an\n                    // example of how this can happen.\n                    return;\n                }\n                // Otherwise, applyMerges returned a StoreObject, whose fields we should\n                // merge into the store (see store.merge statement below).\n                storeObject = applied;\n            }\n            if (globalThis.__DEV__ !== false && !context.overwrite) {\n                var fieldsWithSelectionSets_1 = Object.create(null);\n                fieldNodeSet.forEach(function (field) {\n                    if (field.selectionSet) {\n                        fieldsWithSelectionSets_1[field.name.value] = true;\n                    }\n                });\n                var hasSelectionSet_1 = function (storeFieldName) {\n                    return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] ===\n                        true;\n                };\n                var hasMergeFunction_1 = function (storeFieldName) {\n                    var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n                    return Boolean(childTree && childTree.info && childTree.info.merge);\n                };\n                Object.keys(storeObject).forEach(function (storeFieldName) {\n                    // If a merge function was defined for this field, trust that it\n                    // did the right thing about (not) clobbering data. If the field\n                    // has no selection set, it's a scalar field, so it doesn't need\n                    // a merge function (even if it's an object, like JSON data).\n                    if (hasSelectionSet_1(storeFieldName) &&\n                        !hasMergeFunction_1(storeFieldName)) {\n                        warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n                    }\n                });\n            }\n            store.merge(dataId, storeObject);\n        });\n        // Any IDs written explicitly to the cache will be retained as\n        // reachable root IDs for garbage collection purposes. Although this\n        // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n        // retainment counts are effectively ignored because cache.gc() always\n        // includes them in its root ID set.\n        store.retain(ref.__ref);\n        return ref;\n    };\n    StoreWriter.prototype.processSelectionSet = function (_a) {\n        var _this = this;\n        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, \n        // This object allows processSelectionSet to report useful information\n        // to its callers without explicitly returning that information.\n        mergeTree = _a.mergeTree;\n        var policies = this.cache.policies;\n        // This variable will be repeatedly updated using context.merge to\n        // accumulate all fields that need to be written into the store.\n        var incoming = Object.create(null);\n        // If typename was not passed in, infer it. Note that typename is\n        // always passed in for tricky-to-infer cases such as \"Query\" for\n        // ROOT_QUERY.\n        var typename = (dataId && policies.rootTypenamesById[dataId]) ||\n            getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n            (dataId && context.store.get(dataId, \"__typename\"));\n        if (\"string\" === typeof typename) {\n            incoming.__typename = typename;\n        }\n        // This readField function will be passed as context.readField in the\n        // KeyFieldsContext object created within policies.identify (called below).\n        // In addition to reading from the existing context.store (thanks to the\n        // policies.readField(options, context) line at the very bottom), this\n        // version of readField can read from Reference objects that are currently\n        // pending in context.incomingById, which is important whenever keyFields\n        // need to be extracted from a child object that processSelectionSet has\n        // turned into a Reference.\n        var readField = function () {\n            var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n            if (isReference(options.from)) {\n                var info = context.incomingById.get(options.from.__ref);\n                if (info) {\n                    var result_1 = policies.readField(__assign(__assign({}, options), { from: info.storeObject }), context);\n                    if (result_1 !== void 0) {\n                        return result_1;\n                    }\n                }\n            }\n            return policies.readField(options, context);\n        };\n        var fieldNodeSet = new Set();\n        this.flattenFields(selectionSet, result, \n        // This WriteContext will be the default context value for fields returned\n        // by the flattenFields method, but some fields may be assigned a modified\n        // context, depending on the presence of @client and other directives.\n        context, typename).forEach(function (context, field) {\n            var _a;\n            var resultFieldKey = resultKeyNameFromField(field);\n            var value = result[resultFieldKey];\n            fieldNodeSet.add(field);\n            if (value !== void 0) {\n                var storeFieldName = policies.getStoreFieldName({\n                    typename: typename,\n                    fieldName: field.name.value,\n                    field: field,\n                    variables: context.variables,\n                });\n                var childTree = getChildMergeTree(mergeTree, storeFieldName);\n                var incomingValue = _this.processFieldValue(value, field, \n                // Reset context.clientOnly and context.deferred to their default\n                // values before processing nested selection sets.\n                field.selectionSet ?\n                    getContextFlavor(context, false, false)\n                    : context, childTree);\n                // To determine if this field holds a child object with a merge function\n                // defined in its type policy (see PR #7070), we need to figure out the\n                // child object's __typename.\n                var childTypename = void 0;\n                // The field's value can be an object that has a __typename only if the\n                // field has a selection set. Otherwise incomingValue is scalar.\n                if (field.selectionSet &&\n                    (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {\n                    childTypename = readField(\"__typename\", incomingValue);\n                }\n                var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n                if (merge) {\n                    childTree.info = {\n                        // TODO Check compatibility against any existing childTree.field?\n                        field: field,\n                        typename: typename,\n                        merge: merge,\n                    };\n                }\n                else {\n                    maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n                }\n                incoming = context.merge(incoming, (_a = {},\n                    _a[storeFieldName] = incomingValue,\n                    _a));\n            }\n            else if (globalThis.__DEV__ !== false &&\n                !context.clientOnly &&\n                !context.deferred &&\n                !addTypenameToDocument.added(field) &&\n                // If the field has a read function, it may be a synthetic field or\n                // provide a default value, so its absence from the written data should\n                // not be cause for alarm.\n                !policies.getReadFunction(typename, field.name.value)) {\n                globalThis.__DEV__ !== false && invariant.error(12, resultKeyNameFromField(field), result);\n            }\n        });\n        // Identify the result object, even if dataId was already provided,\n        // since we always need keyObject below.\n        try {\n            var _b = policies.identify(result, {\n                typename: typename,\n                selectionSet: selectionSet,\n                fragmentMap: context.fragmentMap,\n                storeObject: incoming,\n                readField: readField,\n            }), id = _b[0], keyObject = _b[1];\n            // If dataId was not provided, fall back to the id just generated by\n            // policies.identify.\n            dataId = dataId || id;\n            // Write any key fields that were used during identification, even if\n            // they were not mentioned in the original query.\n            if (keyObject) {\n                // TODO Reverse the order of the arguments?\n                incoming = context.merge(incoming, keyObject);\n            }\n        }\n        catch (e) {\n            // If dataId was provided, tolerate failure of policies.identify.\n            if (!dataId)\n                throw e;\n        }\n        if (\"string\" === typeof dataId) {\n            var dataRef = makeReference(dataId);\n            // Avoid processing the same entity object using the same selection\n            // set more than once. We use an array instead of a Set since most\n            // entity IDs will be written using only one selection set, so the\n            // size of this array is likely to be very small, meaning indexOf is\n            // likely to be faster than Set.prototype.has.\n            var sets = context.written[dataId] || (context.written[dataId] = []);\n            if (sets.indexOf(selectionSet) >= 0)\n                return dataRef;\n            sets.push(selectionSet);\n            // If we're about to write a result object into the store, but we\n            // happen to know that the exact same (===) result object would be\n            // returned if we were to reread the result with the same inputs,\n            // then we can skip the rest of the processSelectionSet work for\n            // this object, and immediately return a Reference to it.\n            if (this.reader &&\n                this.reader.isFresh(result, dataRef, selectionSet, context)) {\n                return dataRef;\n            }\n            var previous_1 = context.incomingById.get(dataId);\n            if (previous_1) {\n                previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n                previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n                fieldNodeSet.forEach(function (field) { return previous_1.fieldNodeSet.add(field); });\n            }\n            else {\n                context.incomingById.set(dataId, {\n                    storeObject: incoming,\n                    // Save a reference to mergeTree only if it is not empty, because\n                    // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n                    // reused for entirely different parts of the result tree.\n                    mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n                    fieldNodeSet: fieldNodeSet,\n                });\n            }\n            return dataRef;\n        }\n        return incoming;\n    };\n    StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n        var _this = this;\n        if (!field.selectionSet || value === null) {\n            // In development, we need to clone scalar values so that they can be\n            // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n            // it's cheaper to store the scalar values directly in the cache.\n            return globalThis.__DEV__ !== false ? cloneDeep(value) : value;\n        }\n        if (isArray(value)) {\n            return value.map(function (item, i) {\n                var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n                maybeRecycleChildMergeTree(mergeTree, i);\n                return value;\n            });\n        }\n        return this.processSelectionSet({\n            result: value,\n            selectionSet: field.selectionSet,\n            context: context,\n            mergeTree: mergeTree,\n        });\n    };\n    // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n    // some additions for tracking @client and @defer directives.\n    StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\n        if (typename === void 0) { typename = getTypenameFromResult(result, selectionSet, context.fragmentMap); }\n        var fieldMap = new Map();\n        var policies = this.cache.policies;\n        var limitingTrie = new Trie(false); // No need for WeakMap, since limitingTrie does not escape.\n        (function flatten(selectionSet, inheritedContext) {\n            var visitedNode = limitingTrie.lookup(selectionSet, \n            // Because we take inheritedClientOnly and inheritedDeferred into\n            // consideration here (in addition to selectionSet), it's possible for\n            // the same selection set to be flattened more than once, if it appears\n            // in the query with different @client and/or @directive configurations.\n            inheritedContext.clientOnly, inheritedContext.deferred);\n            if (visitedNode.visited)\n                return;\n            visitedNode.visited = true;\n            selectionSet.selections.forEach(function (selection) {\n                if (!shouldInclude(selection, context.variables))\n                    return;\n                var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;\n                if (\n                // Since the presence of @client or @defer on this field can only\n                // cause clientOnly or deferred to become true, we can skip the\n                // forEach loop if both clientOnly and deferred are already true.\n                !(clientOnly && deferred) &&\n                    isNonEmptyArray(selection.directives)) {\n                    selection.directives.forEach(function (dir) {\n                        var name = dir.name.value;\n                        if (name === \"client\")\n                            clientOnly = true;\n                        if (name === \"defer\") {\n                            var args = argumentsObjectFromField(dir, context.variables);\n                            // The @defer directive takes an optional args.if boolean\n                            // argument, similar to @include(if: boolean). Note that\n                            // @defer(if: false) does not make context.deferred false, but\n                            // instead behaves as if there was no @defer directive.\n                            if (!args || args.if !== false) {\n                                deferred = true;\n                            }\n                            // TODO In the future, we may want to record args.label using\n                            // context.deferred, if a label is specified.\n                        }\n                    });\n                }\n                if (isField(selection)) {\n                    var existing = fieldMap.get(selection);\n                    if (existing) {\n                        // If this field has been visited along another recursive path\n                        // before, the final context should have clientOnly or deferred set\n                        // to true only if *all* paths have the directive (hence the &&).\n                        clientOnly = clientOnly && existing.clientOnly;\n                        deferred = deferred && existing.deferred;\n                    }\n                    fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n                }\n                else {\n                    var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n                    if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n                        throw newInvariantError(13, selection.name.value);\n                    }\n                    if (fragment &&\n                        policies.fragmentMatches(fragment, typename, result, context.variables)) {\n                        flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n                    }\n                }\n            });\n        })(selectionSet, context);\n        return fieldMap;\n    };\n    StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n        var _a;\n        var _this = this;\n        if (mergeTree.map.size && !isReference(incoming)) {\n            var e_1 = \n            // Items in the same position in different arrays are not\n            // necessarily related to each other, so when incoming is an array\n            // we process its elements as if there was no existing data.\n            (!isArray(incoming) &&\n                // Likewise, existing must be either a Reference or a StoreObject\n                // in order for its fields to be safe to merge with the fields of\n                // the incoming object.\n                (isReference(existing) || storeValueIsStoreObject(existing))) ?\n                existing\n                : void 0;\n            // This narrowing is implied by mergeTree.map.size > 0 and\n            // !isReference(incoming), though TypeScript understandably cannot\n            // hope to infer this type.\n            var i_1 = incoming;\n            // The options.storage objects provided to read and merge functions\n            // are derived from the identity of the parent object plus a\n            // sequence of storeFieldName strings/numbers identifying the nested\n            // field name path of each field value to be merged.\n            if (e_1 && !getStorageArgs) {\n                getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n            }\n            // It's possible that applying merge functions to this subtree will\n            // not change the incoming data, so this variable tracks the fields\n            // that did change, so we can create a new incoming object when (and\n            // only when) at least one incoming field has changed. We use a Map\n            // to preserve the type of numeric keys.\n            var changedFields_1;\n            var getValue_1 = function (from, name) {\n                return (isArray(from) ?\n                    typeof name === \"number\" ?\n                        from[name]\n                        : void 0\n                    : context.store.getFieldValue(from, String(name)));\n            };\n            mergeTree.map.forEach(function (childTree, storeFieldName) {\n                var eVal = getValue_1(e_1, storeFieldName);\n                var iVal = getValue_1(i_1, storeFieldName);\n                // If we have no incoming data, leave any existing data untouched.\n                if (void 0 === iVal)\n                    return;\n                if (getStorageArgs) {\n                    getStorageArgs.push(storeFieldName);\n                }\n                var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n                if (aVal !== iVal) {\n                    changedFields_1 = changedFields_1 || new Map();\n                    changedFields_1.set(storeFieldName, aVal);\n                }\n                if (getStorageArgs) {\n                    invariant(getStorageArgs.pop() === storeFieldName);\n                }\n            });\n            if (changedFields_1) {\n                // Shallow clone i so we can add changed fields to it.\n                incoming = (isArray(i_1) ? i_1.slice(0) : __assign({}, i_1));\n                changedFields_1.forEach(function (value, name) {\n                    incoming[name] = value;\n                });\n            }\n        }\n        if (mergeTree.info) {\n            return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n        }\n        return incoming;\n    };\n    return StoreWriter;\n}());\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n    var map = _a.map;\n    if (!map.has(name)) {\n        map.set(name, emptyMergeTreePool.pop() || { map: new Map() });\n    }\n    return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n    if (left === right || !right || mergeTreeIsEmpty(right))\n        return left;\n    if (!left || mergeTreeIsEmpty(left))\n        return right;\n    var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n    var needToMergeMaps = left.map.size && right.map.size;\n    var map = needToMergeMaps ? new Map()\n        : left.map.size ? left.map\n            : right.map;\n    var merged = { info: info, map: map };\n    if (needToMergeMaps) {\n        var remainingRightKeys_1 = new Set(right.map.keys());\n        left.map.forEach(function (leftTree, key) {\n            merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n            remainingRightKeys_1.delete(key);\n        });\n        remainingRightKeys_1.forEach(function (key) {\n            merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n        });\n    }\n    return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n    return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n    var map = _a.map;\n    var childTree = map.get(name);\n    if (childTree && mergeTreeIsEmpty(childTree)) {\n        emptyMergeTreePool.push(childTree);\n        map.delete(name);\n    }\n}\nvar warnings = new Set();\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n    var getChild = function (objOrRef) {\n        var child = store.getFieldValue(objOrRef, storeFieldName);\n        return typeof child === \"object\" && child;\n    };\n    var existing = getChild(existingRef);\n    if (!existing)\n        return;\n    var incoming = getChild(incomingObj);\n    if (!incoming)\n        return;\n    // It's always safe to replace a reference, since it refers to data\n    // safely stored elsewhere.\n    if (isReference(existing))\n        return;\n    // If the values are structurally equivalent, we do not need to worry\n    // about incoming replacing existing.\n    if (equal(existing, incoming))\n        return;\n    // If we're replacing every key of the existing object, then the\n    // existing data would be overwritten even if the objects were\n    // normalized, so warning would not be helpful here.\n    if (Object.keys(existing).every(function (key) { return store.getFieldValue(incoming, key) !== void 0; })) {\n        return;\n    }\n    var parentType = store.getFieldValue(existingRef, \"__typename\") ||\n        store.getFieldValue(incomingObj, \"__typename\");\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n    // Avoid warning more than once for the same type and field name.\n    if (warnings.has(typeDotName))\n        return;\n    warnings.add(typeDotName);\n    var childTypenames = [];\n    // Arrays do not have __typename fields, and always need a custom merge\n    // function, even if their elements are normalized entities.\n    if (!isArray(existing) && !isArray(incoming)) {\n        [existing, incoming].forEach(function (child) {\n            var typename = store.getFieldValue(child, \"__typename\");\n            if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n                childTypenames.push(typename);\n            }\n        });\n    }\n    globalThis.__DEV__ !== false && invariant.warn(14, fieldName, parentType, childTypenames.length ?\n        \"either ensure all objects of type \" +\n            childTypenames.join(\" and \") +\n            \" have an ID or a custom merge function, or \"\n        : \"\", typeDotName, existing, incoming);\n}\n", "import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\n// Make builtins like Map and Set safe to use with non-extensible objects.\nimport \"./fixPolyfills.js\";\nimport { wrap } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { ApolloCache } from \"../core/cache.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { addTypenameToDocument, isReference, DocumentTransform, } from \"../../utilities/index.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { makeVar, forgetCache, recallCache } from \"./reactiveVars.js\";\nimport { Policies } from \"./policies.js\";\nimport { hasOwn, normalizeConfig, shouldCanonizeResults } from \"./helpers.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nvar InMemoryCache = /** @class */ (function (_super) {\n    __extends(InMemoryCache, _super);\n    function InMemoryCache(config) {\n        if (config === void 0) { config = {}; }\n        var _this = _super.call(this) || this;\n        _this.watches = new Set();\n        _this.addTypenameTransform = new DocumentTransform(addTypenameToDocument);\n        // Override the default value, since InMemoryCache result objects are frozen\n        // in development and expected to remain logically immutable in production.\n        _this.assumeImmutableResults = true;\n        _this.makeVar = makeVar;\n        _this.txCount = 0;\n        _this.config = normalizeConfig(config);\n        _this.addTypename = !!_this.config.addTypename;\n        _this.policies = new Policies({\n            cache: _this,\n            dataIdFromObject: _this.config.dataIdFromObject,\n            possibleTypes: _this.config.possibleTypes,\n            typePolicies: _this.config.typePolicies,\n        });\n        _this.init();\n        return _this;\n    }\n    InMemoryCache.prototype.init = function () {\n        // Passing { resultCaching: false } in the InMemoryCache constructor options\n        // will completely disable dependency tracking, which will improve memory\n        // usage but worsen the performance of repeated reads.\n        var rootStore = (this.data = new EntityStore.Root({\n            policies: this.policies,\n            resultCaching: this.config.resultCaching,\n        }));\n        // When no optimistic writes are currently active, cache.optimisticData ===\n        // cache.data, so there are no additional layers on top of the actual data.\n        // When an optimistic update happens, this.optimisticData will become a\n        // linked list of EntityStore Layer objects that terminates with the\n        // original this.data cache object.\n        this.optimisticData = rootStore.stump;\n        this.resetResultCache();\n    };\n    InMemoryCache.prototype.resetResultCache = function (resetResultIdentities) {\n        var _this = this;\n        var previousReader = this.storeReader;\n        var fragments = this.config.fragments;\n        // The StoreWriter is mostly stateless and so doesn't really need to be\n        // reset, but it does need to have its writer.storeReader reference updated,\n        // so it's simpler to update this.storeWriter as well.\n        this.storeWriter = new StoreWriter(this, (this.storeReader = new StoreReader({\n            cache: this,\n            addTypename: this.addTypename,\n            resultCacheMaxSize: this.config.resultCacheMaxSize,\n            canonizeResults: shouldCanonizeResults(this.config),\n            canon: resetResultIdentities ? void 0 : (previousReader && previousReader.canon),\n            fragments: fragments,\n        })), fragments);\n        this.maybeBroadcastWatch = wrap(function (c, options) {\n            return _this.broadcastWatch(c, options);\n        }, {\n            max: this.config.resultCacheMaxSize,\n            makeCacheKey: function (c) {\n                // Return a cache key (thus enabling result caching) only if we're\n                // currently using a data store that can track cache dependencies.\n                var store = c.optimistic ? _this.optimisticData : _this.data;\n                if (supportsResultCaching(store)) {\n                    var optimistic = c.optimistic, id = c.id, variables = c.variables;\n                    return store.makeCacheKey(c.query, \n                    // Different watches can have the same query, optimistic\n                    // status, rootId, and variables, but if their callbacks are\n                    // different, the (identical) result needs to be delivered to\n                    // each distinct callback. The easiest way to achieve that\n                    // separation is to include c.callback in the cache key for\n                    // maybeBroadcastWatch calls. See issue #5733.\n                    c.callback, canonicalStringify({ optimistic: optimistic, id: id, variables: variables }));\n                }\n            },\n        });\n        // Since we have thrown away all the cached functions that depend on the\n        // CacheGroup dependencies maintained by EntityStore, we should also reset\n        // all CacheGroup dependency information.\n        new Set([this.data.group, this.optimisticData.group]).forEach(function (group) {\n            return group.resetCaching();\n        });\n    };\n    InMemoryCache.prototype.restore = function (data) {\n        this.init();\n        // Since calling this.init() discards/replaces the entire StoreReader, along\n        // with the result caches it maintains, this.data.replace(data) won't have\n        // to bother deleting the old data.\n        if (data)\n            this.data.replace(data);\n        return this;\n    };\n    InMemoryCache.prototype.extract = function (optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return (optimistic ? this.optimisticData : this.data).extract();\n    };\n    InMemoryCache.prototype.read = function (options) {\n        var \n        // Since read returns data or null, without any additional metadata\n        // about whether/where there might have been missing fields, the\n        // default behavior cannot be returnPartialData = true (like it is\n        // for the diff method), since defaulting to true would violate the\n        // integrity of the T in the return type. However, partial data may\n        // be useful in some cases, so returnPartialData:true may be\n        // specified explicitly.\n        _a = options.returnPartialData, \n        // Since read returns data or null, without any additional metadata\n        // about whether/where there might have been missing fields, the\n        // default behavior cannot be returnPartialData = true (like it is\n        // for the diff method), since defaulting to true would violate the\n        // integrity of the T in the return type. However, partial data may\n        // be useful in some cases, so returnPartialData:true may be\n        // specified explicitly.\n        returnPartialData = _a === void 0 ? false : _a;\n        try {\n            return (this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData: returnPartialData })).result || null);\n        }\n        catch (e) {\n            if (e instanceof MissingFieldError) {\n                // Swallow MissingFieldError and return null, so callers do not need to\n                // worry about catching \"normal\" exceptions resulting from incomplete\n                // cache data. Unexpected errors will be re-thrown. If you need more\n                // information about which fields were missing, use cache.diff instead,\n                // and examine diffResult.missing.\n                return null;\n            }\n            throw e;\n        }\n    };\n    InMemoryCache.prototype.write = function (options) {\n        try {\n            ++this.txCount;\n            return this.storeWriter.writeToStore(this.data, options);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.modify = function (options) {\n        if (hasOwn.call(options, \"id\") && !options.id) {\n            // To my knowledge, TypeScript does not currently provide a way to\n            // enforce that an optional property?:type must *not* be undefined\n            // when present. That ability would be useful here, because we want\n            // options.id to default to ROOT_QUERY only when no options.id was\n            // provided. If the caller attempts to pass options.id with a\n            // falsy/undefined value (perhaps because cache.identify failed), we\n            // should not assume the goal was to modify the ROOT_QUERY object.\n            // We could throw, but it seems natural to return false to indicate\n            // that nothing was modified.\n            return false;\n        }\n        var store = ((options.optimistic) // Defaults to false.\n        ) ?\n            this.optimisticData\n            : this.data;\n        try {\n            ++this.txCount;\n            return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.diff = function (options) {\n        return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || \"ROOT_QUERY\", config: this.config }));\n    };\n    InMemoryCache.prototype.watch = function (watch) {\n        var _this = this;\n        if (!this.watches.size) {\n            // In case we previously called forgetCache(this) because\n            // this.watches became empty (see below), reattach this cache to any\n            // reactive variables on which it previously depended. It might seem\n            // paradoxical that we're able to recall something we supposedly\n            // forgot, but the point of calling forgetCache(this) is to silence\n            // useless broadcasts while this.watches is empty, and to allow the\n            // cache to be garbage collected. If, however, we manage to call\n            // recallCache(this) here, this cache object must not have been\n            // garbage collected yet, and should resume receiving updates from\n            // reactive variables, now that it has a watcher to notify.\n            recallCache(this);\n        }\n        this.watches.add(watch);\n        if (watch.immediate) {\n            this.maybeBroadcastWatch(watch);\n        }\n        return function () {\n            // Once we remove the last watch from this.watches, cache.broadcastWatches\n            // no longer does anything, so we preemptively tell the reactive variable\n            // system to exclude this cache from future broadcasts.\n            if (_this.watches.delete(watch) && !_this.watches.size) {\n                forgetCache(_this);\n            }\n            // Remove this watch from the LRU cache managed by the\n            // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n            // leaks involving the closure of watch.callback.\n            _this.maybeBroadcastWatch.forget(watch);\n        };\n    };\n    InMemoryCache.prototype.gc = function (options) {\n        canonicalStringify.reset();\n        var ids = this.optimisticData.gc();\n        if (options && !this.txCount) {\n            if (options.resetResultCache) {\n                this.resetResultCache(options.resetResultIdentities);\n            }\n            else if (options.resetResultIdentities) {\n                this.storeReader.resetCanon();\n            }\n        }\n        return ids;\n    };\n    // Call this method to ensure the given root ID remains in the cache after\n    // garbage collection, along with its transitive child entities. Note that\n    // the cache automatically retains all directly written entities. By default,\n    // the retainment persists after optimistic updates are removed. Pass true\n    // for the optimistic argument if you would prefer for the retainment to be\n    // discarded when the top-most optimistic layer is removed. Returns the\n    // resulting (non-negative) retainment count.\n    InMemoryCache.prototype.retain = function (rootId, optimistic) {\n        return (optimistic ? this.optimisticData : this.data).retain(rootId);\n    };\n    // Call this method to undo the effect of the retain method, above. Once the\n    // retainment count falls to zero, the given ID will no longer be preserved\n    // during garbage collection, though it may still be preserved by other safe\n    // entities that refer to it. Returns the resulting (non-negative) retainment\n    // count, in case that's useful.\n    InMemoryCache.prototype.release = function (rootId, optimistic) {\n        return (optimistic ? this.optimisticData : this.data).release(rootId);\n    };\n    // Returns the canonical ID for a given StoreObject, obeying typePolicies\n    // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n    // the object must contain a __typename and any primary key fields required\n    // to identify entities of that type. If you pass a query result object, be\n    // sure that none of the primary key fields have been renamed by aliasing.\n    // If you pass a Reference object, its __ref ID string will be returned.\n    InMemoryCache.prototype.identify = function (object) {\n        if (isReference(object))\n            return object.__ref;\n        try {\n            return this.policies.identify(object)[0];\n        }\n        catch (e) {\n            globalThis.__DEV__ !== false && invariant.warn(e);\n        }\n    };\n    InMemoryCache.prototype.evict = function (options) {\n        if (!options.id) {\n            if (hasOwn.call(options, \"id\")) {\n                // See comment in modify method about why we return false when\n                // options.id exists but is falsy/undefined.\n                return false;\n            }\n            options = __assign(__assign({}, options), { id: \"ROOT_QUERY\" });\n        }\n        try {\n            // It's unlikely that the eviction will end up invoking any other\n            // cache update operations while it's running, but {in,de}crementing\n            // this.txCount still seems like a good idea, for uniformity with\n            // the other update methods.\n            ++this.txCount;\n            // Pass this.data as a limit on the depth of the eviction, so evictions\n            // during optimistic updates (when this.data is temporarily set equal to\n            // this.optimisticData) do not escape their optimistic Layer.\n            return this.optimisticData.evict(options, this.data);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.reset = function (options) {\n        var _this = this;\n        this.init();\n        canonicalStringify.reset();\n        if (options && options.discardWatches) {\n            // Similar to what happens in the unsubscribe function returned by\n            // cache.watch, applied to all current watches.\n            this.watches.forEach(function (watch) { return _this.maybeBroadcastWatch.forget(watch); });\n            this.watches.clear();\n            forgetCache(this);\n        }\n        else {\n            // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n            // this.broadcastWatches() triggers a broadcast to every current watcher\n            // (letting them know their data is now missing). This default behavior is\n            // convenient because it means the watches do not have to be manually\n            // reestablished after resetting the cache. To prevent this broadcast and\n            // cancel all watches, pass true for options.discardWatches.\n            this.broadcastWatches();\n        }\n        return Promise.resolve();\n    };\n    InMemoryCache.prototype.removeOptimistic = function (idToRemove) {\n        var newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n        if (newOptimisticData !== this.optimisticData) {\n            this.optimisticData = newOptimisticData;\n            this.broadcastWatches();\n        }\n    };\n    InMemoryCache.prototype.batch = function (options) {\n        var _this = this;\n        var update = options.update, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;\n        var updateResult;\n        var perform = function (layer) {\n            var _a = _this, data = _a.data, optimisticData = _a.optimisticData;\n            ++_this.txCount;\n            if (layer) {\n                _this.data = _this.optimisticData = layer;\n            }\n            try {\n                return (updateResult = update(_this));\n            }\n            finally {\n                --_this.txCount;\n                _this.data = data;\n                _this.optimisticData = optimisticData;\n            }\n        };\n        var alreadyDirty = new Set();\n        if (onWatchUpdated && !this.txCount) {\n            // If an options.onWatchUpdated callback is provided, we want to call it\n            // with only the Cache.WatchOptions objects affected by options.update,\n            // but there might be dirty watchers already waiting to be broadcast that\n            // have nothing to do with the update. To prevent including those watchers\n            // in the post-update broadcast, we perform this initial broadcast to\n            // collect the dirty watchers, so we can re-dirty them later, after the\n            // post-update broadcast, allowing them to receive their pending\n            // broadcasts the next time broadcastWatches is called, just as they would\n            // if we never called cache.batch.\n            this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function (watch) {\n                    alreadyDirty.add(watch);\n                    return false;\n                } }));\n        }\n        if (typeof optimistic === \"string\") {\n            // Note that there can be multiple layers with the same optimistic ID.\n            // When removeOptimistic(id) is called for that id, all matching layers\n            // will be removed, and the remaining layers will be reapplied.\n            this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n        }\n        else if (optimistic === false) {\n            // Ensure both this.data and this.optimisticData refer to the root\n            // (non-optimistic) layer of the cache during the update. Note that\n            // this.data could be a Layer if we are currently executing an optimistic\n            // update function, but otherwise will always be an EntityStore.Root\n            // instance.\n            perform(this.data);\n        }\n        else {\n            // Otherwise, leave this.data and this.optimisticData unchanged and run\n            // the update with broadcast batching.\n            perform();\n        }\n        if (typeof removeOptimistic === \"string\") {\n            this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n        }\n        // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n        // takes the else branch and calls this.broadcastWatches(options), which\n        // does nothing when this.txCount > 0.\n        if (onWatchUpdated && alreadyDirty.size) {\n            this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function (watch, diff) {\n                    var result = onWatchUpdated.call(this, watch, diff);\n                    if (result !== false) {\n                        // Since onWatchUpdated did not return false, this diff is\n                        // about to be broadcast to watch.callback, so we don't need\n                        // to re-dirty it with the other alreadyDirty watches below.\n                        alreadyDirty.delete(watch);\n                    }\n                    return result;\n                } }));\n            // Silently re-dirty any watches that were already dirty before the update\n            // was performed, and were not broadcast just now.\n            if (alreadyDirty.size) {\n                alreadyDirty.forEach(function (watch) { return _this.maybeBroadcastWatch.dirty(watch); });\n            }\n        }\n        else {\n            // If alreadyDirty is empty or we don't have an onWatchUpdated\n            // function, we don't need to go to the trouble of wrapping\n            // options.onWatchUpdated.\n            this.broadcastWatches(options);\n        }\n        return updateResult;\n    };\n    InMemoryCache.prototype.performTransaction = function (update, optimisticId) {\n        return this.batch({\n            update: update,\n            optimistic: optimisticId || optimisticId !== null,\n        });\n    };\n    InMemoryCache.prototype.transformDocument = function (document) {\n        return this.addTypenameToDocument(this.addFragmentsToDocument(document));\n    };\n    InMemoryCache.prototype.broadcastWatches = function (options) {\n        var _this = this;\n        if (!this.txCount) {\n            this.watches.forEach(function (c) { return _this.maybeBroadcastWatch(c, options); });\n        }\n    };\n    InMemoryCache.prototype.addFragmentsToDocument = function (document) {\n        var fragments = this.config.fragments;\n        return fragments ? fragments.transform(document) : document;\n    };\n    InMemoryCache.prototype.addTypenameToDocument = function (document) {\n        if (this.addTypename) {\n            return this.addTypenameTransform.transformDocument(document);\n        }\n        return document;\n    };\n    // This method is wrapped by maybeBroadcastWatch, which is called by\n    // broadcastWatches, so that we compute and broadcast results only when\n    // the data that would be broadcast might have changed. It would be\n    // simpler to check for changes after recomputing a result but before\n    // broadcasting it, but this wrapping approach allows us to skip both\n    // the recomputation and the broadcast, in most cases.\n    InMemoryCache.prototype.broadcastWatch = function (c, options) {\n        var lastDiff = c.lastDiff;\n        // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n        // currently requires no additional properties, so we can use c (a\n        // WatchOptions object) as DiffOptions, without having to allocate a new\n        // object, and without having to enumerate the relevant properties (query,\n        // variables, etc.) explicitly. There will be some additional properties\n        // (lastDiff, callback, etc.), but cache.diff ignores them.\n        var diff = this.diff(c);\n        if (options) {\n            if (c.optimistic && typeof options.optimistic === \"string\") {\n                diff.fromOptimisticTransaction = true;\n            }\n            if (options.onWatchUpdated &&\n                options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {\n                // Returning false from the onWatchUpdated callback will prevent\n                // calling c.callback(diff) for this watcher.\n                return;\n            }\n        }\n        if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n            c.callback((c.lastDiff = diff), lastDiff);\n        }\n    };\n    return InMemoryCache;\n}(ApolloCache));\nexport { InMemoryCache };\n", "import { __assign, __spreadArray } from \"tslib\";\nimport { visit } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { getFragmentDefinitions } from \"../../utilities/index.js\";\n// As long as createFragmentRegistry is not imported or used, the\n// FragmentRegistry example implementation provided below should not be bundled\n// (by tree-shaking bundlers like Rollup), because the implementation of\n// InMemoryCache refers only to the TypeScript interface FragmentRegistryAPI,\n// never the concrete implementation FragmentRegistry (which is deliberately not\n// exported from this module).\nexport function createFragmentRegistry() {\n    var fragments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fragments[_i] = arguments[_i];\n    }\n    return new (FragmentRegistry.bind.apply(FragmentRegistry, __spreadArray([void 0], fragments, false)))();\n}\nvar FragmentRegistry = /** @class */ (function () {\n    // Call `createFragmentRegistry` instead of invoking the\n    // FragmentRegistry constructor directly. This reserves the constructor for\n    // future configuration of the FragmentRegistry.\n    function FragmentRegistry() {\n        var fragments = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            fragments[_i] = arguments[_i];\n        }\n        this.registry = Object.create(null);\n        this.resetCaches();\n        if (fragments.length) {\n            this.register.apply(this, fragments);\n        }\n    }\n    FragmentRegistry.prototype.register = function () {\n        var _this = this;\n        var fragments = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            fragments[_i] = arguments[_i];\n        }\n        var definitions = new Map();\n        fragments.forEach(function (doc) {\n            getFragmentDefinitions(doc).forEach(function (node) {\n                definitions.set(node.name.value, node);\n            });\n        });\n        definitions.forEach(function (node, name) {\n            if (node !== _this.registry[name]) {\n                _this.registry[name] = node;\n                _this.invalidate(name);\n            }\n        });\n        return this;\n    };\n    // Overridden in the resetCaches method below.\n    FragmentRegistry.prototype.invalidate = function (name) { };\n    FragmentRegistry.prototype.resetCaches = function () {\n        this.invalidate = (this.lookup = this.cacheUnaryMethod(this.lookup)).dirty; // This dirty function is bound to the wrapped lookup method.\n        this.transform = this.cacheUnaryMethod(this.transform);\n        this.findFragmentSpreads = this.cacheUnaryMethod(this.findFragmentSpreads);\n    };\n    FragmentRegistry.prototype.cacheUnaryMethod = function (originalMethod) {\n        return wrap(originalMethod.bind(this), {\n            makeCacheKey: function (arg) { return arg; },\n        });\n    };\n    FragmentRegistry.prototype.lookup = function (fragmentName) {\n        return this.registry[fragmentName] || null;\n    };\n    FragmentRegistry.prototype.transform = function (document) {\n        var _this = this;\n        var defined = new Map();\n        getFragmentDefinitions(document).forEach(function (def) {\n            defined.set(def.name.value, def);\n        });\n        var unbound = new Set();\n        var enqueue = function (spreadName) {\n            if (!defined.has(spreadName)) {\n                unbound.add(spreadName);\n            }\n        };\n        var enqueueChildSpreads = function (node) {\n            return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue);\n        };\n        enqueueChildSpreads(document);\n        var missing = [];\n        var map = Object.create(null);\n        // This Set forEach loop can be extended during iteration by adding\n        // additional strings to the unbound set.\n        unbound.forEach(function (fragmentName) {\n            var knownFragmentDef = defined.get(fragmentName);\n            if (knownFragmentDef) {\n                enqueueChildSpreads((map[fragmentName] = knownFragmentDef));\n            }\n            else {\n                missing.push(fragmentName);\n                var def = _this.lookup(fragmentName);\n                if (def) {\n                    enqueueChildSpreads((map[fragmentName] = def));\n                }\n            }\n        });\n        if (missing.length) {\n            var defsToAppend_1 = [];\n            missing.forEach(function (name) {\n                var def = map[name];\n                if (def) {\n                    defsToAppend_1.push(def);\n                }\n            });\n            if (defsToAppend_1.length) {\n                document = __assign(__assign({}, document), { definitions: document.definitions.concat(defsToAppend_1) });\n            }\n        }\n        return document;\n    };\n    FragmentRegistry.prototype.findFragmentSpreads = function (root) {\n        var spreads = Object.create(null);\n        visit(root, {\n            FragmentSpread: function (node) {\n                spreads[node.name.value] = node;\n            },\n        });\n        return spreads;\n    };\n    return FragmentRegistry;\n}());\n", "/**\n * The current status of a query’s execution in our system.\n */\nexport var NetworkStatus;\n(function (NetworkStatus) {\n    /**\n     * The query has never been run before and the query is now currently running. A query will still\n     * have this network status even if a partial data result was returned from the cache, but a\n     * query was dispatched anyway.\n     */\n    NetworkStatus[NetworkStatus[\"loading\"] = 1] = \"loading\";\n    /**\n     * If `setVariables` was called and a query was fired because of that then the network status\n     * will be `setVariables` until the result of that query comes back.\n     */\n    NetworkStatus[NetworkStatus[\"setVariables\"] = 2] = \"setVariables\";\n    /**\n     * Indicates that `fetchMore` was called on this query and that the query created is currently in\n     * flight.\n     */\n    NetworkStatus[NetworkStatus[\"fetchMore\"] = 3] = \"fetchMore\";\n    /**\n     * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n     * and the refetch request is currently in flight.\n     */\n    NetworkStatus[NetworkStatus[\"refetch\"] = 4] = \"refetch\";\n    /**\n     * Indicates that a polling query is currently in flight. So for example if you are polling a\n     * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n     * a poll request has been sent but not resolved.\n     */\n    NetworkStatus[NetworkStatus[\"poll\"] = 6] = \"poll\";\n    /**\n     * No request is in flight for this query, and no errors happened. Everything is OK.\n     */\n    NetworkStatus[NetworkStatus[\"ready\"] = 7] = \"ready\";\n    /**\n     * No request is in flight for this query, but one or more errors were detected.\n     */\n    NetworkStatus[NetworkStatus[\"error\"] = 8] = \"error\";\n})(NetworkStatus || (NetworkStatus = {}));\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(networkStatus) {\n    return networkStatus ? networkStatus < 7 : false;\n}\n/**\n * Returns true if the network request is in ready or error state according to a given network\n * status.\n */\nexport function isNetworkRequestSettled(networkStatus) {\n    return networkStatus === 7 || networkStatus === 8;\n}\n", "import { __rest } from \"tslib\";\nimport equal from \"@wry/equality\";\nimport { createFragmentMap, getFragmentDefinitions, getFragmentFromSelection, getMainDefinition, isField, resultKeyNameFromField, shouldInclude, } from \"../utilities/index.js\";\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nexport function equalByQuery(query, _a, _b, variables) {\n    var aData = _a.data, aRest = __rest(_a, [\"data\"]);\n    var bData = _b.data, bRest = __rest(_b, [\"data\"]);\n    return (equal(aRest, bRest) &&\n        equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n            fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n            variables: variables,\n        }));\n}\nfunction equalBySelectionSet(selectionSet, aResult, bResult, context) {\n    if (aResult === bResult) {\n        return true;\n    }\n    var seenSelections = new Set();\n    // Returning true from this Array.prototype.every callback function skips the\n    // current field/subtree. Returning false aborts the entire traversal\n    // immediately, causing equalBySelectionSet to return false.\n    return selectionSet.selections.every(function (selection) {\n        // Avoid re-processing the same selection at the same level of recursion, in\n        // case the same field gets included via multiple indirect fragment spreads.\n        if (seenSelections.has(selection))\n            return true;\n        seenSelections.add(selection);\n        // Ignore @skip(if: true) and @include(if: false) fields.\n        if (!shouldInclude(selection, context.variables))\n            return true;\n        // If the field or (named) fragment spread has a @nonreactive directive on\n        // it, we don't care if it's different, so we pretend it's the same.\n        if (selectionHasNonreactiveDirective(selection))\n            return true;\n        if (isField(selection)) {\n            var resultKey = resultKeyNameFromField(selection);\n            var aResultChild = aResult && aResult[resultKey];\n            var bResultChild = bResult && bResult[resultKey];\n            var childSelectionSet = selection.selectionSet;\n            if (!childSelectionSet) {\n                // These are scalar values, so we can compare them with deep equal\n                // without redoing the main recursive work.\n                return equal(aResultChild, bResultChild);\n            }\n            var aChildIsArray = Array.isArray(aResultChild);\n            var bChildIsArray = Array.isArray(bResultChild);\n            if (aChildIsArray !== bChildIsArray)\n                return false;\n            if (aChildIsArray && bChildIsArray) {\n                var length_1 = aResultChild.length;\n                if (bResultChild.length !== length_1) {\n                    return false;\n                }\n                for (var i = 0; i < length_1; ++i) {\n                    if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);\n        }\n        else {\n            var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n            if (fragment) {\n                // The fragment might === selection if it's an inline fragment, but\n                // could be !== if it's a named fragment ...spread.\n                if (selectionHasNonreactiveDirective(fragment))\n                    return true;\n                return equalBySelectionSet(fragment.selectionSet, \n                // Notice that we reuse the same aResult and bResult values here,\n                // since the fragment ...spread does not specify a field name, but\n                // consists of multiple fields (within the fragment's selection set)\n                // that should be applied to the current result value(s).\n                aResult, bResult, context);\n            }\n        }\n    });\n}\nfunction selectionHasNonreactiveDirective(selection) {\n    return (!!selection.directives && selection.directives.some(directiveIsNonreactive));\n}\nfunction directiveIsNonreactive(dir) {\n    return dir.name.value === \"nonreactive\";\n}\n", "import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { cloneDeep, compact, getOperationDefinition, Observable, iterateObserversSafely, fixObservableSubclass, getQueryDefinition, } from \"../utilities/index.js\";\nimport { equalByQuery } from \"./equalByQuery.js\";\nvar assign = Object.assign, hasOwnProperty = Object.hasOwnProperty;\nvar ObservableQuery = /** @class */ (function (_super) {\n    __extends(ObservableQuery, _super);\n    function ObservableQuery(_a) {\n        var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;\n        var _this = _super.call(this, function (observer) {\n            // Zen Observable has its own error function, so in order to log correctly\n            // we need to provide a custom error callback.\n            try {\n                var subObserver = observer._subscription._observer;\n                if (subObserver && !subObserver.error) {\n                    subObserver.error = defaultSubscriptionObserverErrorCallback;\n                }\n            }\n            catch (_a) { }\n            var first = !_this.observers.size;\n            _this.observers.add(observer);\n            // Deliver most recent error or result.\n            var last = _this.last;\n            if (last && last.error) {\n                observer.error && observer.error(last.error);\n            }\n            else if (last && last.result) {\n                observer.next && observer.next(last.result);\n            }\n            // Initiate observation of this query if it hasn't been reported to\n            // the QueryManager yet.\n            if (first) {\n                // Blindly catching here prevents unhandled promise rejections,\n                // and is safe because the ObservableQuery handles this error with\n                // this.observer.error, so we're not just swallowing the error by\n                // ignoring it here.\n                _this.reobserve().catch(function () { });\n            }\n            return function () {\n                if (_this.observers.delete(observer) && !_this.observers.size) {\n                    _this.tearDownQuery();\n                }\n            };\n        }) || this;\n        _this.observers = new Set();\n        _this.subscriptions = new Set();\n        // related classes\n        _this.queryInfo = queryInfo;\n        _this.queryManager = queryManager;\n        // active state\n        _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);\n        _this.isTornDown = false;\n        var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? \"cache-first\" : _d;\n        var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, \n        // Make sure we don't store \"standby\" as the initialFetchPolicy.\n        _f = options.initialFetchPolicy, \n        // Make sure we don't store \"standby\" as the initialFetchPolicy.\n        initialFetchPolicy = _f === void 0 ? fetchPolicy === \"standby\" ? defaultFetchPolicy : (fetchPolicy) : _f;\n        _this.options = __assign(__assign({}, options), { \n            // Remember the initial options.fetchPolicy so we can revert back to this\n            // policy when variables change. This information can also be specified\n            // (or overridden) by providing options.initialFetchPolicy explicitly.\n            initialFetchPolicy: initialFetchPolicy, \n            // This ensures this.options.fetchPolicy always has a string value, in\n            // case options.fetchPolicy was not provided.\n            fetchPolicy: fetchPolicy });\n        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n        var opDef = getOperationDefinition(_this.query);\n        _this.queryName = opDef && opDef.name && opDef.name.value;\n        return _this;\n    }\n    Object.defineProperty(ObservableQuery.prototype, \"query\", {\n        // The `query` computed property will always reflect the document transformed\n        // by the last run query. `this.options.query` will always reflect the raw\n        // untransformed query to ensure document transforms with runtime conditionals\n        // are run on the original document.\n        get: function () {\n            return this.lastQuery || this.options.query;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ObservableQuery.prototype, \"variables\", {\n        // Computed shorthand for this.options.variables, preserved for\n        // backwards compatibility.\n        get: function () {\n            return this.options.variables;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ObservableQuery.prototype.result = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            // TODO: this code doesn’t actually make sense insofar as the observer\n            // will never exist in this.observers due how zen-observable wraps observables.\n            // https://github.com/zenparsing/zen-observable/blob/master/src/Observable.js#L169\n            var observer = {\n                next: function (result) {\n                    resolve(result);\n                    // Stop the query within the QueryManager if we can before\n                    // this function returns.\n                    //\n                    // We do this in order to prevent observers piling up within\n                    // the QueryManager. Notice that we only fully unsubscribe\n                    // from the subscription in a setTimeout(..., 0)  call. This call can\n                    // actually be handled by the browser at a much later time. If queries\n                    // are fired in the meantime, observers that should have been removed\n                    // from the QueryManager will continue to fire, causing an unnecessary\n                    // performance hit.\n                    _this.observers.delete(observer);\n                    if (!_this.observers.size) {\n                        _this.queryManager.removeQuery(_this.queryId);\n                    }\n                    setTimeout(function () {\n                        subscription.unsubscribe();\n                    }, 0);\n                },\n                error: reject,\n            };\n            var subscription = _this.subscribe(observer);\n        });\n    };\n    ObservableQuery.prototype.getCurrentResult = function (saveAsLastResult) {\n        if (saveAsLastResult === void 0) { saveAsLastResult = true; }\n        // Use the last result as long as the variables match this.variables.\n        var lastResult = this.getLastResult(true);\n        var networkStatus = this.queryInfo.networkStatus ||\n            (lastResult && lastResult.networkStatus) ||\n            NetworkStatus.ready;\n        var result = __assign(__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus });\n        var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a;\n        if (\n        // These fetch policies should never deliver data from the cache, unless\n        // redelivering a previously delivered result.\n        skipCacheDataFor(fetchPolicy) ||\n            // If this.options.query has @client(always: true) fields, we cannot\n            // trust diff.result, since it was read from the cache without running\n            // local resolvers (and it's too late to run resolvers now, since we must\n            // return a result synchronously).\n            this.queryManager.getDocumentInfo(this.query).hasForcedResolvers) {\n            // Fall through.\n        }\n        else if (this.waitForOwnResult) {\n            // This would usually be a part of `QueryInfo.getDiff()`.\n            // which we skip in the waitForOwnResult case since we are not\n            // interested in the diff.\n            this.queryInfo[\"updateWatch\"]();\n        }\n        else {\n            var diff = this.queryInfo.getDiff();\n            if (diff.complete || this.options.returnPartialData) {\n                result.data = diff.result;\n            }\n            if (equal(result.data, {})) {\n                result.data = void 0;\n            }\n            if (diff.complete) {\n                // Similar to setting result.partial to false, but taking advantage of the\n                // falsiness of missing fields.\n                delete result.partial;\n                // If the diff is complete, and we're using a FetchPolicy that\n                // terminates after a complete cache read, we can assume the next result\n                // we receive will have NetworkStatus.ready and !loading.\n                if (diff.complete &&\n                    result.networkStatus === NetworkStatus.loading &&\n                    (fetchPolicy === \"cache-first\" || fetchPolicy === \"cache-only\")) {\n                    result.networkStatus = NetworkStatus.ready;\n                    result.loading = false;\n                }\n            }\n            else {\n                result.partial = true;\n            }\n            if (globalThis.__DEV__ !== false &&\n                !diff.complete &&\n                !this.options.partialRefetch &&\n                !result.loading &&\n                !result.data &&\n                !result.error) {\n                logMissingFieldErrors(diff.missing);\n            }\n        }\n        if (saveAsLastResult) {\n            this.updateLastResult(result);\n        }\n        return result;\n    };\n    // Compares newResult to the snapshot we took of this.lastResult when it was\n    // first received.\n    ObservableQuery.prototype.isDifferentFromLastResult = function (newResult, variables) {\n        if (!this.last) {\n            return true;\n        }\n        var resultIsDifferent = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ?\n            !equalByQuery(this.query, this.last.result, newResult, this.variables)\n            : !equal(this.last.result, newResult);\n        return (resultIsDifferent || (variables && !equal(this.last.variables, variables)));\n    };\n    ObservableQuery.prototype.getLast = function (key, variablesMustMatch) {\n        var last = this.last;\n        if (last &&\n            last[key] &&\n            (!variablesMustMatch || equal(last.variables, this.variables))) {\n            return last[key];\n        }\n    };\n    ObservableQuery.prototype.getLastResult = function (variablesMustMatch) {\n        return this.getLast(\"result\", variablesMustMatch);\n    };\n    ObservableQuery.prototype.getLastError = function (variablesMustMatch) {\n        return this.getLast(\"error\", variablesMustMatch);\n    };\n    ObservableQuery.prototype.resetLastResults = function () {\n        delete this.last;\n        this.isTornDown = false;\n    };\n    ObservableQuery.prototype.resetQueryStoreErrors = function () {\n        this.queryManager.resetErrors(this.queryId);\n    };\n    /**\n     * Update the variables of this observable query, and fetch the new results.\n     * This method should be preferred over `setVariables` in most use cases.\n     *\n     * @param variables - The new set of variables. If there are missing variables,\n     * the previous values of those variables will be used.\n     */\n    ObservableQuery.prototype.refetch = function (variables) {\n        var _a;\n        var reobserveOptions = {\n            // Always disable polling for refetches.\n            pollInterval: 0,\n        };\n        // Unless the provided fetchPolicy always consults the network\n        // (no-cache, network-only, or cache-and-network), override it with\n        // network-only to force the refetch for this fetchQuery call.\n        var fetchPolicy = this.options.fetchPolicy;\n        if (fetchPolicy === \"cache-and-network\") {\n            reobserveOptions.fetchPolicy = fetchPolicy;\n        }\n        else if (fetchPolicy === \"no-cache\") {\n            reobserveOptions.fetchPolicy = \"no-cache\";\n        }\n        else {\n            reobserveOptions.fetchPolicy = \"network-only\";\n        }\n        if (globalThis.__DEV__ !== false && variables && hasOwnProperty.call(variables, \"variables\")) {\n            var queryDef = getQueryDefinition(this.query);\n            var vars = queryDef.variableDefinitions;\n            if (!vars || !vars.some(function (v) { return v.variable.name.value === \"variables\"; })) {\n                globalThis.__DEV__ !== false && invariant.warn(\n                    20,\n                    variables,\n                    ((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || queryDef\n                );\n            }\n        }\n        if (variables && !equal(this.options.variables, variables)) {\n            // Update the existing options with new variables\n            reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);\n        }\n        this.queryInfo.resetLastWrite();\n        return this.reobserve(reobserveOptions, NetworkStatus.refetch);\n    };\n    ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {\n        var _this = this;\n        var combinedOptions = __assign(__assign({}, (fetchMoreOptions.query ? fetchMoreOptions : (__assign(__assign(__assign(__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables) })))), { \n            // The fetchMore request goes immediately to the network and does\n            // not automatically write its result to the cache (hence no-cache\n            // instead of network-only), because we allow the caller of\n            // fetchMore to provide an updateQuery callback that determines how\n            // the data gets written to the cache.\n            fetchPolicy: \"no-cache\" });\n        combinedOptions.query = this.transformDocument(combinedOptions.query);\n        var qid = this.queryManager.generateQueryId();\n        // If a temporary query is passed to `fetchMore`, we don't want to store\n        // it as the last query result since it may be an optimized query for\n        // pagination. We will however run the transforms on the original document\n        // as well as the document passed in `fetchMoreOptions` to ensure the cache\n        // uses the most up-to-date document which may rely on runtime conditionals.\n        this.lastQuery =\n            fetchMoreOptions.query ?\n                this.transformDocument(this.options.query)\n                : combinedOptions.query;\n        // Simulate a loading result for the original query with\n        // result.networkStatus === NetworkStatus.fetchMore.\n        var queryInfo = this.queryInfo;\n        var originalNetworkStatus = queryInfo.networkStatus;\n        queryInfo.networkStatus = NetworkStatus.fetchMore;\n        if (combinedOptions.notifyOnNetworkStatusChange) {\n            this.observe();\n        }\n        var updatedQuerySet = new Set();\n        return this.queryManager\n            .fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore)\n            .then(function (fetchMoreResult) {\n            _this.queryManager.removeQuery(qid);\n            if (queryInfo.networkStatus === NetworkStatus.fetchMore) {\n                queryInfo.networkStatus = originalNetworkStatus;\n            }\n            // Performing this cache update inside a cache.batch transaction ensures\n            // any affected cache.watch watchers are notified at most once about any\n            // updates. Most watchers will be using the QueryInfo class, which\n            // responds to notifications by calling reobserveCacheFirst to deliver\n            // fetchMore cache results back to this ObservableQuery.\n            _this.queryManager.cache.batch({\n                update: function (cache) {\n                    var updateQuery = fetchMoreOptions.updateQuery;\n                    if (updateQuery) {\n                        cache.updateQuery({\n                            query: _this.query,\n                            variables: _this.variables,\n                            returnPartialData: true,\n                            optimistic: false,\n                        }, function (previous) {\n                            return updateQuery(previous, {\n                                fetchMoreResult: fetchMoreResult.data,\n                                variables: combinedOptions.variables,\n                            });\n                        });\n                    }\n                    else {\n                        // If we're using a field policy instead of updateQuery, the only\n                        // thing we need to do is write the new data to the cache using\n                        // combinedOptions.variables (instead of this.variables, which is\n                        // what this.updateQuery uses, because it works by abusing the\n                        // original field value, keyed by the original variables).\n                        cache.writeQuery({\n                            query: combinedOptions.query,\n                            variables: combinedOptions.variables,\n                            data: fetchMoreResult.data,\n                        });\n                    }\n                },\n                onWatchUpdated: function (watch) {\n                    // Record the DocumentNode associated with any watched query whose\n                    // data were updated by the cache writes above.\n                    updatedQuerySet.add(watch.query);\n                },\n            });\n            return fetchMoreResult;\n        })\n            .finally(function () {\n            // In case the cache writes above did not generate a broadcast\n            // notification (which would have been intercepted by onWatchUpdated),\n            // likely because the written data were the same as what was already in\n            // the cache, we still want fetchMore to deliver its final loading:false\n            // result with the unchanged data.\n            if (!updatedQuerySet.has(_this.query)) {\n                reobserveCacheFirst(_this);\n            }\n        });\n    };\n    // XXX the subscription variables are separate from the query variables.\n    // if you want to update subscription variables, right now you have to do that separately,\n    // and you can only do it by stopping the subscription and then subscribing again with new variables.\n    ObservableQuery.prototype.subscribeToMore = function (options) {\n        var _this = this;\n        var subscription = this.queryManager\n            .startGraphQLSubscription({\n            query: options.document,\n            variables: options.variables,\n            context: options.context,\n        })\n            .subscribe({\n            next: function (subscriptionData) {\n                var updateQuery = options.updateQuery;\n                if (updateQuery) {\n                    _this.updateQuery(function (previous, _a) {\n                        var variables = _a.variables;\n                        return updateQuery(previous, {\n                            subscriptionData: subscriptionData,\n                            variables: variables,\n                        });\n                    });\n                }\n            },\n            error: function (err) {\n                if (options.onError) {\n                    options.onError(err);\n                    return;\n                }\n                globalThis.__DEV__ !== false && invariant.error(21, err);\n            },\n        });\n        this.subscriptions.add(subscription);\n        return function () {\n            if (_this.subscriptions.delete(subscription)) {\n                subscription.unsubscribe();\n            }\n        };\n    };\n    ObservableQuery.prototype.setOptions = function (newOptions) {\n        return this.reobserve(newOptions);\n    };\n    ObservableQuery.prototype.silentSetOptions = function (newOptions) {\n        var mergedOptions = compact(this.options, newOptions || {});\n        assign(this.options, mergedOptions);\n    };\n    /**\n     * Update the variables of this observable query, and fetch the new results\n     * if they've changed. Most users should prefer `refetch` instead of\n     * `setVariables` in order to to be properly notified of results even when\n     * they come from the cache.\n     *\n     * Note: the `next` callback will *not* fire if the variables have not changed\n     * or if the result is coming from cache.\n     *\n     * Note: the promise will return the old results immediately if the variables\n     * have not changed.\n     *\n     * Note: the promise will return null immediately if the query is not active\n     * (there are no subscribers).\n     *\n     * @param variables - The new set of variables. If there are missing variables,\n     * the previous values of those variables will be used.\n     */\n    ObservableQuery.prototype.setVariables = function (variables) {\n        if (equal(this.variables, variables)) {\n            // If we have no observers, then we don't actually want to make a network\n            // request. As soon as someone observes the query, the request will kick\n            // off. For now, we just store any changes. (See #1077)\n            return this.observers.size ? this.result() : Promise.resolve();\n        }\n        this.options.variables = variables;\n        // See comment above\n        if (!this.observers.size) {\n            return Promise.resolve();\n        }\n        return this.reobserve({\n            // Reset options.fetchPolicy to its original value.\n            fetchPolicy: this.options.initialFetchPolicy,\n            variables: variables,\n        }, NetworkStatus.setVariables);\n    };\n    ObservableQuery.prototype.updateQuery = function (mapFn) {\n        var queryManager = this.queryManager;\n        var result = queryManager.cache.diff({\n            query: this.options.query,\n            variables: this.variables,\n            returnPartialData: true,\n            optimistic: false,\n        }).result;\n        var newResult = mapFn(result, {\n            variables: this.variables,\n        });\n        if (newResult) {\n            queryManager.cache.writeQuery({\n                query: this.options.query,\n                data: newResult,\n                variables: this.variables,\n            });\n            queryManager.broadcastQueries();\n        }\n    };\n    ObservableQuery.prototype.startPolling = function (pollInterval) {\n        this.options.pollInterval = pollInterval;\n        this.updatePolling();\n    };\n    ObservableQuery.prototype.stopPolling = function () {\n        this.options.pollInterval = 0;\n        this.updatePolling();\n    };\n    // Update options.fetchPolicy according to options.nextFetchPolicy.\n    ObservableQuery.prototype.applyNextFetchPolicy = function (reason, \n    // It's possible to use this method to apply options.nextFetchPolicy to\n    // options.fetchPolicy even if options !== this.options, though that happens\n    // most often when the options are temporary, used for only one request and\n    // then thrown away, so nextFetchPolicy may not end up mattering.\n    options) {\n        if (options.nextFetchPolicy) {\n            var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;\n            if (fetchPolicy === \"standby\") {\n                // Do nothing, leaving options.fetchPolicy unchanged.\n            }\n            else if (typeof options.nextFetchPolicy === \"function\") {\n                // When someone chooses \"cache-and-network\" or \"network-only\" as their\n                // initial FetchPolicy, they often do not want future cache updates to\n                // trigger unconditional network requests, which is what repeatedly\n                // applying the \"cache-and-network\" or \"network-only\" policies would\n                // seem to imply. Instead, when the cache reports an update after the\n                // initial network request, it may be desirable for subsequent network\n                // requests to be triggered only if the cache result is incomplete. To\n                // that end, the options.nextFetchPolicy option provides an easy way to\n                // update options.fetchPolicy after the initial network request, without\n                // having to call observableQuery.setOptions.\n                options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {\n                    reason: reason,\n                    options: options,\n                    observable: this,\n                    initialFetchPolicy: initialFetchPolicy,\n                });\n            }\n            else if (reason === \"variables-changed\") {\n                options.fetchPolicy = initialFetchPolicy;\n            }\n            else {\n                options.fetchPolicy = options.nextFetchPolicy;\n            }\n        }\n        return options.fetchPolicy;\n    };\n    ObservableQuery.prototype.fetch = function (options, newNetworkStatus, query) {\n        // TODO Make sure we update the networkStatus (and infer fetchVariables)\n        // before actually committing to the fetch.\n        this.queryManager.setObservableQuery(this);\n        return this.queryManager[\"fetchConcastWithInfo\"](this.queryId, options, newNetworkStatus, query);\n    };\n    // Turns polling on or off based on this.options.pollInterval.\n    ObservableQuery.prototype.updatePolling = function () {\n        var _this = this;\n        // Avoid polling in SSR mode\n        if (this.queryManager.ssrMode) {\n            return;\n        }\n        var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;\n        if (!pollInterval) {\n            if (pollingInfo) {\n                clearTimeout(pollingInfo.timeout);\n                delete this.pollingInfo;\n            }\n            return;\n        }\n        if (pollingInfo && pollingInfo.interval === pollInterval) {\n            return;\n        }\n        invariant(pollInterval, 22);\n        var info = pollingInfo || (this.pollingInfo = {});\n        info.interval = pollInterval;\n        var maybeFetch = function () {\n            if (_this.pollingInfo) {\n                if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus)) {\n                    _this.reobserve({\n                        // Most fetchPolicy options don't make sense to use in a polling context, as\n                        // users wouldn't want to be polling the cache directly. However, network-only and\n                        // no-cache are both useful for when the user wants to control whether or not the\n                        // polled results are written to the cache.\n                        fetchPolicy: _this.options.initialFetchPolicy === \"no-cache\" ?\n                            \"no-cache\"\n                            : \"network-only\",\n                    }, NetworkStatus.poll).then(poll, poll);\n                }\n                else {\n                    poll();\n                }\n            }\n        };\n        var poll = function () {\n            var info = _this.pollingInfo;\n            if (info) {\n                clearTimeout(info.timeout);\n                info.timeout = setTimeout(maybeFetch, info.interval);\n            }\n        };\n        poll();\n    };\n    ObservableQuery.prototype.updateLastResult = function (newResult, variables) {\n        if (variables === void 0) { variables = this.variables; }\n        var error = this.getLastError();\n        // Preserve this.last.error unless the variables have changed.\n        if (error && this.last && !equal(variables, this.last.variables)) {\n            error = void 0;\n        }\n        return (this.last = __assign({ result: this.queryManager.assumeImmutableResults ?\n                newResult\n                : cloneDeep(newResult), variables: variables }, (error ? { error: error } : null)));\n    };\n    ObservableQuery.prototype.reobserveAsConcast = function (newOptions, newNetworkStatus) {\n        var _this = this;\n        this.isTornDown = false;\n        var useDisposableConcast = \n        // Refetching uses a disposable Concast to allow refetches using different\n        // options/variables, without permanently altering the options of the\n        // original ObservableQuery.\n        newNetworkStatus === NetworkStatus.refetch ||\n            // The fetchMore method does not actually call the reobserve method, but,\n            // if it did, it would definitely use a disposable Concast.\n            newNetworkStatus === NetworkStatus.fetchMore ||\n            // Polling uses a disposable Concast so the polling options (which force\n            // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n            newNetworkStatus === NetworkStatus.poll;\n        // Save the old variables, since Object.assign may modify them below.\n        var oldVariables = this.options.variables;\n        var oldFetchPolicy = this.options.fetchPolicy;\n        var mergedOptions = compact(this.options, newOptions || {});\n        var options = useDisposableConcast ?\n            // Disposable Concast fetches receive a shallow copy of this.options\n            // (merged with newOptions), leaving this.options unmodified.\n            mergedOptions\n            : assign(this.options, mergedOptions);\n        // Don't update options.query with the transformed query to avoid\n        // overwriting this.options.query when we aren't using a disposable concast.\n        // We want to ensure we can re-run the custom document transforms the next\n        // time a request is made against the original query.\n        var query = this.transformDocument(options.query);\n        this.lastQuery = query;\n        if (!useDisposableConcast) {\n            // We can skip calling updatePolling if we're not changing this.options.\n            this.updatePolling();\n            // Reset options.fetchPolicy to its original value when variables change,\n            // unless a new fetchPolicy was provided by newOptions.\n            if (newOptions &&\n                newOptions.variables &&\n                !equal(newOptions.variables, oldVariables) &&\n                // Don't mess with the fetchPolicy if it's currently \"standby\".\n                options.fetchPolicy !== \"standby\" &&\n                // If we're changing the fetchPolicy anyway, don't try to change it here\n                // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n                options.fetchPolicy === oldFetchPolicy) {\n                this.applyNextFetchPolicy(\"variables-changed\", options);\n                if (newNetworkStatus === void 0) {\n                    newNetworkStatus = NetworkStatus.setVariables;\n                }\n            }\n        }\n        this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));\n        var finishWaitingForOwnResult = function () {\n            if (_this.concast === concast) {\n                _this.waitForOwnResult = false;\n            }\n        };\n        var variables = options.variables && __assign({}, options.variables);\n        var _a = this.fetch(options, newNetworkStatus, query), concast = _a.concast, fromLink = _a.fromLink;\n        var observer = {\n            next: function (result) {\n                finishWaitingForOwnResult();\n                _this.reportResult(result, variables);\n            },\n            error: function (error) {\n                finishWaitingForOwnResult();\n                _this.reportError(error, variables);\n            },\n        };\n        if (!useDisposableConcast && (fromLink || !this.concast)) {\n            // We use the {add,remove}Observer methods directly to avoid wrapping\n            // observer with an unnecessary SubscriptionObserver object.\n            if (this.concast && this.observer) {\n                this.concast.removeObserver(this.observer);\n            }\n            this.concast = concast;\n            this.observer = observer;\n        }\n        concast.addObserver(observer);\n        return concast;\n    };\n    ObservableQuery.prototype.reobserve = function (newOptions, newNetworkStatus) {\n        return this.reobserveAsConcast(newOptions, newNetworkStatus)\n            .promise;\n    };\n    ObservableQuery.prototype.resubscribeAfterError = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // If `lastError` is set in the current when the subscription is re-created,\n        // the subscription will immediately receive the error, which will\n        // cause it to terminate again. To avoid this, we first clear\n        // the last error/result from the `observableQuery` before re-starting\n        // the subscription, and restore the last value afterwards so that the\n        // subscription has a chance to stay open.\n        var last = this.last;\n        this.resetLastResults();\n        var subscription = this.subscribe.apply(this, args);\n        this.last = last;\n        return subscription;\n    };\n    // (Re)deliver the current result to this.observers without applying fetch\n    // policies or making network requests.\n    ObservableQuery.prototype.observe = function () {\n        this.reportResult(\n        // Passing false is important so that this.getCurrentResult doesn't\n        // save the fetchMore result as this.lastResult, causing it to be\n        // ignored due to the this.isDifferentFromLastResult check in\n        // this.reportResult.\n        this.getCurrentResult(false), this.variables);\n    };\n    ObservableQuery.prototype.reportResult = function (result, variables) {\n        var lastError = this.getLastError();\n        var isDifferent = this.isDifferentFromLastResult(result, variables);\n        // Update the last result even when isDifferentFromLastResult returns false,\n        // because the query may be using the @nonreactive directive, and we want to\n        // save the the latest version of any nonreactive subtrees (in case\n        // getCurrentResult is called), even though we skip broadcasting changes.\n        if (lastError || !result.partial || this.options.returnPartialData) {\n            this.updateLastResult(result, variables);\n        }\n        if (lastError || isDifferent) {\n            iterateObserversSafely(this.observers, \"next\", result);\n        }\n    };\n    ObservableQuery.prototype.reportError = function (error, variables) {\n        // Since we don't get the current result on errors, only the error, we\n        // must mirror the updates that occur in QueryStore.markQueryError here\n        var errorResult = __assign(__assign({}, this.getLastResult()), { error: error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });\n        this.updateLastResult(errorResult, variables);\n        iterateObserversSafely(this.observers, \"error\", (this.last.error = error));\n    };\n    ObservableQuery.prototype.hasObservers = function () {\n        return this.observers.size > 0;\n    };\n    ObservableQuery.prototype.tearDownQuery = function () {\n        if (this.isTornDown)\n            return;\n        if (this.concast && this.observer) {\n            this.concast.removeObserver(this.observer);\n            delete this.concast;\n            delete this.observer;\n        }\n        this.stopPolling();\n        // stop all active GraphQL subscriptions\n        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });\n        this.subscriptions.clear();\n        this.queryManager.stopQuery(this.queryId);\n        this.observers.clear();\n        this.isTornDown = true;\n    };\n    ObservableQuery.prototype.transformDocument = function (document) {\n        return this.queryManager.transform(document);\n    };\n    return ObservableQuery;\n}(Observable));\nexport { ObservableQuery };\n// Necessary because the ObservableQuery constructor has a different\n// signature than the Observable constructor.\nfixObservableSubclass(ObservableQuery);\n// Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n// delivery of any new data from the cache, possibly falling back to the network\n// if any cache data are missing. This allows _complete_ cache results to be\n// delivered without also kicking off unnecessary network requests when\n// this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n// this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n// \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\nexport function reobserveCacheFirst(obsQuery) {\n    var _a = obsQuery.options, fetchPolicy = _a.fetchPolicy, nextFetchPolicy = _a.nextFetchPolicy;\n    if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n        return obsQuery.reobserve({\n            fetchPolicy: \"cache-first\",\n            // Use a temporary nextFetchPolicy function that replaces itself with the\n            // previous nextFetchPolicy value and returns the original fetchPolicy.\n            nextFetchPolicy: function (currentFetchPolicy, context) {\n                // Replace this nextFetchPolicy function in the options object with the\n                // original this.options.nextFetchPolicy value.\n                this.nextFetchPolicy = nextFetchPolicy;\n                // If the original nextFetchPolicy value was a function, give it a\n                // chance to decide what happens here.\n                if (typeof this.nextFetchPolicy === \"function\") {\n                    return this.nextFetchPolicy(currentFetchPolicy, context);\n                }\n                // Otherwise go back to the original this.options.fetchPolicy.\n                return fetchPolicy;\n            },\n        });\n    }\n    return obsQuery.reobserve();\n}\nfunction defaultSubscriptionObserverErrorCallback(error) {\n    globalThis.__DEV__ !== false && invariant.error(23, error.message, error.stack);\n}\nexport function logMissingFieldErrors(missing) {\n    if (globalThis.__DEV__ !== false && missing) {\n        globalThis.__DEV__ !== false && invariant.debug(24, missing);\n    }\n}\nfunction skipCacheDataFor(fetchPolicy /* `undefined` would mean `\"cache-first\"` */) {\n    return (fetchPolicy === \"network-only\" ||\n        fetchPolicy === \"no-cache\" ||\n        fetchPolicy === \"standby\");\n}\n", "import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\nimport { argumentsObjectFromField, buildQueryFromSelectionSet, createFragmentMap, getFragmentDefinitions, getMainDefinition, hasDirectives, isField, isInlineFragment, mergeDeep, mergeDeepArray, removeClientSetsFromDocument, resultKeyNameFromField, shouldInclude, } from \"../utilities/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\nvar LocalState = /** @class */ (function () {\n    function LocalState(_a) {\n        var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;\n        this.selectionsToResolveCache = new WeakMap();\n        this.cache = cache;\n        if (client) {\n            this.client = client;\n        }\n        if (resolvers) {\n            this.addResolvers(resolvers);\n        }\n        if (fragmentMatcher) {\n            this.setFragmentMatcher(fragmentMatcher);\n        }\n    }\n    LocalState.prototype.addResolvers = function (resolvers) {\n        var _this = this;\n        this.resolvers = this.resolvers || {};\n        if (Array.isArray(resolvers)) {\n            resolvers.forEach(function (resolverGroup) {\n                _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);\n            });\n        }\n        else {\n            this.resolvers = mergeDeep(this.resolvers, resolvers);\n        }\n    };\n    LocalState.prototype.setResolvers = function (resolvers) {\n        this.resolvers = {};\n        this.addResolvers(resolvers);\n    };\n    LocalState.prototype.getResolvers = function () {\n        return this.resolvers || {};\n    };\n    // Run local client resolvers against the incoming query and remote data.\n    // Locally resolved field values are merged with the incoming remote data,\n    // and returned. Note that locally resolved fields will overwrite\n    // remote data using the same field name.\n    LocalState.prototype.runResolvers = function (_a) {\n        var document = _a.document, remoteResult = _a.remoteResult, context = _a.context, variables = _a.variables, _b = _a.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_c) {\n                if (document) {\n                    return [2 /*return*/, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) { return (__assign(__assign({}, remoteResult), { data: localResult.result })); })];\n                }\n                return [2 /*return*/, remoteResult];\n            });\n        });\n    };\n    LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {\n        this.fragmentMatcher = fragmentMatcher;\n    };\n    LocalState.prototype.getFragmentMatcher = function () {\n        return this.fragmentMatcher;\n    };\n    // Client queries contain everything in the incoming document (if a @client\n    // directive is found).\n    LocalState.prototype.clientQuery = function (document) {\n        if (hasDirectives([\"client\"], document)) {\n            if (this.resolvers) {\n                return document;\n            }\n        }\n        return null;\n    };\n    // Server queries are stripped of all @client based selection sets.\n    LocalState.prototype.serverQuery = function (document) {\n        return removeClientSetsFromDocument(document);\n    };\n    LocalState.prototype.prepareContext = function (context) {\n        var cache = this.cache;\n        return __assign(__assign({}, context), { cache: cache, \n            // Getting an entry's cache key is useful for local state resolvers.\n            getCacheKey: function (obj) {\n                return cache.identify(obj);\n            } });\n    };\n    // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n    // @client @export fields locally, then pass the resolved values back to be\n    // used alongside the original operation variables.\n    LocalState.prototype.addExportedVariables = function (document, variables, context) {\n        if (variables === void 0) { variables = {}; }\n        if (context === void 0) { context = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (document) {\n                    return [2 /*return*/, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) { return (__assign(__assign({}, variables), data.exportedVariables)); })];\n                }\n                return [2 /*return*/, __assign({}, variables)];\n            });\n        });\n    };\n    LocalState.prototype.shouldForceResolvers = function (document) {\n        var forceResolvers = false;\n        visit(document, {\n            Directive: {\n                enter: function (node) {\n                    if (node.name.value === \"client\" && node.arguments) {\n                        forceResolvers = node.arguments.some(function (arg) {\n                            return arg.name.value === \"always\" &&\n                                arg.value.kind === \"BooleanValue\" &&\n                                arg.value.value === true;\n                        });\n                        if (forceResolvers) {\n                            return BREAK;\n                        }\n                    }\n                },\n            },\n        });\n        return forceResolvers;\n    };\n    // Query the cache and return matching data.\n    LocalState.prototype.buildRootValueFromCache = function (document, variables) {\n        return this.cache.diff({\n            query: buildQueryFromSelectionSet(document),\n            variables: variables,\n            returnPartialData: true,\n            optimistic: false,\n        }).result;\n    };\n    LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n        if (context === void 0) { context = {}; }\n        if (variables === void 0) { variables = {}; }\n        if (fragmentMatcher === void 0) { fragmentMatcher = function () { return true; }; }\n        if (onlyRunForcedResolvers === void 0) { onlyRunForcedResolvers = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a, cache, client, execContext, isClientFieldDescendant;\n            return __generator(this, function (_b) {\n                mainDefinition = getMainDefinition(document);\n                fragments = getFragmentDefinitions(document);\n                fragmentMap = createFragmentMap(fragments);\n                selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);\n                definitionOperation = mainDefinition.operation;\n                defaultOperationType = definitionOperation ?\n                    definitionOperation.charAt(0).toUpperCase() +\n                        definitionOperation.slice(1)\n                    : \"Query\";\n                _a = this, cache = _a.cache, client = _a.client;\n                execContext = {\n                    fragmentMap: fragmentMap,\n                    context: __assign(__assign({}, context), { cache: cache, client: client }),\n                    variables: variables,\n                    fragmentMatcher: fragmentMatcher,\n                    defaultOperationType: defaultOperationType,\n                    exportedVariables: {},\n                    selectionsToResolve: selectionsToResolve,\n                    onlyRunForcedResolvers: onlyRunForcedResolvers,\n                };\n                isClientFieldDescendant = false;\n                return [2 /*return*/, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (result) { return ({\n                        result: result,\n                        exportedVariables: execContext.exportedVariables,\n                    }); })];\n            });\n        });\n    };\n    LocalState.prototype.resolveSelectionSet = function (selectionSet, isClientFieldDescendant, rootValue, execContext) {\n        return __awaiter(this, void 0, void 0, function () {\n            var fragmentMap, context, variables, resultsToMerge, execute;\n            var _this = this;\n            return __generator(this, function (_a) {\n                fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n                resultsToMerge = [rootValue];\n                execute = function (selection) { return __awaiter(_this, void 0, void 0, function () {\n                    var fragment, typeCondition;\n                    return __generator(this, function (_a) {\n                        if (!isClientFieldDescendant &&\n                            !execContext.selectionsToResolve.has(selection)) {\n                            // Skip selections without @client directives\n                            // (still processing if one of the ancestors or one of the child fields has @client directive)\n                            return [2 /*return*/];\n                        }\n                        if (!shouldInclude(selection, variables)) {\n                            // Skip this entirely.\n                            return [2 /*return*/];\n                        }\n                        if (isField(selection)) {\n                            return [2 /*return*/, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function (fieldResult) {\n                                    var _a;\n                                    if (typeof fieldResult !== \"undefined\") {\n                                        resultsToMerge.push((_a = {},\n                                            _a[resultKeyNameFromField(selection)] = fieldResult,\n                                            _a));\n                                    }\n                                })];\n                        }\n                        if (isInlineFragment(selection)) {\n                            fragment = selection;\n                        }\n                        else {\n                            // This is a named fragment.\n                            fragment = fragmentMap[selection.name.value];\n                            invariant(fragment, 18, selection.name.value);\n                        }\n                        if (fragment && fragment.typeCondition) {\n                            typeCondition = fragment.typeCondition.name.value;\n                            if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                                return [2 /*return*/, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (fragmentResult) {\n                                        resultsToMerge.push(fragmentResult);\n                                    })];\n                            }\n                        }\n                        return [2 /*return*/];\n                    });\n                }); };\n                return [2 /*return*/, Promise.all(selectionSet.selections.map(execute)).then(function () {\n                        return mergeDeepArray(resultsToMerge);\n                    })];\n            });\n        });\n    };\n    LocalState.prototype.resolveField = function (field, isClientFieldDescendant, rootValue, execContext) {\n        return __awaiter(this, void 0, void 0, function () {\n            var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n            var _this = this;\n            return __generator(this, function (_a) {\n                if (!rootValue) {\n                    return [2 /*return*/, null];\n                }\n                variables = execContext.variables;\n                fieldName = field.name.value;\n                aliasedFieldName = resultKeyNameFromField(field);\n                aliasUsed = fieldName !== aliasedFieldName;\n                defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n                resultPromise = Promise.resolve(defaultResult);\n                // Usually all local resolvers are run when passing through here, but\n                // if we've specifically identified that we only want to run forced\n                // resolvers (that is, resolvers for fields marked with\n                // `@client(always: true)`), then we'll skip running non-forced resolvers.\n                if (!execContext.onlyRunForcedResolvers ||\n                    this.shouldForceResolvers(field)) {\n                    resolverType = rootValue.__typename || execContext.defaultOperationType;\n                    resolverMap = this.resolvers && this.resolvers[resolverType];\n                    if (resolverMap) {\n                        resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n                        if (resolve) {\n                            resultPromise = Promise.resolve(\n                            // In case the resolve function accesses reactive variables,\n                            // set cacheSlot to the current cache instance.\n                            cacheSlot.withValue(this.cache, resolve, [\n                                rootValue,\n                                argumentsObjectFromField(field, variables),\n                                execContext.context,\n                                { field: field, fragmentMap: execContext.fragmentMap },\n                            ]));\n                        }\n                    }\n                }\n                return [2 /*return*/, resultPromise.then(function (result) {\n                        var _a, _b;\n                        if (result === void 0) { result = defaultResult; }\n                        // If an @export directive is associated with the current field, store\n                        // the `as` export variable name and current result for later use.\n                        if (field.directives) {\n                            field.directives.forEach(function (directive) {\n                                if (directive.name.value === \"export\" && directive.arguments) {\n                                    directive.arguments.forEach(function (arg) {\n                                        if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                                            execContext.exportedVariables[arg.value.value] = result;\n                                        }\n                                    });\n                                }\n                            });\n                        }\n                        // Handle all scalar types here.\n                        if (!field.selectionSet) {\n                            return result;\n                        }\n                        // From here down, the field has a selection set, which means it's trying\n                        // to query a GraphQLObjectType.\n                        if (result == null) {\n                            // Basically any field in a GraphQL response can be null, or missing\n                            return result;\n                        }\n                        var isClientField = (_b = (_a = field.directives) === null || _a === void 0 ? void 0 : _a.some(function (d) { return d.name.value === \"client\"; })) !== null && _b !== void 0 ? _b : false;\n                        if (Array.isArray(result)) {\n                            return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);\n                        }\n                        // Returned value is an object, and the query has a sub-selection. Recurse.\n                        if (field.selectionSet) {\n                            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);\n                        }\n                    })];\n            });\n        });\n    };\n    LocalState.prototype.resolveSubSelectedArray = function (field, isClientFieldDescendant, result, execContext) {\n        var _this = this;\n        return Promise.all(result.map(function (item) {\n            if (item === null) {\n                return null;\n            }\n            // This is a nested array, recurse.\n            if (Array.isArray(item)) {\n                return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);\n            }\n            // This is an object, run the selection set on it.\n            if (field.selectionSet) {\n                return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);\n            }\n        }));\n    };\n    // Collect selection nodes on paths from document root down to all @client directives.\n    // This function takes into account transitive fragment spreads.\n    // Complexity equals to a single `visit` over the full document.\n    LocalState.prototype.collectSelectionsToResolve = function (mainDefinition, fragmentMap) {\n        var isSingleASTNode = function (node) { return !Array.isArray(node); };\n        var selectionsToResolveCache = this.selectionsToResolveCache;\n        function collectByDefinition(definitionNode) {\n            if (!selectionsToResolveCache.has(definitionNode)) {\n                var matches_1 = new Set();\n                selectionsToResolveCache.set(definitionNode, matches_1);\n                visit(definitionNode, {\n                    Directive: function (node, _, __, ___, ancestors) {\n                        if (node.name.value === \"client\") {\n                            ancestors.forEach(function (node) {\n                                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                                    matches_1.add(node);\n                                }\n                            });\n                        }\n                    },\n                    FragmentSpread: function (spread, _, __, ___, ancestors) {\n                        var fragment = fragmentMap[spread.name.value];\n                        invariant(fragment, 19, spread.name.value);\n                        var fragmentSelections = collectByDefinition(fragment);\n                        if (fragmentSelections.size > 0) {\n                            // Fragment for this spread contains @client directive (either directly or transitively)\n                            // Collect selection nodes on paths from the root down to fields with the @client directive\n                            ancestors.forEach(function (node) {\n                                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                                    matches_1.add(node);\n                                }\n                            });\n                            matches_1.add(spread);\n                            fragmentSelections.forEach(function (selection) {\n                                matches_1.add(selection);\n                            });\n                        }\n                    },\n                });\n            }\n            return selectionsToResolveCache.get(definitionNode);\n        }\n        return collectByDefinition(mainDefinition);\n    };\n    return LocalState;\n}());\nexport { LocalState };\n", "import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { DeepMerger } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/index.js\";\nimport { reobserveCacheFirst } from \"./ObservableQuery.js\";\nimport { isNonEmptyArray, graphQLResultHasError, canUseWeakMap, } from \"../utilities/index.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nvar destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();\nfunction wrapDestructiveCacheMethod(cache, methodName) {\n    var original = cache[methodName];\n    if (typeof original === \"function\") {\n        cache[methodName] = function () {\n            destructiveMethodCounts.set(cache, \n            // The %1e15 allows the count to wrap around to 0 safely every\n            // quadrillion evictions, so there's no risk of overflow. To be\n            // clear, this is more of a pedantic principle than something\n            // that matters in any conceivable practical scenario.\n            (destructiveMethodCounts.get(cache) + 1) % 1e15);\n            // @ts-expect-error this is just too generic to be typed correctly\n            return original.apply(this, arguments);\n        };\n    }\n}\nfunction cancelNotifyTimeout(info) {\n    if (info[\"notifyTimeout\"]) {\n        clearTimeout(info[\"notifyTimeout\"]);\n        info[\"notifyTimeout\"] = void 0;\n    }\n}\n// A QueryInfo object represents a single query managed by the\n// QueryManager, which tracks all QueryInfo objects by queryId in its\n// this.queries Map. QueryInfo objects store the latest results and errors\n// for the given query, and are responsible for reporting those results to\n// the corresponding ObservableQuery, via the QueryInfo.notify method.\n// Results are reported asynchronously whenever setDiff marks the\n// QueryInfo object as dirty, though a call to the QueryManager's\n// broadcastQueries method may trigger the notification before it happens\n// automatically. This class used to be a simple interface type without\n// any field privacy or meaningful methods, which is why it still has so\n// many public fields. The effort to lock down and simplify the QueryInfo\n// interface is ongoing, and further improvements are welcome.\nvar QueryInfo = /** @class */ (function () {\n    function QueryInfo(queryManager, queryId) {\n        if (queryId === void 0) { queryId = queryManager.generateQueryId(); }\n        this.queryId = queryId;\n        this.listeners = new Set();\n        this.document = null;\n        this.lastRequestId = 1;\n        this.stopped = false;\n        this.dirty = false;\n        this.observableQuery = null;\n        var cache = (this.cache = queryManager.cache);\n        // Track how often cache.evict is called, since we want eviction to\n        // override the feud-stopping logic in the markResult method, by\n        // causing shouldWrite to return true. Wrapping the cache.evict method\n        // is a bit of a hack, but it saves us from having to make eviction\n        // counting an official part of the ApolloCache API.\n        if (!destructiveMethodCounts.has(cache)) {\n            destructiveMethodCounts.set(cache, 0);\n            wrapDestructiveCacheMethod(cache, \"evict\");\n            wrapDestructiveCacheMethod(cache, \"modify\");\n            wrapDestructiveCacheMethod(cache, \"reset\");\n        }\n    }\n    QueryInfo.prototype.init = function (query) {\n        var networkStatus = query.networkStatus || NetworkStatus.loading;\n        if (this.variables &&\n            this.networkStatus !== NetworkStatus.loading &&\n            !equal(this.variables, query.variables)) {\n            networkStatus = NetworkStatus.setVariables;\n        }\n        if (!equal(query.variables, this.variables)) {\n            this.lastDiff = void 0;\n        }\n        Object.assign(this, {\n            document: query.document,\n            variables: query.variables,\n            networkError: null,\n            graphQLErrors: this.graphQLErrors || [],\n            networkStatus: networkStatus,\n        });\n        if (query.observableQuery) {\n            this.setObservableQuery(query.observableQuery);\n        }\n        if (query.lastRequestId) {\n            this.lastRequestId = query.lastRequestId;\n        }\n        return this;\n    };\n    QueryInfo.prototype.reset = function () {\n        cancelNotifyTimeout(this);\n        this.dirty = false;\n    };\n    QueryInfo.prototype.getDiff = function () {\n        var options = this.getDiffOptions();\n        if (this.lastDiff && equal(options, this.lastDiff.options)) {\n            return this.lastDiff.diff;\n        }\n        this.updateWatch(this.variables);\n        var oq = this.observableQuery;\n        if (oq && oq.options.fetchPolicy === \"no-cache\") {\n            return { complete: false };\n        }\n        var diff = this.cache.diff(options);\n        this.updateLastDiff(diff, options);\n        return diff;\n    };\n    QueryInfo.prototype.updateLastDiff = function (diff, options) {\n        this.lastDiff =\n            diff ?\n                {\n                    diff: diff,\n                    options: options || this.getDiffOptions(),\n                }\n                : void 0;\n    };\n    QueryInfo.prototype.getDiffOptions = function (variables) {\n        var _a;\n        if (variables === void 0) { variables = this.variables; }\n        return {\n            query: this.document,\n            variables: variables,\n            returnPartialData: true,\n            optimistic: true,\n            canonizeResults: (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.options.canonizeResults,\n        };\n    };\n    QueryInfo.prototype.setDiff = function (diff) {\n        var _this = this;\n        var oldDiff = this.lastDiff && this.lastDiff.diff;\n        this.updateLastDiff(diff);\n        if (!this.dirty && !equal(oldDiff && oldDiff.result, diff && diff.result)) {\n            this.dirty = true;\n            if (!this.notifyTimeout) {\n                this.notifyTimeout = setTimeout(function () { return _this.notify(); }, 0);\n            }\n        }\n    };\n    QueryInfo.prototype.setObservableQuery = function (oq) {\n        var _this = this;\n        if (oq === this.observableQuery)\n            return;\n        if (this.oqListener) {\n            this.listeners.delete(this.oqListener);\n        }\n        this.observableQuery = oq;\n        if (oq) {\n            oq[\"queryInfo\"] = this;\n            this.listeners.add((this.oqListener = function () {\n                var diff = _this.getDiff();\n                if (diff.fromOptimisticTransaction) {\n                    // If this diff came from an optimistic transaction, deliver the\n                    // current cache data to the ObservableQuery, but don't perform a\n                    // reobservation, since oq.reobserveCacheFirst might make a network\n                    // request, and we never want to trigger network requests in the\n                    // middle of optimistic updates.\n                    oq[\"observe\"]();\n                }\n                else {\n                    // Otherwise, make the ObservableQuery \"reobserve\" the latest data\n                    // using a temporary fetch policy of \"cache-first\", so complete cache\n                    // results have a chance to be delivered without triggering additional\n                    // network requests, even when options.fetchPolicy is \"network-only\"\n                    // or \"cache-and-network\". All other fetch policies are preserved by\n                    // this method, and are handled by calling oq.reobserve(). If this\n                    // reobservation is spurious, isDifferentFromLastResult still has a\n                    // chance to catch it before delivery to ObservableQuery subscribers.\n                    reobserveCacheFirst(oq);\n                }\n            }));\n        }\n        else {\n            delete this.oqListener;\n        }\n    };\n    QueryInfo.prototype.notify = function () {\n        var _this = this;\n        cancelNotifyTimeout(this);\n        if (this.shouldNotify()) {\n            this.listeners.forEach(function (listener) { return listener(_this); });\n        }\n        this.dirty = false;\n    };\n    QueryInfo.prototype.shouldNotify = function () {\n        if (!this.dirty || !this.listeners.size) {\n            return false;\n        }\n        if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {\n            var fetchPolicy = this.observableQuery.options.fetchPolicy;\n            if (fetchPolicy !== \"cache-only\" && fetchPolicy !== \"cache-and-network\") {\n                return false;\n            }\n        }\n        return true;\n    };\n    QueryInfo.prototype.stop = function () {\n        if (!this.stopped) {\n            this.stopped = true;\n            // Cancel the pending notify timeout\n            this.reset();\n            this.cancel();\n            // Revert back to the no-op version of cancel inherited from\n            // QueryInfo.prototype.\n            this.cancel = QueryInfo.prototype.cancel;\n            var oq = this.observableQuery;\n            if (oq)\n                oq.stopPolling();\n        }\n    };\n    // This method is a no-op by default, until/unless overridden by the\n    // updateWatch method.\n    QueryInfo.prototype.cancel = function () { };\n    QueryInfo.prototype.updateWatch = function (variables) {\n        var _this = this;\n        if (variables === void 0) { variables = this.variables; }\n        var oq = this.observableQuery;\n        if (oq && oq.options.fetchPolicy === \"no-cache\") {\n            return;\n        }\n        var watchOptions = __assign(__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function (diff) { return _this.setDiff(diff); } });\n        if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {\n            this.cancel();\n            this.cancel = this.cache.watch((this.lastWatch = watchOptions));\n        }\n    };\n    QueryInfo.prototype.resetLastWrite = function () {\n        this.lastWrite = void 0;\n    };\n    QueryInfo.prototype.shouldWrite = function (result, variables) {\n        var lastWrite = this.lastWrite;\n        return !(lastWrite &&\n            // If cache.evict has been called since the last time we wrote this\n            // data into the cache, there's a chance writing this result into\n            // the cache will repair what was evicted.\n            lastWrite.dmCount === destructiveMethodCounts.get(this.cache) &&\n            equal(variables, lastWrite.variables) &&\n            equal(result.data, lastWrite.result.data));\n    };\n    QueryInfo.prototype.markResult = function (result, document, options, cacheWriteBehavior) {\n        var _this = this;\n        var merger = new DeepMerger();\n        var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];\n        // Cancel the pending notify timeout (if it exists) to prevent extraneous network\n        // requests. To allow future notify timeouts, diff and dirty are reset as well.\n        this.reset();\n        if (\"incremental\" in result && isNonEmptyArray(result.incremental)) {\n            var mergedData = mergeIncrementalData(this.getDiff().result, result);\n            result.data = mergedData;\n            // Detect the first chunk of a deferred query and merge it with existing\n            // cache data. This ensures a `cache-first` fetch policy that returns\n            // partial cache data or a `cache-and-network` fetch policy that already\n            // has full data in the cache does not complain when trying to merge the\n            // initial deferred server data with existing cache data.\n        }\n        else if (\"hasNext\" in result && result.hasNext) {\n            var diff = this.getDiff();\n            result.data = merger.merge(diff.result, result.data);\n        }\n        this.graphQLErrors = graphQLErrors;\n        if (options.fetchPolicy === \"no-cache\") {\n            this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options.variables));\n        }\n        else if (cacheWriteBehavior !== 0 /* CacheWriteBehavior.FORBID */) {\n            if (shouldWriteResult(result, options.errorPolicy)) {\n                // Using a transaction here so we have a chance to read the result\n                // back from the cache before the watch callback fires as a result\n                // of writeQuery, so we can store the new diff quietly and ignore\n                // it when we receive it redundantly from the watch callback.\n                this.cache.performTransaction(function (cache) {\n                    if (_this.shouldWrite(result, options.variables)) {\n                        cache.writeQuery({\n                            query: document,\n                            data: result.data,\n                            variables: options.variables,\n                            overwrite: cacheWriteBehavior === 1 /* CacheWriteBehavior.OVERWRITE */,\n                        });\n                        _this.lastWrite = {\n                            result: result,\n                            variables: options.variables,\n                            dmCount: destructiveMethodCounts.get(_this.cache),\n                        };\n                    }\n                    else {\n                        // If result is the same as the last result we received from\n                        // the network (and the variables match too), avoid writing\n                        // result into the cache again. The wisdom of skipping this\n                        // cache write is far from obvious, since any cache write\n                        // could be the one that puts the cache back into a desired\n                        // state, fixing corruption or missing data. However, if we\n                        // always write every network result into the cache, we enable\n                        // feuds between queries competing to update the same data in\n                        // incompatible ways, which can lead to an endless cycle of\n                        // cache broadcasts and useless network requests. As with any\n                        // feud, eventually one side must step back from the brink,\n                        // letting the other side(s) have the last word(s). There may\n                        // be other points where we could break this cycle, such as\n                        // silencing the broadcast for cache.writeQuery (not a good\n                        // idea, since it just delays the feud a bit) or somehow\n                        // avoiding the network request that just happened (also bad,\n                        // because the server could return useful new data). All\n                        // options considered, skipping this cache write seems to be\n                        // the least damaging place to break the cycle, because it\n                        // reflects the intuition that we recently wrote this exact\n                        // result into the cache, so the cache *should* already/still\n                        // contain this data. If some other query has clobbered that\n                        // data in the meantime, that's too bad, but there will be no\n                        // winners if every query blindly reverts to its own version\n                        // of the data. This approach also gives the network a chance\n                        // to return new data, which will be written into the cache as\n                        // usual, notifying only those queries that are directly\n                        // affected by the cache updates, as usual. In the future, an\n                        // even more sophisticated cache could perhaps prevent or\n                        // mitigate the clobbering somehow, but that would make this\n                        // particular cache write even less important, and thus\n                        // skipping it would be even safer than it is today.\n                        if (_this.lastDiff && _this.lastDiff.diff.complete) {\n                            // Reuse data from the last good (complete) diff that we\n                            // received, when possible.\n                            result.data = _this.lastDiff.diff.result;\n                            return;\n                        }\n                        // If the previous this.diff was incomplete, fall through to\n                        // re-reading the latest data with cache.diff, below.\n                    }\n                    var diffOptions = _this.getDiffOptions(options.variables);\n                    var diff = cache.diff(diffOptions);\n                    // In case the QueryManager stops this QueryInfo before its\n                    // results are delivered, it's important to avoid restarting the\n                    // cache watch when markResult is called. We also avoid updating\n                    // the watch if we are writing a result that doesn't match the current\n                    // variables to avoid race conditions from broadcasting the wrong\n                    // result.\n                    if (!_this.stopped && equal(_this.variables, options.variables)) {\n                        // Any time we're about to update this.diff, we need to make\n                        // sure we've started watching the cache.\n                        _this.updateWatch(options.variables);\n                    }\n                    // If we're allowed to write to the cache, and we can read a\n                    // complete result from the cache, update result.data to be the\n                    // result from the cache, rather than the raw network result.\n                    // Set without setDiff to avoid triggering a notify call, since\n                    // we have other ways of notifying for this result.\n                    _this.updateLastDiff(diff, diffOptions);\n                    if (diff.complete) {\n                        result.data = diff.result;\n                    }\n                });\n            }\n            else {\n                this.lastWrite = void 0;\n            }\n        }\n    };\n    QueryInfo.prototype.markReady = function () {\n        this.networkError = null;\n        return (this.networkStatus = NetworkStatus.ready);\n    };\n    QueryInfo.prototype.markError = function (error) {\n        this.networkStatus = NetworkStatus.error;\n        this.lastWrite = void 0;\n        this.reset();\n        if (error.graphQLErrors) {\n            this.graphQLErrors = error.graphQLErrors;\n        }\n        if (error.networkError) {\n            this.networkError = error.networkError;\n        }\n        return error;\n    };\n    return QueryInfo;\n}());\nexport { QueryInfo };\nexport function shouldWriteResult(result, errorPolicy) {\n    if (errorPolicy === void 0) { errorPolicy = \"none\"; }\n    var ignoreErrors = errorPolicy === \"ignore\" || errorPolicy === \"all\";\n    var writeWithErrors = !graphQLResultHasError(result);\n    if (!writeWithErrors && ignoreErrors && result.data) {\n        writeWithErrors = true;\n    }\n    return writeWithErrors;\n}\n", "import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { execute } from \"../link/core/index.js\";\nimport { hasDirectives, isExecutionPatchIncrementalResult, isExecutionPatchResult, removeDirectivesFromDocument, } from \"../utilities/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, getGraphQLErrorsFromResult, canUseWeakMap, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject, DocumentTransform, } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors, } from \"../errors/index.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { LocalState } from \"./LocalState.js\";\nimport { QueryInfo, shouldWriteResult, } from \"./QueryInfo.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar QueryManager = /** @class */ (function () {\n    function QueryManager(_a) {\n        var cache = _a.cache, link = _a.link, defaultOptions = _a.defaultOptions, documentTransform = _a.documentTransform, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a.onBroadcast, _c = _a.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a.localState, _e = _a.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? !!cache.assumeImmutableResults : _e;\n        var _this = this;\n        this.clientAwareness = {};\n        // All the queries that the QueryManager is currently managing (not\n        // including mutations and subscriptions).\n        this.queries = new Map();\n        // Maps from queryId strings to Promise rejection functions for\n        // currently active queries and fetches.\n        // Use protected instead of private field so\n        // @apollo/experimental-nextjs-app-support can access type info.\n        this.fetchCancelFns = new Map();\n        this.transformCache = new (canUseWeakMap ? WeakMap : Map)();\n        this.queryIdCounter = 1;\n        this.requestIdCounter = 1;\n        this.mutationIdCounter = 1;\n        // Use protected instead of private field so\n        // @apollo/experimental-nextjs-app-support can access type info.\n        this.inFlightLinkObservables = new Map();\n        var defaultDocumentTransform = new DocumentTransform(function (document) { return _this.cache.transformDocument(document); }, \n        // Allow the apollo cache to manage its own transform caches\n        { cache: false });\n        this.cache = cache;\n        this.link = link;\n        this.defaultOptions = defaultOptions || Object.create(null);\n        this.queryDeduplication = queryDeduplication;\n        this.clientAwareness = clientAwareness;\n        this.localState = localState || new LocalState({ cache: cache });\n        this.ssrMode = ssrMode;\n        this.assumeImmutableResults = assumeImmutableResults;\n        this.documentTransform =\n            documentTransform ?\n                defaultDocumentTransform\n                    .concat(documentTransform)\n                    // The custom document transform may add new fragment spreads or new\n                    // field selections, so we want to give the cache a chance to run\n                    // again. For example, the InMemoryCache adds __typename to field\n                    // selections and fragments from the fragment registry.\n                    .concat(defaultDocumentTransform)\n                : defaultDocumentTransform;\n        if ((this.onBroadcast = onBroadcast)) {\n            this.mutationStore = Object.create(null);\n        }\n    }\n    /**\n     * Call this method to terminate any active query processes, making it safe\n     * to dispose of this QueryManager instance.\n     */\n    QueryManager.prototype.stop = function () {\n        var _this = this;\n        this.queries.forEach(function (_info, queryId) {\n            _this.stopQueryNoBroadcast(queryId);\n        });\n        this.cancelPendingFetches(newInvariantError(25));\n    };\n    QueryManager.prototype.cancelPendingFetches = function (error) {\n        this.fetchCancelFns.forEach(function (cancel) { return cancel(error); });\n        this.fetchCancelFns.clear();\n    };\n    QueryManager.prototype.mutate = function (_a) {\n        var _b, _c;\n        var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueries = _a.updateQueries, _d = _a.refetchQueries, refetchQueries = _d === void 0 ? [] : _d, _e = _a.awaitRefetchQueries, awaitRefetchQueries = _e === void 0 ? false : _e, updateWithProxyFn = _a.update, onQueryUpdated = _a.onQueryUpdated, _f = _a.fetchPolicy, fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || \"network-only\" : _f, _g = _a.errorPolicy, errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || \"none\" : _g, keepRootFields = _a.keepRootFields, context = _a.context;\n        return __awaiter(this, void 0, void 0, function () {\n            var mutationId, hasClientExports, mutationStoreValue, self;\n            return __generator(this, function (_h) {\n                switch (_h.label) {\n                    case 0:\n                        invariant(mutation, 26);\n                        invariant(fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\", 27);\n                        mutationId = this.generateMutationId();\n                        mutation = this.cache.transformForLink(this.transform(mutation));\n                        hasClientExports = this.getDocumentInfo(mutation).hasClientExports;\n                        variables = this.getVariables(mutation, variables);\n                        if (!hasClientExports) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.localState.addExportedVariables(mutation, variables, context)];\n                    case 1:\n                        variables = (_h.sent());\n                        _h.label = 2;\n                    case 2:\n                        mutationStoreValue = this.mutationStore &&\n                            (this.mutationStore[mutationId] = {\n                                mutation: mutation,\n                                variables: variables,\n                                loading: true,\n                                error: null,\n                            });\n                        if (optimisticResponse) {\n                            this.markMutationOptimistic(optimisticResponse, {\n                                mutationId: mutationId,\n                                document: mutation,\n                                variables: variables,\n                                fetchPolicy: fetchPolicy,\n                                errorPolicy: errorPolicy,\n                                context: context,\n                                updateQueries: updateQueries,\n                                update: updateWithProxyFn,\n                                keepRootFields: keepRootFields,\n                            });\n                        }\n                        this.broadcastQueries();\n                        self = this;\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\n                                return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse: optimisticResponse }), variables, false), function (result) {\n                                    if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n                                        throw new ApolloError({\n                                            graphQLErrors: getGraphQLErrorsFromResult(result),\n                                        });\n                                    }\n                                    if (mutationStoreValue) {\n                                        mutationStoreValue.loading = false;\n                                        mutationStoreValue.error = null;\n                                    }\n                                    var storeResult = __assign({}, result);\n                                    if (typeof refetchQueries === \"function\") {\n                                        refetchQueries = refetchQueries(storeResult);\n                                    }\n                                    if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n                                        delete storeResult.errors;\n                                    }\n                                    return self.markMutationResult({\n                                        mutationId: mutationId,\n                                        result: storeResult,\n                                        document: mutation,\n                                        variables: variables,\n                                        fetchPolicy: fetchPolicy,\n                                        errorPolicy: errorPolicy,\n                                        context: context,\n                                        update: updateWithProxyFn,\n                                        updateQueries: updateQueries,\n                                        awaitRefetchQueries: awaitRefetchQueries,\n                                        refetchQueries: refetchQueries,\n                                        removeOptimistic: optimisticResponse ? mutationId : void 0,\n                                        onQueryUpdated: onQueryUpdated,\n                                        keepRootFields: keepRootFields,\n                                    });\n                                }).subscribe({\n                                    next: function (storeResult) {\n                                        self.broadcastQueries();\n                                        // Since mutations might receive multiple payloads from the\n                                        // ApolloLink chain (e.g. when used with @defer),\n                                        // we resolve with a SingleExecutionResult or after the final\n                                        // ExecutionPatchResult has arrived and we have assembled the\n                                        // multipart response into a single result.\n                                        if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n                                            resolve(storeResult);\n                                        }\n                                    },\n                                    error: function (err) {\n                                        if (mutationStoreValue) {\n                                            mutationStoreValue.loading = false;\n                                            mutationStoreValue.error = err;\n                                        }\n                                        if (optimisticResponse) {\n                                            self.cache.removeOptimistic(mutationId);\n                                        }\n                                        self.broadcastQueries();\n                                        reject(err instanceof ApolloError ? err : (new ApolloError({\n                                            networkError: err,\n                                        })));\n                                    },\n                                });\n                            })];\n                }\n            });\n        });\n    };\n    QueryManager.prototype.markMutationResult = function (mutation, cache) {\n        var _this = this;\n        if (cache === void 0) { cache = this.cache; }\n        var result = mutation.result;\n        var cacheWrites = [];\n        var skipCache = mutation.fetchPolicy === \"no-cache\";\n        if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n            if (!isExecutionPatchIncrementalResult(result)) {\n                cacheWrites.push({\n                    result: result.data,\n                    dataId: \"ROOT_MUTATION\",\n                    query: mutation.document,\n                    variables: mutation.variables,\n                });\n            }\n            if (isExecutionPatchIncrementalResult(result) &&\n                isNonEmptyArray(result.incremental)) {\n                var diff = cache.diff({\n                    id: \"ROOT_MUTATION\",\n                    // The cache complains if passed a mutation where it expects a\n                    // query, so we transform mutations and subscriptions to queries\n                    // (only once, thanks to this.transformCache).\n                    query: this.getDocumentInfo(mutation.document).asQuery,\n                    variables: mutation.variables,\n                    optimistic: false,\n                    returnPartialData: true,\n                });\n                var mergedData = void 0;\n                if (diff.result) {\n                    mergedData = mergeIncrementalData(diff.result, result);\n                }\n                if (typeof mergedData !== \"undefined\") {\n                    // cast the ExecutionPatchResult to FetchResult here since\n                    // ExecutionPatchResult never has `data` when returned from the server\n                    result.data = mergedData;\n                    cacheWrites.push({\n                        result: mergedData,\n                        dataId: \"ROOT_MUTATION\",\n                        query: mutation.document,\n                        variables: mutation.variables,\n                    });\n                }\n            }\n            var updateQueries_1 = mutation.updateQueries;\n            if (updateQueries_1) {\n                this.queries.forEach(function (_a, queryId) {\n                    var observableQuery = _a.observableQuery;\n                    var queryName = observableQuery && observableQuery.queryName;\n                    if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n                        return;\n                    }\n                    var updater = updateQueries_1[queryName];\n                    var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;\n                    // Read the current query result from the store.\n                    var _c = cache.diff({\n                        query: document,\n                        variables: variables,\n                        returnPartialData: true,\n                        optimistic: false,\n                    }), currentQueryResult = _c.result, complete = _c.complete;\n                    if (complete && currentQueryResult) {\n                        // Run our reducer using the current query result and the mutation result.\n                        var nextQueryResult = updater(currentQueryResult, {\n                            mutationResult: result,\n                            queryName: (document && getOperationName(document)) || void 0,\n                            queryVariables: variables,\n                        });\n                        // Write the modified result back into the store if we got a new result.\n                        if (nextQueryResult) {\n                            cacheWrites.push({\n                                result: nextQueryResult,\n                                dataId: \"ROOT_QUERY\",\n                                query: document,\n                                variables: variables,\n                            });\n                        }\n                    }\n                });\n            }\n        }\n        if (cacheWrites.length > 0 ||\n            mutation.refetchQueries ||\n            mutation.update ||\n            mutation.onQueryUpdated ||\n            mutation.removeOptimistic) {\n            var results_1 = [];\n            this.refetchQueries({\n                updateCache: function (cache) {\n                    if (!skipCache) {\n                        cacheWrites.forEach(function (write) { return cache.write(write); });\n                    }\n                    // If the mutation has some writes associated with it then we need to\n                    // apply those writes to the store by running this reducer again with\n                    // a write action.\n                    var update = mutation.update;\n                    // Determine whether result is a SingleExecutionResult,\n                    // or the final ExecutionPatchResult.\n                    var isFinalResult = !isExecutionPatchResult(result) ||\n                        (isExecutionPatchIncrementalResult(result) && !result.hasNext);\n                    if (update) {\n                        if (!skipCache) {\n                            // Re-read the ROOT_MUTATION data we just wrote into the cache\n                            // (the first cache.write call in the cacheWrites.forEach loop\n                            // above), so field read functions have a chance to run for\n                            // fields within mutation result objects.\n                            var diff = cache.diff({\n                                id: \"ROOT_MUTATION\",\n                                // The cache complains if passed a mutation where it expects a\n                                // query, so we transform mutations and subscriptions to queries\n                                // (only once, thanks to this.transformCache).\n                                query: _this.getDocumentInfo(mutation.document).asQuery,\n                                variables: mutation.variables,\n                                optimistic: false,\n                                returnPartialData: true,\n                            });\n                            if (diff.complete) {\n                                result = __assign(__assign({}, result), { data: diff.result });\n                                if (\"incremental\" in result) {\n                                    delete result.incremental;\n                                }\n                                if (\"hasNext\" in result) {\n                                    delete result.hasNext;\n                                }\n                            }\n                        }\n                        // If we've received the whole response,\n                        // either a SingleExecutionResult or the final ExecutionPatchResult,\n                        // call the update function.\n                        if (isFinalResult) {\n                            update(cache, result, {\n                                context: mutation.context,\n                                variables: mutation.variables,\n                            });\n                        }\n                    }\n                    // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n                    // shallow to allow rolling back optimistic evictions.\n                    if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n                        cache.modify({\n                            id: \"ROOT_MUTATION\",\n                            fields: function (value, _a) {\n                                var fieldName = _a.fieldName, DELETE = _a.DELETE;\n                                return fieldName === \"__typename\" ? value : DELETE;\n                            },\n                        });\n                    }\n                },\n                include: mutation.refetchQueries,\n                // Write the final mutation.result to the root layer of the cache.\n                optimistic: false,\n                // Remove the corresponding optimistic layer at the same time as we\n                // write the final non-optimistic result.\n                removeOptimistic: mutation.removeOptimistic,\n                // Let the caller of client.mutate optionally determine the refetching\n                // behavior for watched queries after the mutation.update function runs.\n                // If no onQueryUpdated function was provided for this mutation, pass\n                // null instead of undefined to disable the default refetching behavior.\n                onQueryUpdated: mutation.onQueryUpdated || null,\n            }).forEach(function (result) { return results_1.push(result); });\n            if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n                // Returning a promise here makes the mutation await that promise, so we\n                // include results in that promise's work if awaitRefetchQueries or an\n                // onQueryUpdated function was specified.\n                return Promise.all(results_1).then(function () { return result; });\n            }\n        }\n        return Promise.resolve(result);\n    };\n    QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n        var _this = this;\n        var data = typeof optimisticResponse === \"function\" ?\n            optimisticResponse(mutation.variables)\n            : optimisticResponse;\n        return this.cache.recordOptimisticTransaction(function (cache) {\n            try {\n                _this.markMutationResult(__assign(__assign({}, mutation), { result: { data: data } }), cache);\n            }\n            catch (error) {\n                globalThis.__DEV__ !== false && invariant.error(error);\n            }\n        }, mutation.mutationId);\n    };\n    QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n        return this.fetchConcastWithInfo(queryId, options, networkStatus).concast\n            .promise;\n    };\n    QueryManager.prototype.getQueryStore = function () {\n        var store = Object.create(null);\n        this.queries.forEach(function (info, queryId) {\n            store[queryId] = {\n                variables: info.variables,\n                networkStatus: info.networkStatus,\n                networkError: info.networkError,\n                graphQLErrors: info.graphQLErrors,\n            };\n        });\n        return store;\n    };\n    QueryManager.prototype.resetErrors = function (queryId) {\n        var queryInfo = this.queries.get(queryId);\n        if (queryInfo) {\n            queryInfo.networkError = undefined;\n            queryInfo.graphQLErrors = [];\n        }\n    };\n    QueryManager.prototype.transform = function (document) {\n        return this.documentTransform.transformDocument(document);\n    };\n    QueryManager.prototype.getDocumentInfo = function (document) {\n        var transformCache = this.transformCache;\n        if (!transformCache.has(document)) {\n            var cacheEntry = {\n                // TODO These three calls (hasClientExports, shouldForceResolvers, and\n                // usesNonreactiveDirective) are performing independent full traversals\n                // of the transformed document. We should consider merging these\n                // traversals into a single pass in the future, though the work is\n                // cached after the first time.\n                hasClientExports: hasClientExports(document),\n                hasForcedResolvers: this.localState.shouldForceResolvers(document),\n                hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n                clientQuery: this.localState.clientQuery(document),\n                serverQuery: removeDirectivesFromDocument([\n                    { name: \"client\", remove: true },\n                    { name: \"connection\" },\n                    { name: \"nonreactive\" },\n                ], document),\n                defaultVars: getDefaultValues(getOperationDefinition(document)),\n                // Transform any mutation or subscription operations to query operations\n                // so we can read/write them from/to the cache.\n                asQuery: __assign(__assign({}, document), { definitions: document.definitions.map(function (def) {\n                        if (def.kind === \"OperationDefinition\" &&\n                            def.operation !== \"query\") {\n                            return __assign(__assign({}, def), { operation: \"query\" });\n                        }\n                        return def;\n                    }) }),\n            };\n            transformCache.set(document, cacheEntry);\n        }\n        return transformCache.get(document);\n    };\n    QueryManager.prototype.getVariables = function (document, variables) {\n        return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);\n    };\n    QueryManager.prototype.watchQuery = function (options) {\n        var query = this.transform(options.query);\n        // assign variable default values if supplied\n        // NOTE: We don't modify options.query here with the transformed query to\n        // ensure observable.options.query is set to the raw untransformed query.\n        options = __assign(__assign({}, options), { variables: this.getVariables(query, options.variables) });\n        if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n            options.notifyOnNetworkStatusChange = false;\n        }\n        var queryInfo = new QueryInfo(this);\n        var observable = new ObservableQuery({\n            queryManager: this,\n            queryInfo: queryInfo,\n            options: options,\n        });\n        observable[\"lastQuery\"] = query;\n        this.queries.set(observable.queryId, queryInfo);\n        // We give queryInfo the transformed query to ensure the first cache diff\n        // uses the transformed query instead of the raw query\n        queryInfo.init({\n            document: query,\n            observableQuery: observable,\n            variables: observable.variables,\n        });\n        return observable;\n    };\n    QueryManager.prototype.query = function (options, queryId) {\n        var _this = this;\n        if (queryId === void 0) { queryId = this.generateQueryId(); }\n        invariant(options.query, 28);\n        invariant(options.query.kind === \"Document\", 29);\n        invariant(!options.returnPartialData, 30);\n        invariant(!options.pollInterval, 31);\n        return this.fetchQuery(queryId, __assign(__assign({}, options), { query: this.transform(options.query) })).finally(function () { return _this.stopQuery(queryId); });\n    };\n    QueryManager.prototype.generateQueryId = function () {\n        return String(this.queryIdCounter++);\n    };\n    QueryManager.prototype.generateRequestId = function () {\n        return this.requestIdCounter++;\n    };\n    QueryManager.prototype.generateMutationId = function () {\n        return String(this.mutationIdCounter++);\n    };\n    QueryManager.prototype.stopQueryInStore = function (queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n        var queryInfo = this.queries.get(queryId);\n        if (queryInfo)\n            queryInfo.stop();\n    };\n    QueryManager.prototype.clearStore = function (options) {\n        if (options === void 0) { options = {\n            discardWatches: true,\n        }; }\n        // Before we have sent the reset action to the store, we can no longer\n        // rely on the results returned by in-flight requests since these may\n        // depend on values that previously existed in the data portion of the\n        // store. So, we cancel the promises and observers that we have issued\n        // so far and not yet resolved (in the case of queries).\n        this.cancelPendingFetches(newInvariantError(32));\n        this.queries.forEach(function (queryInfo) {\n            if (queryInfo.observableQuery) {\n                // Set loading to true so listeners don't trigger unless they want\n                // results with partial data.\n                queryInfo.networkStatus = NetworkStatus.loading;\n            }\n            else {\n                queryInfo.stop();\n            }\n        });\n        if (this.mutationStore) {\n            this.mutationStore = Object.create(null);\n        }\n        // begin removing data from the store\n        return this.cache.reset(options);\n    };\n    QueryManager.prototype.getObservableQueries = function (include) {\n        var _this = this;\n        if (include === void 0) { include = \"active\"; }\n        var queries = new Map();\n        var queryNamesAndDocs = new Map();\n        var legacyQueryOptions = new Set();\n        if (Array.isArray(include)) {\n            include.forEach(function (desc) {\n                if (typeof desc === \"string\") {\n                    queryNamesAndDocs.set(desc, false);\n                }\n                else if (isDocumentNode(desc)) {\n                    queryNamesAndDocs.set(_this.transform(desc), false);\n                }\n                else if (isNonNullObject(desc) && desc.query) {\n                    legacyQueryOptions.add(desc);\n                }\n            });\n        }\n        this.queries.forEach(function (_a, queryId) {\n            var oq = _a.observableQuery, document = _a.document;\n            if (oq) {\n                if (include === \"all\") {\n                    queries.set(queryId, oq);\n                    return;\n                }\n                var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;\n                if (fetchPolicy === \"standby\" ||\n                    (include === \"active\" && !oq.hasObservers())) {\n                    return;\n                }\n                if (include === \"active\" ||\n                    (queryName && queryNamesAndDocs.has(queryName)) ||\n                    (document && queryNamesAndDocs.has(document))) {\n                    queries.set(queryId, oq);\n                    if (queryName)\n                        queryNamesAndDocs.set(queryName, true);\n                    if (document)\n                        queryNamesAndDocs.set(document, true);\n                }\n            }\n        });\n        if (legacyQueryOptions.size) {\n            legacyQueryOptions.forEach(function (options) {\n                // We will be issuing a fresh network request for this query, so we\n                // pre-allocate a new query ID here, using a special prefix to enable\n                // cleaning up these temporary queries later, after fetching.\n                var queryId = makeUniqueId(\"legacyOneTimeQuery\");\n                var queryInfo = _this.getQuery(queryId).init({\n                    document: options.query,\n                    variables: options.variables,\n                });\n                var oq = new ObservableQuery({\n                    queryManager: _this,\n                    queryInfo: queryInfo,\n                    options: __assign(__assign({}, options), { fetchPolicy: \"network-only\" }),\n                });\n                invariant(oq.queryId === queryId);\n                queryInfo.setObservableQuery(oq);\n                queries.set(queryId, oq);\n            });\n        }\n        if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {\n            queryNamesAndDocs.forEach(function (included, nameOrDoc) {\n                if (!included) {\n                    globalThis.__DEV__ !== false && invariant.warn(typeof nameOrDoc === \"string\" ? 33 : 34, nameOrDoc);\n                }\n            });\n        }\n        return queries;\n    };\n    QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n        var _this = this;\n        if (includeStandby === void 0) { includeStandby = false; }\n        var observableQueryPromises = [];\n        this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function (observableQuery, queryId) {\n            var fetchPolicy = observableQuery.options.fetchPolicy;\n            observableQuery.resetLastResults();\n            if (includeStandby ||\n                (fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\")) {\n                observableQueryPromises.push(observableQuery.refetch());\n            }\n            _this.getQuery(queryId).setDiff(null);\n        });\n        this.broadcastQueries();\n        return Promise.all(observableQueryPromises);\n    };\n    QueryManager.prototype.setObservableQuery = function (observableQuery) {\n        this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n    };\n    QueryManager.prototype.startGraphQLSubscription = function (_a) {\n        var _this = this;\n        var query = _a.query, fetchPolicy = _a.fetchPolicy, _b = _a.errorPolicy, errorPolicy = _b === void 0 ? \"none\" : _b, variables = _a.variables, _c = _a.context, context = _c === void 0 ? {} : _c;\n        query = this.transform(query);\n        variables = this.getVariables(query, variables);\n        var makeObservable = function (variables) {\n            return _this.getObservableFromLink(query, context, variables).map(function (result) {\n                if (fetchPolicy !== \"no-cache\") {\n                    // the subscription interface should handle not sending us results we no longer subscribe to.\n                    // XXX I don't think we ever send in an object with errors, but we might in the future...\n                    if (shouldWriteResult(result, errorPolicy)) {\n                        _this.cache.write({\n                            query: query,\n                            result: result.data,\n                            dataId: \"ROOT_SUBSCRIPTION\",\n                            variables: variables,\n                        });\n                    }\n                    _this.broadcastQueries();\n                }\n                var hasErrors = graphQLResultHasError(result);\n                var hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n                if (hasErrors || hasProtocolErrors) {\n                    var errors = {};\n                    if (hasErrors) {\n                        errors.graphQLErrors = result.errors;\n                    }\n                    if (hasProtocolErrors) {\n                        errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n                    }\n                    // `errorPolicy` is a mechanism for handling GraphQL errors, according\n                    // to our documentation, so we throw protocol errors regardless of the\n                    // set error policy.\n                    if (errorPolicy === \"none\" || hasProtocolErrors) {\n                        throw new ApolloError(errors);\n                    }\n                }\n                if (errorPolicy === \"ignore\") {\n                    delete result.errors;\n                }\n                return result;\n            });\n        };\n        if (this.getDocumentInfo(query).hasClientExports) {\n            var observablePromise_1 = this.localState\n                .addExportedVariables(query, variables, context)\n                .then(makeObservable);\n            return new Observable(function (observer) {\n                var sub = null;\n                observablePromise_1.then(function (observable) { return (sub = observable.subscribe(observer)); }, observer.error);\n                return function () { return sub && sub.unsubscribe(); };\n            });\n        }\n        return makeObservable(variables);\n    };\n    QueryManager.prototype.stopQuery = function (queryId) {\n        this.stopQueryNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.removeQuery(queryId);\n    };\n    QueryManager.prototype.removeQuery = function (queryId) {\n        // teardown all links\n        // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n        // that each add their reject functions to fetchCancelFns.\n        // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n        // The same queryId could have two rejection fns for two promises\n        this.fetchCancelFns.delete(queryId);\n        if (this.queries.has(queryId)) {\n            this.getQuery(queryId).stop();\n            this.queries.delete(queryId);\n        }\n    };\n    QueryManager.prototype.broadcastQueries = function () {\n        if (this.onBroadcast)\n            this.onBroadcast();\n        this.queries.forEach(function (info) { return info.notify(); });\n    };\n    QueryManager.prototype.getLocalState = function () {\n        return this.localState;\n    };\n    QueryManager.prototype.getObservableFromLink = function (query, context, variables, \n    // Prefer context.queryDeduplication if specified.\n    deduplication) {\n        var _this = this;\n        var _a;\n        if (deduplication === void 0) { deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication; }\n        var observable;\n        var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;\n        if (serverQuery) {\n            var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;\n            var operation = {\n                query: serverQuery,\n                variables: variables,\n                operationName: getOperationName(serverQuery) || void 0,\n                context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication })),\n            };\n            context = operation.context;\n            if (deduplication) {\n                var printedServerQuery_1 = print(serverQuery);\n                var byVariables_1 = inFlightLinkObservables_1.get(printedServerQuery_1) || new Map();\n                inFlightLinkObservables_1.set(printedServerQuery_1, byVariables_1);\n                var varJson_1 = canonicalStringify(variables);\n                observable = byVariables_1.get(varJson_1);\n                if (!observable) {\n                    var concast = new Concast([\n                        execute(link, operation),\n                    ]);\n                    byVariables_1.set(varJson_1, (observable = concast));\n                    concast.beforeNext(function () {\n                        if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {\n                            inFlightLinkObservables_1.delete(printedServerQuery_1);\n                        }\n                    });\n                }\n            }\n            else {\n                observable = new Concast([\n                    execute(link, operation),\n                ]);\n            }\n        }\n        else {\n            observable = new Concast([Observable.of({ data: {} })]);\n            context = this.prepareContext(context);\n        }\n        if (clientQuery) {\n            observable = asyncMap(observable, function (result) {\n                return _this.localState.runResolvers({\n                    document: clientQuery,\n                    remoteResult: result,\n                    context: context,\n                    variables: variables,\n                });\n            });\n        }\n        return observable;\n    };\n    QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\n        var requestId = (queryInfo.lastRequestId = this.generateRequestId());\n        // Performing transformForLink here gives this.cache a chance to fill in\n        // missing fragment definitions (for example) before sending this document\n        // through the link chain.\n        var linkDocument = this.cache.transformForLink(options.query);\n        return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function (result) {\n            var graphQLErrors = getGraphQLErrorsFromResult(result);\n            var hasErrors = graphQLErrors.length > 0;\n            // If we interrupted this request by calling getResultsFromLink again\n            // with the same QueryInfo object, we ignore the old results.\n            if (requestId >= queryInfo.lastRequestId) {\n                if (hasErrors && options.errorPolicy === \"none\") {\n                    // Throwing here effectively calls observer.error.\n                    throw queryInfo.markError(new ApolloError({\n                        graphQLErrors: graphQLErrors,\n                    }));\n                }\n                // Use linkDocument rather than queryInfo.document so the\n                // operation/fragments used to write the result are the same as the\n                // ones used to obtain it from the link.\n                queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n                queryInfo.markReady();\n            }\n            var aqr = {\n                data: result.data,\n                loading: false,\n                networkStatus: NetworkStatus.ready,\n            };\n            if (hasErrors && options.errorPolicy !== \"ignore\") {\n                aqr.errors = graphQLErrors;\n                aqr.networkStatus = NetworkStatus.error;\n            }\n            return aqr;\n        }, function (networkError) {\n            var error = isApolloError(networkError) ? networkError : (new ApolloError({ networkError: networkError }));\n            // Avoid storing errors from older interrupted queries.\n            if (requestId >= queryInfo.lastRequestId) {\n                queryInfo.markError(error);\n            }\n            throw error;\n        });\n    };\n    QueryManager.prototype.fetchConcastWithInfo = function (queryId, options, \n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus, query) {\n        var _this = this;\n        if (networkStatus === void 0) { networkStatus = NetworkStatus.loading; }\n        if (query === void 0) { query = options.query; }\n        var variables = this.getVariables(query, options.variables);\n        var queryInfo = this.getQuery(queryId);\n        var defaults = this.defaultOptions.watchQuery;\n        var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? (defaults && defaults.fetchPolicy) || \"cache-first\" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? (defaults && defaults.errorPolicy) || \"none\" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;\n        var normalized = Object.assign({}, options, {\n            query: query,\n            variables: variables,\n            fetchPolicy: fetchPolicy,\n            errorPolicy: errorPolicy,\n            returnPartialData: returnPartialData,\n            notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n            context: context,\n        });\n        var fromVariables = function (variables) {\n            // Since normalized is always a fresh copy of options, it's safe to\n            // modify its properties here, rather than creating yet another new\n            // WatchQueryOptions object.\n            normalized.variables = variables;\n            var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n            if (\n            // If we're in standby, postpone advancing options.fetchPolicy using\n            // applyNextFetchPolicy.\n            normalized.fetchPolicy !== \"standby\" &&\n                // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n                // this is another way to detect when nothing was done/fetched.\n                sourcesWithInfo.sources.length > 0 &&\n                queryInfo.observableQuery) {\n                queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n            }\n            return sourcesWithInfo;\n        };\n        // This cancel function needs to be set before the concast is created,\n        // in case concast creation synchronously cancels the request.\n        var cleanupCancelFn = function () { return _this.fetchCancelFns.delete(queryId); };\n        this.fetchCancelFns.set(queryId, function (reason) {\n            cleanupCancelFn();\n            // This delay ensures the concast variable has been initialized.\n            setTimeout(function () { return concast.cancel(reason); });\n        });\n        var concast, containsDataFromLink;\n        // If the query has @export(as: ...) directives, then we need to\n        // process those directives asynchronously. When there are no\n        // @export directives (the common case), we deliberately avoid\n        // wrapping the result of this.fetchQueryByPolicy in a Promise,\n        // since the timing of result delivery is (unfortunately) important\n        // for backwards compatibility. TODO This code could be simpler if\n        // we deprecated and removed LocalState.\n        if (this.getDocumentInfo(normalized.query).hasClientExports) {\n            concast = new Concast(this.localState\n                .addExportedVariables(normalized.query, normalized.variables, normalized.context)\n                .then(fromVariables)\n                .then(function (sourcesWithInfo) { return sourcesWithInfo.sources; }));\n            // there is just no way we can synchronously get the *right* value here,\n            // so we will assume `true`, which is the behaviour before the bug fix in\n            // #10597. This means that bug is not fixed in that case, and is probably\n            // un-fixable with reasonable effort for the edge case of @export as\n            // directives.\n            containsDataFromLink = true;\n        }\n        else {\n            var sourcesWithInfo = fromVariables(normalized.variables);\n            containsDataFromLink = sourcesWithInfo.fromLink;\n            concast = new Concast(sourcesWithInfo.sources);\n        }\n        concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n        return {\n            concast: concast,\n            fromLink: containsDataFromLink,\n        };\n    };\n    QueryManager.prototype.refetchQueries = function (_a) {\n        var _this = this;\n        var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\"refetchQueries\") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;\n        var includedQueriesById = new Map();\n        if (include) {\n            this.getObservableQueries(include).forEach(function (oq, queryId) {\n                includedQueriesById.set(queryId, {\n                    oq: oq,\n                    lastDiff: _this.getQuery(queryId).getDiff(),\n                });\n            });\n        }\n        var results = new Map();\n        if (updateCache) {\n            this.cache.batch({\n                update: updateCache,\n                // Since you can perform any combination of cache reads and/or writes in\n                // the cache.batch update function, its optimistic option can be either\n                // a boolean or a string, representing three distinct modes of\n                // operation:\n                //\n                // * false: read/write only the root layer\n                // * true: read/write the topmost layer\n                // * string: read/write a fresh optimistic layer with that ID string\n                //\n                // When typeof optimistic === \"string\", a new optimistic layer will be\n                // temporarily created within cache.batch with that string as its ID. If\n                // we then pass that same string as the removeOptimistic option, we can\n                // make cache.batch immediately remove the optimistic layer after\n                // running the updateCache function, triggering only one broadcast.\n                //\n                // However, the refetchQueries method accepts only true or false for its\n                // optimistic option (not string). We interpret true to mean a temporary\n                // optimistic layer should be created, to allow efficiently rolling back\n                // the effect of the updateCache function, which involves passing a\n                // string instead of true as the optimistic option to cache.batch, when\n                // refetchQueries receives optimistic: true.\n                //\n                // In other words, we are deliberately not supporting the use case of\n                // writing to an *existing* optimistic layer (using the refetchQueries\n                // updateCache function), since that would potentially interfere with\n                // other optimistic updates in progress. Instead, you can read/write\n                // only the root layer by passing optimistic: false to refetchQueries,\n                // or you can read/write a brand new optimistic layer that will be\n                // automatically removed by passing optimistic: true.\n                optimistic: (optimistic && removeOptimistic) || false,\n                // The removeOptimistic option can also be provided by itself, even if\n                // optimistic === false, to remove some previously-added optimistic\n                // layer safely and efficiently, like we do in markMutationResult.\n                //\n                // If an explicit removeOptimistic string is provided with optimistic:\n                // true, the removeOptimistic string will determine the ID of the\n                // temporary optimistic layer, in case that ever matters.\n                removeOptimistic: removeOptimistic,\n                onWatchUpdated: function (watch, diff, lastDiff) {\n                    var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n                    if (oq) {\n                        if (onQueryUpdated) {\n                            // Since we're about to handle this query now, remove it from\n                            // includedQueriesById, in case it was added earlier because of\n                            // options.include.\n                            includedQueriesById.delete(oq.queryId);\n                            var result = onQueryUpdated(oq, diff, lastDiff);\n                            if (result === true) {\n                                // The onQueryUpdated function requested the default refetching\n                                // behavior by returning true.\n                                result = oq.refetch();\n                            }\n                            // Record the result in the results Map, as long as onQueryUpdated\n                            // did not return false to skip/ignore this result.\n                            if (result !== false) {\n                                results.set(oq, result);\n                            }\n                            // Allow the default cache broadcast to happen, except when\n                            // onQueryUpdated returns false.\n                            return result;\n                        }\n                        if (onQueryUpdated !== null) {\n                            // If we don't have an onQueryUpdated function, and onQueryUpdated\n                            // was not disabled by passing null, make sure this query is\n                            // \"included\" like any other options.include-specified query.\n                            includedQueriesById.set(oq.queryId, { oq: oq, lastDiff: lastDiff, diff: diff });\n                        }\n                    }\n                },\n            });\n        }\n        if (includedQueriesById.size) {\n            includedQueriesById.forEach(function (_a, queryId) {\n                var oq = _a.oq, lastDiff = _a.lastDiff, diff = _a.diff;\n                var result;\n                // If onQueryUpdated is provided, we want to use it for all included\n                // queries, even the QueryOptions ones.\n                if (onQueryUpdated) {\n                    if (!diff) {\n                        var info = oq[\"queryInfo\"];\n                        info.reset(); // Force info.getDiff() to read from cache.\n                        diff = info.getDiff();\n                    }\n                    result = onQueryUpdated(oq, diff, lastDiff);\n                }\n                // Otherwise, we fall back to refetching.\n                if (!onQueryUpdated || result === true) {\n                    result = oq.refetch();\n                }\n                if (result !== false) {\n                    results.set(oq, result);\n                }\n                if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n                    _this.stopQueryNoBroadcast(queryId);\n                }\n            });\n        }\n        if (removeOptimistic) {\n            // In case no updateCache callback was provided (so cache.batch was not\n            // called above, and thus did not already remove the optimistic layer),\n            // remove it here. Since this is a no-op when the layer has already been\n            // removed, we do it even if we called cache.batch above, since it's\n            // possible this.cache is an instance of some ApolloCache subclass other\n            // than InMemoryCache, and does not fully support the removeOptimistic\n            // option for cache.batch.\n            this.cache.removeOptimistic(removeOptimistic);\n        }\n        return results;\n    };\n    QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a, \n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus) {\n        var _this = this;\n        var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n        var oldNetworkStatus = queryInfo.networkStatus;\n        queryInfo.init({\n            document: query,\n            variables: variables,\n            networkStatus: networkStatus,\n        });\n        var readCache = function () { return queryInfo.getDiff(); };\n        var resultsFromCache = function (diff, networkStatus) {\n            if (networkStatus === void 0) { networkStatus = queryInfo.networkStatus || NetworkStatus.loading; }\n            var data = diff.result;\n            if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {\n                logMissingFieldErrors(diff.missing);\n            }\n            var fromData = function (data) {\n                return Observable.of(__assign({ data: data, loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus }, (diff.complete ? null : { partial: true })));\n            };\n            if (data && _this.getDocumentInfo(query).hasForcedResolvers) {\n                return _this.localState\n                    .runResolvers({\n                    document: query,\n                    remoteResult: { data: data },\n                    context: context,\n                    variables: variables,\n                    onlyRunForcedResolvers: true,\n                })\n                    .then(function (resolved) { return fromData(resolved.data || void 0); });\n            }\n            // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n            // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n            // data was incorrectly returned from the cache on refetch:\n            // if diff.missing exists, we should not return cache data.\n            if (errorPolicy === \"none\" &&\n                networkStatus === NetworkStatus.refetch &&\n                Array.isArray(diff.missing)) {\n                return fromData(void 0);\n            }\n            return fromData(data);\n        };\n        var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */\n            // Watched queries must opt into overwriting existing data on refetch,\n            // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n            : (networkStatus === NetworkStatus.refetch &&\n                refetchWritePolicy !== \"merge\") ?\n                1 /* CacheWriteBehavior.OVERWRITE */\n                : 2 /* CacheWriteBehavior.MERGE */;\n        var resultsFromLink = function () {\n            return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n                query: query,\n                variables: variables,\n                context: context,\n                fetchPolicy: fetchPolicy,\n                errorPolicy: errorPolicy,\n            });\n        };\n        var shouldNotify = notifyOnNetworkStatusChange &&\n            typeof oldNetworkStatus === \"number\" &&\n            oldNetworkStatus !== networkStatus &&\n            isNetworkRequestInFlight(networkStatus);\n        switch (fetchPolicy) {\n            default:\n            case \"cache-first\": {\n                var diff = readCache();\n                if (diff.complete) {\n                    return {\n                        fromLink: false,\n                        sources: [resultsFromCache(diff, queryInfo.markReady())],\n                    };\n                }\n                if (returnPartialData || shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(diff), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            }\n            case \"cache-and-network\": {\n                var diff = readCache();\n                if (diff.complete || returnPartialData || shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(diff), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            }\n            case \"cache-only\":\n                return {\n                    fromLink: false,\n                    sources: [resultsFromCache(readCache(), queryInfo.markReady())],\n                };\n            case \"network-only\":\n                if (shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(readCache()), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            case \"no-cache\":\n                if (shouldNotify) {\n                    return {\n                        fromLink: true,\n                        // Note that queryInfo.getDiff() for no-cache queries does not call\n                        // cache.diff, but instead returns a { complete: false } stub result\n                        // when there is no queryInfo.diff already defined.\n                        sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            case \"standby\":\n                return { fromLink: false, sources: [] };\n        }\n    };\n    QueryManager.prototype.getQuery = function (queryId) {\n        if (queryId && !this.queries.has(queryId)) {\n            this.queries.set(queryId, new QueryInfo(this, queryId));\n        }\n        return this.queries.get(queryId);\n    };\n    QueryManager.prototype.prepareContext = function (context) {\n        if (context === void 0) { context = {}; }\n        var newContext = this.localState.prepareContext(context);\n        return __assign(__assign({}, newContext), { clientAwareness: this.clientAwareness });\n    };\n    return QueryManager;\n}());\nexport { QueryManager };\n", "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport { version } from \"../version.js\";\nimport { HttpLink } from \"../link/http/index.js\";\nimport { QueryManager } from \"./QueryManager.js\";\nimport { LocalState } from \"./LocalState.js\";\nvar hasSuggestedDevtools = false;\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities/index.js\";\nexport { mergeOptions };\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an {@link ApolloLink} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nvar ApolloClient = /** @class */ (function () {\n    /**\n     * Constructs an instance of {@link ApolloClient}.\n     *\n     * @example\n     * ```js\n     * import { ApolloClient, InMemoryCache } from '@apollo/client';\n     *\n     * const cache = new InMemoryCache();\n     *\n     * const client = new ApolloClient({\n     *   // Provide required constructor fields\n     *   cache: cache,\n     *   uri: 'http://localhost:4000/',\n     *\n     *   // Provide some optional constructor fields\n     *   name: 'react-web-client',\n     *   version: '1.3',\n     *   queryDeduplication: false,\n     *   defaultOptions: {\n     *     watchQuery: {\n     *       fetchPolicy: 'cache-and-network',\n     *     },\n     *   },\n     * });\n     * ```\n     */\n    function ApolloClient(options) {\n        var _this = this;\n        this.resetStoreCallbacks = [];\n        this.clearStoreCallbacks = [];\n        if (!options.cache) {\n            throw newInvariantError(15);\n        }\n        var uri = options.uri, credentials = options.credentials, headers = options.headers, cache = options.cache, documentTransform = options.documentTransform, _a = options.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, \n        // Expose the client instance as window.__APOLLO_CLIENT__ and call\n        // onBroadcast in queryManager.broadcastQueries to enable browser\n        // devtools, but disable them by default in production.\n        _c = options.connectToDevTools, \n        // Expose the client instance as window.__APOLLO_CLIENT__ and call\n        // onBroadcast in queryManager.broadcastQueries to enable browser\n        // devtools, but disable them by default in production.\n        connectToDevTools = _c === void 0 ? typeof window === \"object\" &&\n            !window.__APOLLO_CLIENT__ &&\n            globalThis.__DEV__ !== false : _c, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions = options.defaultOptions, _e = options.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? cache.assumeImmutableResults : _e, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;\n        var link = options.link;\n        if (!link) {\n            link =\n                uri ? new HttpLink({ uri: uri, credentials: credentials, headers: headers }) : ApolloLink.empty();\n        }\n        this.link = link;\n        this.cache = cache;\n        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n        this.queryDeduplication = queryDeduplication;\n        this.defaultOptions = defaultOptions || Object.create(null);\n        this.typeDefs = typeDefs;\n        if (ssrForceFetchDelay) {\n            setTimeout(function () { return (_this.disableNetworkFetches = false); }, ssrForceFetchDelay);\n        }\n        this.watchQuery = this.watchQuery.bind(this);\n        this.query = this.query.bind(this);\n        this.mutate = this.mutate.bind(this);\n        this.resetStore = this.resetStore.bind(this);\n        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n        this.version = version;\n        this.localState = new LocalState({\n            cache: cache,\n            client: this,\n            resolvers: resolvers,\n            fragmentMatcher: fragmentMatcher,\n        });\n        this.queryManager = new QueryManager({\n            cache: this.cache,\n            link: this.link,\n            defaultOptions: this.defaultOptions,\n            documentTransform: documentTransform,\n            queryDeduplication: queryDeduplication,\n            ssrMode: ssrMode,\n            clientAwareness: {\n                name: clientAwarenessName,\n                version: clientAwarenessVersion,\n            },\n            localState: this.localState,\n            assumeImmutableResults: assumeImmutableResults,\n            onBroadcast: connectToDevTools ?\n                function () {\n                    if (_this.devToolsHookCb) {\n                        _this.devToolsHookCb({\n                            action: {},\n                            state: {\n                                queries: _this.queryManager.getQueryStore(),\n                                mutations: _this.queryManager.mutationStore || {},\n                            },\n                            dataWithOptimisticResults: _this.cache.extract(true),\n                        });\n                    }\n                }\n                : void 0,\n        });\n        if (connectToDevTools)\n            this.connectToDevTools();\n    }\n    ApolloClient.prototype.connectToDevTools = function () {\n        if (typeof window === \"object\") {\n            var windowWithDevTools = window;\n            var devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n            (windowWithDevTools[devtoolsSymbol] =\n                windowWithDevTools[devtoolsSymbol] || []).push(this);\n            windowWithDevTools.__APOLLO_CLIENT__ = this;\n        }\n        /**\n         * Suggest installing the devtools for developers who don't have them\n         */\n        if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {\n            hasSuggestedDevtools = true;\n            setTimeout(function () {\n                if (typeof window !== \"undefined\" &&\n                    window.document &&\n                    window.top === window.self &&\n                    !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n                    var nav = window.navigator;\n                    var ua = nav && nav.userAgent;\n                    var url = void 0;\n                    if (typeof ua === \"string\") {\n                        if (ua.indexOf(\"Chrome/\") > -1) {\n                            url =\n                                \"https://chrome.google.com/webstore/detail/\" +\n                                    \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n                        }\n                        else if (ua.indexOf(\"Firefox/\") > -1) {\n                            url =\n                                \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n                        }\n                    }\n                    if (url) {\n                        globalThis.__DEV__ !== false && invariant.log(\"Download the Apollo DevTools for a better development \" +\n                            \"experience: %s\", url);\n                    }\n                }\n            }, 10000);\n        }\n    };\n    Object.defineProperty(ApolloClient.prototype, \"documentTransform\", {\n        /**\n         * The `DocumentTransform` used to modify GraphQL documents before a request\n         * is made. If a custom `DocumentTransform` is not provided, this will be the\n         * default document transform.\n         */\n        get: function () {\n            return this.queryManager.documentTransform;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Call this method to terminate any active client processes, making it safe\n     * to dispose of this `ApolloClient` instance.\n     */\n    ApolloClient.prototype.stop = function () {\n        this.queryManager.stop();\n    };\n    /**\n     * This watches the cache store of the query according to the options specified and\n     * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n     * receive updated results through a GraphQL observer when the cache store changes.\n     *\n     * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n     * it uses Apollo's store in order to reactively deliver updates to your query results.\n     *\n     * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n     * first and last name and this person has a particular object identifier, provided by\n     * dataIdFromObject. Later, a different query fetches that same person's\n     * first and last name and the first name has now changed. Then, any observers associated\n     * with the results of the first query will be updated with a new result object.\n     *\n     * Note that if the cache does not change, the subscriber will *not* be notified.\n     *\n     * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n     * a description of store reactivity.\n     */\n    ApolloClient.prototype.watchQuery = function (options) {\n        if (this.defaultOptions.watchQuery) {\n            options = mergeOptions(this.defaultOptions.watchQuery, options);\n        }\n        // XXX Overwriting options is probably not the best way to do this long term...\n        if (this.disableNetworkFetches &&\n            (options.fetchPolicy === \"network-only\" ||\n                options.fetchPolicy === \"cache-and-network\")) {\n            options = __assign(__assign({}, options), { fetchPolicy: \"cache-first\" });\n        }\n        return this.queryManager.watchQuery(options);\n    };\n    /**\n     * This resolves a single query according to the options specified and\n     * returns a `Promise` which is either resolved with the resulting data\n     * or rejected with an error.\n     *\n     * @param options - An object of type {@link QueryOptions} that allows us to\n     * describe how this query should be treated e.g. whether it should hit the\n     * server at all or just resolve from the cache, etc.\n     */\n    ApolloClient.prototype.query = function (options) {\n        if (this.defaultOptions.query) {\n            options = mergeOptions(this.defaultOptions.query, options);\n        }\n        invariant(options.fetchPolicy !== \"cache-and-network\", 16);\n        if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n            options = __assign(__assign({}, options), { fetchPolicy: \"cache-first\" });\n        }\n        return this.queryManager.query(options);\n    };\n    /**\n     * This resolves a single mutation according to the options specified and returns a\n     * Promise which is either resolved with the resulting data or rejected with an\n     * error.\n     *\n     * It takes options as an object with the following keys and values:\n     */\n    ApolloClient.prototype.mutate = function (options) {\n        if (this.defaultOptions.mutate) {\n            options = mergeOptions(this.defaultOptions.mutate, options);\n        }\n        return this.queryManager.mutate(options);\n    };\n    /**\n     * This subscribes to a graphql subscription according to the options specified and returns an\n     * {@link Observable} which either emits received data or an error.\n     */\n    ApolloClient.prototype.subscribe = function (options) {\n        return this.queryManager.startGraphQLSubscription(options);\n    };\n    /**\n     * Tries to read some data from the store in the shape of the provided\n     * GraphQL query without making a network request. This method will start at\n     * the root query. To start at a specific id returned by `dataIdFromObject`\n     * use `readFragment`.\n     *\n     * @param optimistic - Set to `true` to allow `readQuery` to return\n     * optimistic results. Is `false` by default.\n     */\n    ApolloClient.prototype.readQuery = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return this.cache.readQuery(options, optimistic);\n    };\n    /**\n     * Tries to read some data from the store in the shape of the provided\n     * GraphQL fragment without making a network request. This method will read a\n     * GraphQL fragment from any arbitrary id that is currently cached, unlike\n     * `readQuery` which will only read from the root query.\n     *\n     * You must pass in a GraphQL document with a single fragment or a document\n     * with multiple fragments that represent what you are reading. If you pass\n     * in a document with multiple fragments then you must also specify a\n     * `fragmentName`.\n     *\n     * @param optimistic - Set to `true` to allow `readFragment` to return\n     * optimistic results. Is `false` by default.\n     */\n    ApolloClient.prototype.readFragment = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return this.cache.readFragment(options, optimistic);\n    };\n    /**\n     * Writes some data in the shape of the provided GraphQL query directly to\n     * the store. This method will start at the root query. To start at a\n     * specific id returned by `dataIdFromObject` then use `writeFragment`.\n     */\n    ApolloClient.prototype.writeQuery = function (options) {\n        var ref = this.cache.writeQuery(options);\n        if (options.broadcast !== false) {\n            this.queryManager.broadcastQueries();\n        }\n        return ref;\n    };\n    /**\n     * Writes some data in the shape of the provided GraphQL fragment directly to\n     * the store. This method will write to a GraphQL fragment from any arbitrary\n     * id that is currently cached, unlike `writeQuery` which will only write\n     * from the root query.\n     *\n     * You must pass in a GraphQL document with a single fragment or a document\n     * with multiple fragments that represent what you are writing. If you pass\n     * in a document with multiple fragments then you must also specify a\n     * `fragmentName`.\n     */\n    ApolloClient.prototype.writeFragment = function (options) {\n        var ref = this.cache.writeFragment(options);\n        if (options.broadcast !== false) {\n            this.queryManager.broadcastQueries();\n        }\n        return ref;\n    };\n    ApolloClient.prototype.__actionHookForDevTools = function (cb) {\n        this.devToolsHookCb = cb;\n    };\n    ApolloClient.prototype.__requestRaw = function (payload) {\n        return execute(this.link, payload);\n    };\n    /**\n     * Resets your entire store by clearing out your cache and then re-executing\n     * all of your active queries. This makes it so that you may guarantee that\n     * there is no data left in your store from a time before you called this\n     * method.\n     *\n     * `resetStore()` is useful when your user just logged out. You’ve removed the\n     * user session, and you now want to make sure that any references to data you\n     * might have fetched while the user session was active is gone.\n     *\n     * It is important to remember that `resetStore()` *will* refetch any active\n     * queries. This means that any components that might be mounted will execute\n     * their queries again using your network interface. If you do not want to\n     * re-execute any queries then you should make sure to stop watching any\n     * active queries.\n     */\n    ApolloClient.prototype.resetStore = function () {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            return _this.queryManager.clearStore({\n                discardWatches: false,\n            });\n        })\n            .then(function () { return Promise.all(_this.resetStoreCallbacks.map(function (fn) { return fn(); })); })\n            .then(function () { return _this.reFetchObservableQueries(); });\n    };\n    /**\n     * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n     * not refetch any active queries.\n     */\n    ApolloClient.prototype.clearStore = function () {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            return _this.queryManager.clearStore({\n                discardWatches: true,\n            });\n        })\n            .then(function () { return Promise.all(_this.clearStoreCallbacks.map(function (fn) { return fn(); })); });\n    };\n    /**\n     * Allows callbacks to be registered that are executed when the store is\n     * reset. `onResetStore` returns an unsubscribe function that can be used\n     * to remove registered callbacks.\n     */\n    ApolloClient.prototype.onResetStore = function (cb) {\n        var _this = this;\n        this.resetStoreCallbacks.push(cb);\n        return function () {\n            _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) { return c !== cb; });\n        };\n    };\n    /**\n     * Allows callbacks to be registered that are executed when the store is\n     * cleared. `onClearStore` returns an unsubscribe function that can be used\n     * to remove registered callbacks.\n     */\n    ApolloClient.prototype.onClearStore = function (cb) {\n        var _this = this;\n        this.clearStoreCallbacks.push(cb);\n        return function () {\n            _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) { return c !== cb; });\n        };\n    };\n    /**\n     * Refetches all of your active queries.\n     *\n     * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n     *\n     * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n     * queries. This means that any components that might be mounted will execute\n     * their queries again using your network interface. If you do not want to\n     * re-execute any queries then you should make sure to stop watching any\n     * active queries.\n     * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n     */\n    ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {\n        return this.queryManager.reFetchObservableQueries(includeStandby);\n    };\n    /**\n     * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n     *\n     * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n     *\n     * It is important to remember that `refetchQueries()` *will* refetch specified active\n     * queries. This means that any components that might be mounted will execute\n     * their queries again using your network interface. If you do not want to\n     * re-execute any queries then you should make sure to stop watching any\n     * active queries.\n     */\n    ApolloClient.prototype.refetchQueries = function (options) {\n        var map = this.queryManager.refetchQueries(options);\n        var queries = [];\n        var results = [];\n        map.forEach(function (result, obsQuery) {\n            queries.push(obsQuery);\n            results.push(result);\n        });\n        var result = Promise.all(results);\n        // In case you need the raw results immediately, without awaiting\n        // Promise.all(results):\n        result.queries = queries;\n        result.results = results;\n        // If you decide to ignore the result Promise because you're using\n        // result.queries and result.results instead, you shouldn't have to worry\n        // about preventing uncaught rejections for the Promise.all result.\n        result.catch(function (error) {\n            globalThis.__DEV__ !== false && invariant.debug(17, error);\n        });\n        return result;\n    };\n    /**\n     * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n     * query ID strings.\n     *\n     * An \"active\" query is one that has observers and a `fetchPolicy` other than\n     * \"standby\" or \"cache-only\".\n     *\n     * You can include all `ObservableQuery` objects (including the inactive ones)\n     * by passing \"all\" instead of \"active\", or you can include just a subset of\n     * active queries by passing an array of query names or DocumentNode objects.\n     */\n    ApolloClient.prototype.getObservableQueries = function (include) {\n        if (include === void 0) { include = \"active\"; }\n        return this.queryManager.getObservableQueries(include);\n    };\n    /**\n     * Exposes the cache's complete state, in a serializable format for later restoration.\n     */\n    ApolloClient.prototype.extract = function (optimistic) {\n        return this.cache.extract(optimistic);\n    };\n    /**\n     * Replaces existing state in the cache (if any) with the values expressed by\n     * `serializedState`.\n     *\n     * Called when hydrating a cache (server side rendering, or offline storage),\n     * and also (potentially) during hot reloads.\n     */\n    ApolloClient.prototype.restore = function (serializedState) {\n        return this.cache.restore(serializedState);\n    };\n    /**\n     * Add additional local resolvers.\n     */\n    ApolloClient.prototype.addResolvers = function (resolvers) {\n        this.localState.addResolvers(resolvers);\n    };\n    /**\n     * Set (override existing) local resolvers.\n     */\n    ApolloClient.prototype.setResolvers = function (resolvers) {\n        this.localState.setResolvers(resolvers);\n    };\n    /**\n     * Get all registered local resolvers.\n     */\n    ApolloClient.prototype.getResolvers = function () {\n        return this.localState.getResolvers();\n    };\n    /**\n     * Set a custom local state fragment matcher.\n     */\n    ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {\n        this.localState.setFragmentMatcher(fragmentMatcher);\n    };\n    /**\n     * Define a new ApolloLink (or link chain) that Apollo Client will use.\n     */\n    ApolloClient.prototype.setLink = function (newLink) {\n        this.link = this.queryManager.link = newLink;\n    };\n    return ApolloClient;\n}());\nexport { ApolloClient };\n", "/* Core */\nexport { ApolloClient, mergeOptions } from \"./ApolloClient.js\";\nexport { ObservableQuery } from \"./ObservableQuery.js\";\nexport { NetworkStatus, isNetworkRequestSettled } from \"./networkStatus.js\";\nexport * from \"./types.js\";\nexport { isApolloError, ApolloError } from \"../errors/index.js\";\nexport { Cache, ApolloCache, InMemoryCache, MissingFieldError, defaultDataIdFromObject, makeVar, } from \"../cache/index.js\";\nexport * from \"../cache/inmemory/types.js\";\n/* Link */\nexport * from \"../link/core/index.js\";\nexport * from \"../link/http/index.js\";\nexport { fromError, toPromise, fromPromise, throwServerError, } from \"../link/utils/index.js\";\nexport { DocumentTransform, Observable, isReference, makeReference, } from \"../utilities/index.js\";\n/* Supporting */\n// The verbosity of invariant.{log,warn,error} can be controlled globally\n// (for anyone using the same ts-invariant package) by passing \"log\",\n// \"warn\", \"error\", or \"silent\" to setVerbosity (\"log\" is the default).\n// Note that all invariant.* logging is hidden in production.\nimport { setVerbosity } from \"ts-invariant\";\nexport { setVerbosity as setLogVerbosity };\nsetVerbosity(globalThis.__DEV__ !== false ? \"log\" : \"silent\");\n// Note that importing `gql` by itself, then destructuring\n// additional properties separately before exporting, is intentional.\n// Due to the way the `graphql-tag` library is setup, certain bundlers\n// can't find the properties added to the exported `gql` function without\n// additional guidance (e.g. Rollup - see\n// https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module).\n// Instead of having people that are using bundlers with `@apollo/client` add\n// extra bundler config to help `graphql-tag` exports be found (which would be\n// awkward since they aren't importing `graphql-tag` themselves), this\n// workaround of pulling the extra properties off the `gql` function,\n// then re-exporting them separately, helps keeps bundlers happy without any\n// additional config changes.\nexport { gql, resetCaches, disableFragmentWarnings, enableExperimentalFragmentVariables, disableExperimentalFragmentVariables, } from \"graphql-tag\";\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AACA,IAAI,iBAAiB;AACrB,IAAI,KAAK,OAAO;AAAhB,IAAgC,iBAAiB,OAAO,SAAS,SAAU,KAAK,OAAO;AACnF,MAAI,YAAY;AAChB,SAAO;AACX,IAAI;AACJ,IAAI;AAAA;AAAA,EAAgC,SAAU,QAAQ;AAClD,cAAUA,iBAAgB,MAAM;AAChC,aAASA,gBAAe,SAAS;AAC7B,UAAI,YAAY,QAAQ;AAAE,kBAAU;AAAA,MAAgB;AACpD,UAAI,QAAQ,OAAO,KAAK,MAAM,OAAO,YAAY,WAC3C,iBAAiB,OAAO,UAAU,+DAClC,OAAO,KAAK;AAClB,YAAM,cAAc;AACpB,YAAM,OAAO;AACb,qBAAe,OAAOA,gBAAe,SAAS;AAC9C,aAAO;AAAA,IACX;AACA,WAAOA;AAAA,EACX,EAAE,KAAK;AAAA;AAEA,SAAS,UAAU,WAAW,SAAS;AAC1C,MAAI,CAAC,WAAW;AACZ,UAAM,IAAI,eAAe,OAAO;AAAA,EACpC;AACJ;AACA,IAAI,kBAAkB,CAAC,SAAS,OAAO,QAAQ,SAAS,QAAQ;AAChE,IAAI,iBAAiB,gBAAgB,QAAQ,KAAK;AAClD,SAAS,kBAAkB,MAAM;AAC7B,SAAO,WAAY;AACf,QAAI,gBAAgB,QAAQ,IAAI,KAAK,gBAAgB;AAGjD,UAAI,SAAS,QAAQ,IAAI,KAAK,QAAQ;AACtC,aAAO,OAAO,MAAM,SAAS,SAAS;AAAA,IAC1C;AAAA,EACJ;AACJ;AAAA,CACC,SAAUC,YAAW;AAClB,EAAAA,WAAU,QAAQ,kBAAkB,OAAO;AAC3C,EAAAA,WAAU,MAAM,kBAAkB,KAAK;AACvC,EAAAA,WAAU,OAAO,kBAAkB,MAAM;AACzC,EAAAA,WAAU,QAAQ,kBAAkB,OAAO;AAC/C,GAAG,cAAc,YAAY,CAAC,EAAE;AACzB,SAAS,aAAa,OAAO;AAChC,MAAI,MAAM,gBAAgB,cAAc;AACxC,mBAAiB,KAAK,IAAI,GAAG,gBAAgB,QAAQ,KAAK,CAAC;AAC3D,SAAO;AACX;;;AChDO,IAAI,UAAU;;;ACAd,SAAS,MAAM,OAAO;AACzB,MAAI;AACA,WAAO,MAAM;AAAA,EACjB,SACOC,KAAI;AAAA,EAAE;AACjB;;;ACJA,IAAO,iBAAS,MAAM,WAAY;AAAE,SAAO;AAAY,CAAC,KACpD,MAAM,WAAY;AAAE,SAAO;AAAQ,CAAC,KACpC,MAAM,WAAY;AAAE,SAAO;AAAM,CAAC,KAClC,MAAM,WAAY;AAAE,SAAO;AAAQ,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAMxC,MAAM,WAAY;AACd,SAAO,MAAM,YAAY,aAAa,EAAE;AAC5C,CAAC;;;ACZD,IAAI,eAAe,oBAAI,IAAI;AAGpB,SAAS,aAAa,QAAQ;AACjC,MAAI,QAAQ,aAAa,IAAI,MAAM,KAAK;AACxC,eAAa,IAAI,QAAQ,QAAQ,CAAC;AAClC,SAAO,GAAG,OAAO,QAAQ,GAAG,EAAE,OAAO,OAAO,GAAG,EAAE,OAAO,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC;AAC/F;;;ACNO,SAAS,oBAAoB,OAAO,OAAO;AAC9C,MAAI,UAAU,QAAQ;AAAE,YAAQ;AAAA,EAAG;AACnC,MAAI,UAAU,aAAa,qBAAqB;AAChD,SAAO,KAAK,UAAU,OAAO,SAAU,KAAKC,QAAO;AAC/C,WAAOA,WAAU,SAAS,UAAUA;AAAA,EACxC,GAAG,KAAK,EACH,MAAM,KAAK,UAAU,OAAO,CAAC,EAC7B,KAAK,aAAa;AAC3B;;;ACLA,SAAS,KAAK,IAAI;AACd,SAAO,SAAU,SAAS;AACtB,QAAI,OAAO,CAAC;AACZ,aAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,WAAK,KAAK,CAAC,IAAI,UAAU,EAAE;AAAA,IAC/B;AACA,QAAI,OAAO,YAAY,UAAU;AAC7B,UAAI,OAAO;AACX,gBAAU,mBAAmB,IAAI;AACjC,UAAI,CAAC,SAAS;AACV,kBAAU,oBAAoB,MAAM,IAAI;AACxC,eAAO,CAAC;AAAA,MACZ;AAAA,IACJ;AACA,OAAG,MAAM,QAAQ,CAAC,OAAO,EAAE,OAAO,IAAI,CAAC;AAAA,EAC3C;AACJ;AACA,IAAIC,aAAY,OAAO,OAAO,SAASA,WAAU,WAAW,SAAS;AACjE,MAAI,OAAO,CAAC;AACZ,WAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,SAAK,KAAK,CAAC,IAAI,UAAU,EAAE;AAAA,EAC/B;AACA,MAAI,CAAC,WAAW;AACZ,cAAkB,WAAW,mBAAmB,SAAS,IAAI,KAAK,oBAAoB,SAAS,IAAI,CAAC;AAAA,EACxG;AACJ,GAAG;AAAA,EACC,OAAO,KAAK,UAAkB,KAAK;AAAA,EACnC,KAAK,KAAK,UAAkB,GAAG;AAAA,EAC/B,MAAM,KAAK,UAAkB,IAAI;AAAA,EACjC,OAAO,KAAK,UAAkB,KAAK;AACvC,CAAC;AAWD,SAAS,kBAAkB,SAAS;AAChC,MAAI,iBAAiB,CAAC;AACtB,WAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,mBAAe,KAAK,CAAC,IAAI,UAAU,EAAE;AAAA,EACzC;AACA,SAAO,IAAI,eAAe,mBAAmB,SAAS,cAAc,KAChE,oBAAoB,SAAS,cAAc,CAAC;AACpD;AACA,IAAI,4BAA4B,OAAO,IAAI,+BAA+B,OAAO;AACjF,SAAS,UAAU,KAAK;AACpB,SAAO,OAAO,OAAO,WAAW,MAAO,oBAAoB,KAAK,CAAC,EAAE,MAAM,GAAG,GAAI;AACpF;AACA,SAAS,mBAAmB,SAAS,aAAa;AAC9C,MAAI,gBAAgB,QAAQ;AAAE,kBAAc,CAAC;AAAA,EAAG;AAChD,MAAI,CAAC;AACD;AACJ,SAAQ,eAAO,yBAAyB,KACpC,eAAO,yBAAyB,EAAE,SAAS,YAAY,IAAI,SAAS,CAAC;AAC7E;AACA,SAAS,oBAAoB,SAAS,aAAa;AAC/C,MAAI,gBAAgB,QAAQ;AAAE,kBAAc,CAAC;AAAA,EAAG;AAChD,MAAI,CAAC;AACD;AACJ,SAAO,+FAA+F,OAAO,mBAAmB,KAAK,UAAU;AAAA,IAC3I;AAAA,IACA;AAAA,IACA,MAAM,YAAY,IAAI,SAAS;AAAA,EACnC,CAAC,CAAC,CAAC;AACP;;;AC9DO,IAAI,MAAM,WAAW,YAAY;;;ACTjC,SAAS,cAAcC,KAAI,WAAW;AACzC,MAAI,aAAaA,IAAG;AACpB,MAAI,CAAC,cAAc,CAAC,WAAW,QAAQ;AACnC,WAAO;AAAA,EACX;AACA,SAAO,uBAAuB,UAAU,EAAE,MAAM,SAAUA,KAAI;AAC1D,QAAI,YAAYA,IAAG,WAAW,aAAaA,IAAG;AAC9C,QAAI,cAAc;AAClB,QAAI,WAAW,MAAM,SAAS,YAAY;AACtC,oBACI,aAAa,UAAU,WAAW,MAAM,KAAK,KAAK;AACtD,MAAAC,WAAU,gBAAgB,QAAQ,IAAI,UAAU,KAAK,KAAK;AAAA,IAC9D,OACK;AACD,oBAAc,WAAW,MAAM;AAAA,IACnC;AACA,WAAO,UAAU,KAAK,UAAU,SAAS,CAAC,cAAc;AAAA,EAC5D,CAAC;AACL;AAgBO,SAAS,cAAc,OAAOC,OAAM,KAAK;AAC5C,MAAI,UAAU,IAAI,IAAI,KAAK;AAC3B,MAAI,cAAc,QAAQ;AAC1B,QAAMA,OAAM;AAAA,IACR,WAAW,SAAU,MAAM;AACvB,UAAI,QAAQ,OAAO,KAAK,KAAK,KAAK,MAAM,CAAC,OAAO,CAAC,QAAQ,OAAO;AAC5D,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ,CAAC;AAGD,SAAO,MAAM,CAAC,QAAQ,OAAO,QAAQ,OAAO;AAChD;AACO,SAAS,iBAAiB,UAAU;AACvC,SAAO,YAAY,cAAc,CAAC,UAAU,QAAQ,GAAG,UAAU,IAAI;AACzE;AACA,SAAS,qBAAqBC,KAAI;AAC9B,MAAI,QAAQA,IAAG,KAAK;AACpB,SAAO,UAAU,UAAU,UAAU;AACzC;AACO,SAAS,uBAAuB,YAAY;AAC/C,MAAIC,UAAS,CAAC;AACd,MAAI,cAAc,WAAW,QAAQ;AACjC,eAAW,QAAQ,SAAU,WAAW;AACpC,UAAI,CAAC,qBAAqB,SAAS;AAC/B;AACJ,UAAI,qBAAqB,UAAU;AACnC,UAAI,gBAAgB,UAAU,KAAK;AACnC,MAAAC,WAAU,sBAAsB,mBAAmB,WAAW,GAAG,IAAI,aAAa;AAClF,UAAI,aAAa,mBAAmB,CAAC;AACrC,MAAAA,WAAU,WAAW,QAAQ,WAAW,KAAK,UAAU,MAAM,IAAI,aAAa;AAC9E,UAAI,UAAU,WAAW;AAEzB,MAAAA,WAAU,YACL,QAAQ,SAAS,cAAc,QAAQ,SAAS,iBAAiB,IAAI,aAAa;AACvF,MAAAD,QAAO,KAAK,EAAE,WAAsB,WAAuB,CAAC;AAAA,IAChE,CAAC;AAAA,EACL;AACA,SAAOA;AACX;;;ACvEA,IAAM,kBAAkB,MAAM,uBAAO,OAAO,IAAI;AAEhD,IAAM,EAAE,SAAS,MAAM,IAAI,MAAM;AACjC,IAAM,EAAE,eAAe,IAAI,OAAO;AAC3B,IAAM,OAAN,MAAM,MAAK;AAAA,EACd,YAAY,WAAW,MAAM,WAAW,iBAAiB;AACrD,SAAK,WAAW;AAChB,SAAK,WAAW;AAAA,EACpB;AAAA,EACA,SAAS;AACL,WAAO,KAAK,YAAY,SAAS;AAAA,EACrC;AAAA,EACA,YAAY,OAAO;AACf,QAAI,OAAO;AACX,YAAQ,KAAK,OAAO,SAAO,OAAO,KAAK,aAAa,GAAG,CAAC;AACxD,WAAO,eAAe,KAAK,MAAM,MAAM,IACjC,KAAK,OACL,KAAK,OAAO,KAAK,SAAS,MAAM,KAAK,KAAK,CAAC;AAAA,EACrD;AAAA,EACA,OAAO;AACH,WAAO,KAAK,UAAU,SAAS;AAAA,EACnC;AAAA,EACA,UAAU,OAAO;AACb,QAAI,OAAO;AACX,aAAS,IAAI,GAAG,MAAM,MAAM,QAAQ,QAAQ,IAAI,KAAK,EAAE,GAAG;AACtD,YAAM,MAAM,KAAK,OAAO,MAAM,CAAC,GAAG,KAAK;AACvC,aAAO,OAAO,IAAI,IAAI,MAAM,CAAC,CAAC;AAAA,IAClC;AACA,WAAO,QAAQ,KAAK;AAAA,EACxB;AAAA,EACA,SAAS;AACL,WAAO,KAAK,YAAY,SAAS;AAAA,EACrC;AAAA,EACA,YAAY,OAAO;AACf,QAAI;AACJ,QAAI,MAAM,QAAQ;AACd,YAAM,OAAO,MAAM,CAAC;AACpB,YAAM,MAAM,KAAK,OAAO,MAAM,KAAK;AACnC,YAAM,QAAQ,OAAO,IAAI,IAAI,IAAI;AACjC,UAAI,OAAO;AACP,eAAO,MAAM,YAAY,MAAM,KAAK,OAAO,CAAC,CAAC;AAC7C,YAAI,CAAC,MAAM,QAAQ,CAAC,MAAM,QAAQ,EAAE,MAAM,UAAU,MAAM,OAAO,OAAO;AACpE,cAAI,OAAO,IAAI;AAAA,QACnB;AAAA,MACJ;AAAA,IACJ,OACK;AACD,aAAO,KAAK;AACZ,aAAO,KAAK;AAAA,IAChB;AACA,WAAO;AAAA,EACX;AAAA,EACA,aAAa,KAAK;AACd,UAAM,MAAM,KAAK,OAAO,KAAK,IAAI;AACjC,QAAI,QAAQ,IAAI,IAAI,GAAG;AACvB,QAAI,CAAC;AACD,UAAI,IAAI,KAAK,QAAQ,IAAI,MAAK,KAAK,UAAU,KAAK,QAAQ,CAAC;AAC/D,WAAO;AAAA,EACX;AAAA,EACA,OAAO,KAAK,QAAQ;AAChB,WAAO,KAAK,YAAY,SAAS,GAAG,IAC9B,KAAK,SAAS,SAAS,KAAK,OAAO,oBAAI,YAAU,UACjD,KAAK,WAAW,SAAS,KAAK,SAAS,oBAAI,QAAM;AAAA,EAC3D;AACJ;AACA,SAAS,SAAS,OAAO;AACrB,UAAQ,OAAO,OAAO;AAAA,IAClB,KAAK;AACD,UAAI,UAAU;AACV;AAAA,IAER,KAAK;AACD,aAAO;AAAA,EACf;AACA,SAAO;AACX;;;AC/EO,IAAI,gBAAgB,OAAO,YAAY,cAC1C,MAAM,WAAY;AAAE,SAAO,UAAU;AAAS,CAAC,MAAM;AAClD,IAAI,gBAAgB,OAAO,YAAY;AACvC,IAAI,eAAe,OAAO,WAAW,cAAc,OAAO,OAAO,QAAQ;AACzE,IAAI,4BAA4B,gBAAgB,OAAO;AACvD,IAAI,YAAY,OAAO,MAAM,WAAY;AAAE,SAAO,OAAO,SAAS;AAAe,CAAC,MAAM;AAC/F,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASJ,MAAM,WAAY;AAAE,WAAO,UAAU,UAAU,QAAQ,OAAO,KAAK;AAAA,EAAG,CAAC,KAAK;AAAA;;;AChBrE,SAAS,gBAAgB,KAAK;AACjC,SAAO,QAAQ,QAAQ,OAAO,QAAQ;AAC1C;;;ACsBO,SAAS,yBAAyB,UAAU,cAAc;AAC7D,MAAI,qBAAqB;AAIzB,MAAI,YAAY,CAAC;AACjB,WAAS,YAAY,QAAQ,SAAU,YAAY;AAG/C,QAAI,WAAW,SAAS,uBAAuB;AAC3C,YAAM;AAAA,QACF;AAAA,QACA,WAAW;AAAA,QACX,WAAW,OAAO,WAAW,OAAO,WAAW,KAAK,OAAO,GAAG,IAAI;AAAA,MACtE;AAAA,IACJ;AAGA,QAAI,WAAW,SAAS,sBAAsB;AAC1C,gBAAU,KAAK,UAAU;AAAA,IAC7B;AAAA,EACJ,CAAC;AAGD,MAAI,OAAO,uBAAuB,aAAa;AAC3C,IAAAE,WAAU,UAAU,WAAW,GAAG,IAAI,UAAU,MAAM;AACtD,yBAAqB,UAAU,CAAC,EAAE,KAAK;AAAA,EAC3C;AAGA,MAAI,QAAQ,SAAS,SAAS,CAAC,GAAG,QAAQ,GAAG,EAAE,aAAa,cAAc;AAAA,IAClE;AAAA,MACI,MAAM;AAAA;AAAA,MAEN,WAAW;AAAA,MACX,cAAc;AAAA,QACV,MAAM;AAAA,QACN,YAAY;AAAA,UACR;AAAA,YACI,MAAM;AAAA,YACN,MAAM;AAAA,cACF,MAAM;AAAA,cACN,OAAO;AAAA,YACX;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ,GAAG,SAAS,aAAa,IAAI,EAAE,CAAC;AACpC,SAAO;AACX;AAGO,SAAS,kBAAkB,WAAW;AACzC,MAAI,cAAc,QAAQ;AAAE,gBAAY,CAAC;AAAA,EAAG;AAC5C,MAAI,WAAW,CAAC;AAChB,YAAU,QAAQ,SAAU,UAAU;AAClC,aAAS,SAAS,KAAK,KAAK,IAAI;AAAA,EACpC,CAAC;AACD,SAAO;AACX;AACO,SAAS,yBAAyB,WAAW,aAAa;AAC7D,UAAQ,UAAU,MAAM;AAAA,IACpB,KAAK;AACD,aAAO;AAAA,IACX,KAAK,kBAAkB;AACnB,UAAI,eAAe,UAAU,KAAK;AAClC,UAAI,OAAO,gBAAgB,YAAY;AACnC,eAAO,YAAY,YAAY;AAAA,MACnC;AACA,UAAI,WAAW,eAAe,YAAY,YAAY;AACtD,MAAAA,WAAU,UAAU,IAAI,YAAY;AACpC,aAAO,YAAY;AAAA,IACvB;AAAA,IACA;AACI,aAAO;AAAA,EACf;AACJ;;;AClGO,SAAS,cAAc,IAAI;AAC9B,SAAO,EAAE,OAAO,OAAO,EAAE,EAAE;AAC/B;AACO,SAAS,YAAY,KAAK;AAC7B,SAAO,QAAQ,OAAO,OAAO,QAAQ,YAAY,OAAO,IAAI,UAAU,QAAQ;AAClF;AACO,SAAS,eAAe,OAAO;AAClC,SAAQ,gBAAgB,KAAK,KACzB,MAAM,SAAS,cACf,MAAM,QAAQ,MAAM,WAAW;AACvC;AACA,SAAS,cAAc,OAAO;AAC1B,SAAO,MAAM,SAAS;AAC1B;AACA,SAAS,eAAe,OAAO;AAC3B,SAAO,MAAM,SAAS;AAC1B;AACA,SAAS,WAAW,OAAO;AACvB,SAAO,MAAM,SAAS;AAC1B;AACA,SAAS,aAAa,OAAO;AACzB,SAAO,MAAM,SAAS;AAC1B;AACA,SAAS,WAAW,OAAO;AACvB,SAAO,MAAM,SAAS;AAC1B;AACA,SAAS,cAAc,OAAO;AAC1B,SAAO,MAAM,SAAS;AAC1B;AACA,SAAS,YAAY,OAAO;AACxB,SAAO,MAAM,SAAS;AAC1B;AACA,SAAS,YAAY,OAAO;AACxB,SAAO,MAAM,SAAS;AAC1B;AACA,SAAS,YAAY,OAAO;AACxB,SAAO,MAAM,SAAS;AAC1B;AACO,SAAS,4BAA4B,QAAQ,MAAM,OAAO,WAAW;AACxE,MAAI,WAAW,KAAK,KAAK,aAAa,KAAK,GAAG;AAC1C,WAAO,KAAK,KAAK,IAAI,OAAO,MAAM,KAAK;AAAA,EAC3C,WACS,eAAe,KAAK,KAAK,cAAc,KAAK,GAAG;AACpD,WAAO,KAAK,KAAK,IAAI,MAAM;AAAA,EAC/B,WACS,cAAc,KAAK,GAAG;AAC3B,QAAI,iBAAiB,CAAC;AACtB,UAAM,OAAO,IAAI,SAAU,KAAK;AAC5B,aAAO,4BAA4B,gBAAgB,IAAI,MAAM,IAAI,OAAO,SAAS;AAAA,IACrF,CAAC;AACD,WAAO,KAAK,KAAK,IAAI;AAAA,EACzB,WACS,WAAW,KAAK,GAAG;AACxB,QAAI,iBAAiB,aAAa,CAAC,GAAG,MAAM,KAAK,KAAK;AACtD,WAAO,KAAK,KAAK,IAAI;AAAA,EACzB,WACS,YAAY,KAAK,GAAG;AACzB,WAAO,KAAK,KAAK,IAAI,MAAM,OAAO,IAAI,SAAU,WAAW;AACvD,UAAI,oBAAoB,CAAC;AACzB,kCAA4B,mBAAmB,MAAM,WAAW,SAAS;AACzE,aAAO,kBAAkB,KAAK,KAAK;AAAA,IACvC,CAAC;AAAA,EACL,WACS,YAAY,KAAK,GAAG;AACzB,WAAO,KAAK,KAAK,IAAI,MAAM;AAAA,EAC/B,WACS,YAAY,KAAK,GAAG;AACzB,WAAO,KAAK,KAAK,IAAI;AAAA,EACzB,OACK;AACD,UAAM,kBAAkB,IAAI,KAAK,OAAO,MAAM,IAAI;AAAA,EACtD;AACJ;AACO,SAAS,sBAAsB,OAAO,WAAW;AACpD,MAAI,gBAAgB;AACpB,MAAI,MAAM,YAAY;AAClB,oBAAgB,CAAC;AACjB,UAAM,WAAW,QAAQ,SAAU,WAAW;AAC1C,oBAAc,UAAU,KAAK,KAAK,IAAI,CAAC;AACvC,UAAI,UAAU,WAAW;AACrB,kBAAU,UAAU,QAAQ,SAAUC,KAAI;AACtC,cAAI,OAAOA,IAAG,MAAM,QAAQA,IAAG;AAC/B,iBAAO,4BAA4B,cAAc,UAAU,KAAK,KAAK,GAAG,MAAM,OAAO,SAAS;AAAA,QAClG,CAAC;AAAA,MACL;AAAA,IACJ,CAAC;AAAA,EACL;AACA,MAAI,SAAS;AACb,MAAI,MAAM,aAAa,MAAM,UAAU,QAAQ;AAC3C,aAAS,CAAC;AACV,UAAM,UAAU,QAAQ,SAAUA,KAAI;AAClC,UAAI,OAAOA,IAAG,MAAM,QAAQA,IAAG;AAC/B,aAAO,4BAA4B,QAAQ,MAAM,OAAO,SAAS;AAAA,IACrE,CAAC;AAAA,EACL;AACA,SAAO,gBAAgB,MAAM,KAAK,OAAO,QAAQ,aAAa;AAClE;AACA,IAAI,mBAAmB;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AACO,IAAI,kBAAkB,OAAO,OAAO,SAAU,WAAW,MAAM,YAAY;AAC9E,MAAI,QACA,cACA,WAAW,YAAY,KACvB,WAAW,YAAY,EAAE,KAAK,GAAG;AACjC,QAAI,WAAW,YAAY,EAAE,QAAQ,KACjC,WAAW,YAAY,EAAE,QAAQ,EAAE,SAAS,GAAG;AAC/C,UAAI,aAAa,WAAW,YAAY,EAAE,QAAQ,IAC9C,WAAW,YAAY,EAAE,QAAQ,IAC/B,CAAC;AACP,iBAAW,KAAK;AAChB,UAAI,iBAAiB,CAAC;AACtB,iBAAW,QAAQ,SAAU,KAAK;AAC9B,uBAAe,GAAG,IAAI,KAAK,GAAG;AAAA,MAClC,CAAC;AACD,aAAO,GAAG,OAAO,WAAW,YAAY,EAAE,KAAK,GAAG,GAAG,EAAE,OAAOC,WAAU,cAAc,GAAG,GAAG;AAAA,IAChG,OACK;AACD,aAAO,WAAW,YAAY,EAAE,KAAK;AAAA,IACzC;AAAA,EACJ;AACA,MAAI,oBAAoB;AACxB,MAAI,MAAM;AAIN,QAAI,kBAAkBA,WAAU,IAAI;AACpC,yBAAqB,IAAI,OAAO,iBAAiB,GAAG;AAAA,EACxD;AACA,MAAI,YAAY;AACZ,WAAO,KAAK,UAAU,EAAE,QAAQ,SAAU,KAAK;AAC3C,UAAI,iBAAiB,QAAQ,GAAG,MAAM;AAClC;AACJ,UAAI,WAAW,GAAG,KAAK,OAAO,KAAK,WAAW,GAAG,CAAC,EAAE,QAAQ;AACxD,6BAAqB,IAAI,OAAO,KAAK,GAAG,EAAE,OAAOA,WAAU,WAAW,GAAG,CAAC,GAAG,GAAG;AAAA,MACpF,OACK;AACD,6BAAqB,IAAI,OAAO,GAAG;AAAA,MACvC;AAAA,IACJ,CAAC;AAAA,EACL;AACA,SAAO;AACX,GAAG;AAAA,EACC,cAAc,SAAU,GAAG;AACvB,QAAI,WAAWA;AACf,IAAAA,aAAY;AACZ,WAAO;AAAA,EACX;AACJ,CAAC;AAGD,IAAIA,aAAY,SAAS,iBAAiB,OAAO;AAC7C,SAAO,KAAK,UAAU,OAAO,iBAAiB;AAClD;AACA,SAAS,kBAAkB,MAAM,OAAO;AACpC,MAAI,gBAAgB,KAAK,KAAK,CAAC,MAAM,QAAQ,KAAK,GAAG;AACjD,YAAQ,OAAO,KAAK,KAAK,EACpB,KAAK,EACL,OAAO,SAAU,MAAM,KAAK;AAC7B,WAAK,GAAG,IAAI,MAAM,GAAG;AACrB,aAAO;AAAA,IACX,GAAG,CAAC,CAAC;AAAA,EACT;AACA,SAAO;AACX;AACO,SAAS,yBAAyB,OAAO,WAAW;AACvD,MAAI,MAAM,aAAa,MAAM,UAAU,QAAQ;AAC3C,QAAI,WAAW,CAAC;AAChB,UAAM,UAAU,QAAQ,SAAUD,KAAI;AAClC,UAAI,OAAOA,IAAG,MAAM,QAAQA,IAAG;AAC/B,aAAO,4BAA4B,UAAU,MAAM,OAAO,SAAS;AAAA,IACvE,CAAC;AACD,WAAO;AAAA,EACX;AACA,SAAO;AACX;AACO,SAAS,uBAAuB,OAAO;AAC1C,SAAO,MAAM,QAAQ,MAAM,MAAM,QAAQ,MAAM,KAAK;AACxD;AACO,SAAS,sBAAsBE,SAAQ,cAAc,aAAa;AACrE,MAAI;AACJ,WAAS,KAAK,GAAGF,MAAK,aAAa,YAAY,KAAKA,IAAG,QAAQ,MAAM;AACjE,QAAI,YAAYA,IAAG,EAAE;AACrB,QAAI,QAAQ,SAAS,GAAG;AACpB,UAAI,UAAU,KAAK,UAAU,cAAc;AACvC,eAAOE,QAAO,uBAAuB,SAAS,CAAC;AAAA,MACnD;AAAA,IACJ,WACS,WAAW;AAChB,gBAAU,KAAK,SAAS;AAAA,IAC5B,OACK;AACD,kBAAY,CAAC,SAAS;AAAA,IAC1B;AAAA,EACJ;AACA,MAAI,OAAOA,QAAO,eAAe,UAAU;AACvC,WAAOA,QAAO;AAAA,EAClB;AACA,MAAI,WAAW;AACX,aAAS,KAAK,GAAG,cAAc,WAAW,KAAK,YAAY,QAAQ,MAAM;AACrE,UAAI,YAAY,YAAY,EAAE;AAC9B,UAAI,WAAW,sBAAsBA,SAAQ,yBAAyB,WAAW,WAAW,EAAE,cAAc,WAAW;AACvH,UAAI,OAAO,aAAa,UAAU;AAC9B,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;AACJ;AACO,SAAS,QAAQ,WAAW;AAC/B,SAAO,UAAU,SAAS;AAC9B;AACO,SAAS,iBAAiB,WAAW;AACxC,SAAO,UAAU,SAAS;AAC9B;;;AC3NO,SAAS,cAAc,KAAK;AAC/B,EAAAC,WAAU,OAAO,IAAI,SAAS,YAAY,EAAE;AAC5C,MAAI,aAAa,IAAI,YAChB,OAAO,SAAU,GAAG;AAAE,WAAO,EAAE,SAAS;AAAA,EAAsB,CAAC,EAC/D,IAAI,SAAU,YAAY;AAC3B,QAAI,WAAW,SAAS,uBAAuB;AAC3C,YAAM,kBAAkB,IAAI,WAAW,IAAI;AAAA,IAC/C;AACA,WAAO;AAAA,EACX,CAAC;AACD,EAAAA,WAAU,WAAW,UAAU,GAAG,IAAI,WAAW,MAAM;AACvD,SAAO;AACX;AACO,SAAS,uBAAuB,KAAK;AACxC,gBAAc,GAAG;AACjB,SAAO,IAAI,YAAY,OAAO,SAAU,YAAY;AAChD,WAAO,WAAW,SAAS;AAAA,EAC/B,CAAC,EAAE,CAAC;AACR;AACO,SAAS,iBAAiB,KAAK;AAClC,SAAQ,IAAI,YACP,OAAO,SAAU,YAAY;AAC9B,WAAO,WAAW,SAAS,yBAAyB,CAAC,CAAC,WAAW;AAAA,EACrE,CAAC,EACI,IAAI,SAAU,GAAG;AAAE,WAAO,EAAE,KAAK;AAAA,EAAO,CAAC,EAAE,CAAC,KAAK;AAC1D;AAEO,SAAS,uBAAuB,KAAK;AACxC,SAAO,IAAI,YAAY,OAAO,SAAU,YAAY;AAChD,WAAO,WAAW,SAAS;AAAA,EAC/B,CAAC;AACL;AACO,SAAS,mBAAmB,KAAK;AACpC,MAAI,WAAW,uBAAuB,GAAG;AACzC,EAAAA,WAAU,YAAY,SAAS,cAAc,SAAS,EAAE;AACxD,SAAO;AACX;AACO,SAAS,sBAAsB,KAAK;AACvC,EAAAA,WAAU,IAAI,SAAS,YAAY,EAAE;AACrC,EAAAA,WAAU,IAAI,YAAY,UAAU,GAAG,EAAE;AACzC,MAAI,cAAc,IAAI,YAAY,CAAC;AACnC,EAAAA,WAAU,YAAY,SAAS,sBAAsB,EAAE;AACvD,SAAO;AACX;AAMO,SAAS,kBAAkB,UAAU;AACxC,gBAAc,QAAQ;AACtB,MAAI;AACJ,WAAS,KAAK,GAAGC,MAAK,SAAS,aAAa,KAAKA,IAAG,QAAQ,MAAM;AAC9D,QAAI,aAAaA,IAAG,EAAE;AACtB,QAAI,WAAW,SAAS,uBAAuB;AAC3C,UAAI,YAAY,WAAW;AAC3B,UAAI,cAAc,WACd,cAAc,cACd,cAAc,gBAAgB;AAC9B,eAAO;AAAA,MACX;AAAA,IACJ;AACA,QAAI,WAAW,SAAS,wBAAwB,CAAC,oBAAoB;AAGjE,2BAAqB;AAAA,IACzB;AAAA,EACJ;AACA,MAAI,oBAAoB;AACpB,WAAO;AAAA,EACX;AACA,QAAM,kBAAkB,EAAE;AAC9B;AACO,SAAS,iBAAiB,YAAY;AACzC,MAAI,gBAAgB,uBAAO,OAAO,IAAI;AACtC,MAAI,OAAO,cAAc,WAAW;AACpC,MAAI,QAAQ,KAAK,QAAQ;AACrB,SAAK,QAAQ,SAAU,KAAK;AACxB,UAAI,IAAI,cAAc;AAClB,oCAA4B,eAAe,IAAI,SAAS,MAAM,IAAI,YAAY;AAAA,MAClF;AAAA,IACJ,CAAC;AAAA,EACL;AACA,SAAO;AACX;;;ACnFA,SAAS,SAAS,UAAU;AACxB,SAAO;AACX;AACA,IAAI;AAAA;AAAA,EAAmC,WAAY;AAC/C,aAASC,mBAAkB,WAAW,SAAS;AAC3C,UAAI,YAAY,QAAQ;AAAE,kBAAU,uBAAO,OAAO,IAAI;AAAA,MAAG;AACzD,WAAK,cAAc,gBAAgB,oBAAI,QAAQ,IAAI,oBAAI,IAAI;AAC3D,WAAK,YAAY;AACjB,UAAI,QAAQ,aAAa;AAErB,aAAK,cAAc,QAAQ;AAAA,MAC/B;AACA,UAAI,QAAQ,UAAU,OAAO;AACzB,aAAK,kBAAkB,IAAI,KAAK,eAAe,SAAU,KAAK;AAAE,iBAAQ,EAAE,IAAS;AAAA,QAAI,CAAC;AAAA,MAC5F;AAAA,IACJ;AAMA,IAAAA,mBAAkB,UAAU,cAAc,SAAU,UAAU;AAC1D,aAAO,CAAC,QAAQ;AAAA,IACpB;AACA,IAAAA,mBAAkB,WAAW,WAAY;AAIrC,aAAO,IAAIA,mBAAkB,UAAU,EAAE,OAAO,MAAM,CAAC;AAAA,IAC3D;AACA,IAAAA,mBAAkB,QAAQ,SAAU,WAAW,MAAM,OAAO;AACxD,UAAI,UAAU,QAAQ;AAAE,gBAAQA,mBAAkB,SAAS;AAAA,MAAG;AAC9D,aAAO,IAAIA;AAAA,QAAkB,SAAU,UAAU;AAC7C,cAAI,oBAAoB,UAAU,QAAQ,IAAI,OAAO;AACrD,iBAAO,kBAAkB,kBAAkB,QAAQ;AAAA,QACvD;AAAA;AAAA,QAEA,EAAE,OAAO,MAAM;AAAA,MAAC;AAAA,IACpB;AACA,IAAAA,mBAAkB,UAAU,oBAAoB,SAAU,UAAU;AAGhE,UAAI,KAAK,YAAY,IAAI,QAAQ,GAAG;AAChC,eAAO;AAAA,MACX;AACA,UAAI,aAAa,KAAK,oBAAoB,QAAQ;AAClD,UAAI,cAAc,WAAW,OAAO;AAChC,eAAO,WAAW;AAAA,MACtB;AACA,oBAAc,QAAQ;AACtB,UAAI,sBAAsB,KAAK,UAAU,QAAQ;AACjD,WAAK,YAAY,IAAI,mBAAmB;AACxC,UAAI,YAAY;AACZ,mBAAW,QAAQ;AAAA,MACvB;AACA,aAAO;AAAA,IACX;AACA,IAAAA,mBAAkB,UAAU,SAAS,SAAU,gBAAgB;AAC3D,UAAI,QAAQ;AACZ,aAAO,IAAIA;AAAA,QAAkB,SAAU,UAAU;AAC7C,iBAAO,eAAe,kBAAkB,MAAM,kBAAkB,QAAQ,CAAC;AAAA,QAC7E;AAAA;AAAA,QAEA,EAAE,OAAO,MAAM;AAAA,MAAC;AAAA,IACpB;AACA,IAAAA,mBAAkB,UAAU,sBAAsB,SAAU,UAAU;AAClE,UAAI,CAAC,KAAK;AACN;AACJ,UAAI,YAAY,KAAK,YAAY,QAAQ;AACzC,UAAI,WAAW;AACX,QAAAC,WAAU,MAAM,QAAQ,SAAS,GAAG,EAAE;AACtC,eAAO,KAAK,gBAAgB,YAAY,SAAS;AAAA,MACrD;AAAA,IACJ;AACA,WAAOD;AAAA,EACX,EAAE;AAAA;;;AC7EF,IAAI,aAAa,gBAAgB,oBAAI,QAAQ,IAAI;AAC1C,IAAIE,SAAQ,SAAU,KAAK;AAC9B,MAAIC;AACJ,EAAAA,UAAS,eAAe,QAAQ,eAAe,SAAS,SAAS,WAAW,IAAI,GAAG;AACnF,MAAI,CAACA,SAAQ;AACT,IAAAA,UAAS,MAAU,GAAG;AACtB,mBAAe,QAAQ,eAAe,SAAS,SAAS,WAAW,IAAI,KAAKA,OAAM;AAAA,EACtF;AACA,SAAOA;AACX;;;ACVO,IAAI,UAAU,MAAM;AACpB,SAAS,gBAAgB,OAAO;AACnC,SAAO,MAAM,QAAQ,KAAK,KAAK,MAAM,SAAS;AAClD;;;ACGA,IAAI,iBAAiB;AAAA,EACjB,MAAM,KAAK;AAAA,EACX,MAAM;AAAA,IACF,MAAM,KAAK;AAAA,IACX,OAAO;AAAA,EACX;AACJ;AACA,SAAS,QAAQ,IAAI,aAAa;AAC9B,SAAQ,CAAC,MACL,GAAG,aAAa,WAAW,MAAM,SAAU,WAAW;AAClD,WAAO,UAAU,SAAS,KAAK,mBAC3B,QAAQ,YAAY,UAAU,KAAK,KAAK,GAAG,WAAW;AAAA,EAC9D,CAAC;AACT;AACA,SAAS,iBAAiB,KAAK;AAC3B,SAAQ,QAAQ,uBAAuB,GAAG,KAAK,sBAAsB,GAAG,GAAG,kBAAkB,uBAAuB,GAAG,CAAC,CAAC,IACrH,OACE;AACV;AACA,SAAS,oBAAoB,SAAS;AAClC,MAAI,QAAQ,oBAAI,IAAI;AACpB,MAAI,QAAQ,oBAAI,IAAI;AACpB,UAAQ,QAAQ,SAAU,WAAW;AACjC,QAAI,WAAW;AACX,UAAI,UAAU,MAAM;AAChB,cAAM,IAAI,UAAU,MAAM,SAAS;AAAA,MACvC,WACS,UAAU,MAAM;AACrB,cAAM,IAAI,UAAU,MAAM,SAAS;AAAA,MACvC;AAAA,IACJ;AAAA,EACJ,CAAC;AACD,SAAO,SAAU,WAAW;AACxB,QAAI,SAAS,MAAM,IAAI,UAAU,KAAK,KAAK;AAC3C,QAAI,CAAC,UAAU,MAAM,MAAM;AACvB,YAAM,QAAQ,SAAU,YAAY,MAAM;AACtC,YAAI,KAAK,SAAS,GAAG;AACjB,mBAAS;AAAA,QACb;AAAA,MACJ,CAAC;AAAA,IACL;AACA,WAAO;AAAA,EACX;AACJ;AACA,SAAS,wBAAwB,YAAY;AACzC,MAAI,MAAM,oBAAI,IAAI;AAClB,SAAO,SAAS,oBAAoB,KAAK;AACrC,QAAI,QAAQ,QAAQ;AAAE,YAAM;AAAA,IAAY;AACxC,QAAI,QAAQ,IAAI,IAAI,GAAG;AACvB,QAAI,CAAC,OAAO;AACR,UAAI,IAAI,KAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA,QAKlB,WAAW,oBAAI,IAAI;AAAA,QACnB,iBAAiB,oBAAI,IAAI;AAAA,MAC7B,CAAE;AAAA,IACN;AACA,WAAO;AAAA,EACX;AACJ;AACO,SAAS,6BAA6B,YAAY,KAAK;AAC1D,gBAAc,GAAG;AAKjB,MAAI,0BAA0B,wBAAwB,EAAE;AACxD,MAAI,yBAAyB,wBAAwB,EAAE;AACvD,MAAI,WAAW,SAAU,WAAW;AAChC,aAAS,IAAI,GAAG,WAAW,QAAQ,IAAI,UAAU,WAAW,WAAW,UAAU,CAAC,IAAI,EAAE,GAAG;AACvF,UAAI,QAAQ,QAAQ;AAChB;AACJ,UAAI,SAAS,SAAS,KAAK,sBAAsB;AAE7C,eAAO,wBAAwB,SAAS,QAAQ,SAAS,KAAK,KAAK;AAAA,MACvE;AACA,UAAI,SAAS,SAAS,KAAK,qBAAqB;AAC5C,eAAO,uBAAuB,SAAS,KAAK,KAAK;AAAA,MACrD;AAAA,IACJ;AACA,eAAW,YAAY,SAASC,WAAU,MAAM,EAAE;AAClD,WAAO;AAAA,EACX;AACA,MAAI,iBAAiB;AACrB,WAAS,IAAI,IAAI,YAAY,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AAClD,QAAI,IAAI,YAAY,CAAC,EAAE,SAAS,KAAK,sBAAsB;AACvD,QAAE;AAAA,IACN;AAAA,EACJ;AACA,MAAI,mBAAmB,oBAAoB,UAAU;AACrD,MAAI,oBAAoB,SAAU,gBAAgB;AAC9C,WAAO,gBAAgB,cAAc,KACjC,eACK,IAAI,gBAAgB,EACpB,KAAK,SAAU,QAAQ;AAAE,aAAO,UAAU,OAAO;AAAA,IAAQ,CAAC;AAAA,EACvE;AACA,MAAI,6BAA6B,oBAAI,IAAI;AAMzC,MAAI,wBAAwB;AAC5B,MAAI,+BAA+B;AAAA,IAC/B,OAAO,SAAU,MAAM;AACnB,UAAI,kBAAkB,KAAK,UAAU,GAAG;AACpC,gCAAwB;AACxB,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;AACA,MAAI,8BAA8B,MAAM,KAAK;AAAA;AAAA,IAEzC,OAAO;AAAA,IACP,gBAAgB;AAAA,IAChB,oBAAoB;AAAA,MAChB,OAAO,WAAY;AAKf,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,IACA,UAAU;AAAA,MACN,OAAO,SAAU,MAAM,MAAM,SAAS,OAAO,WAAW;AACpD,YAAI,QAAQ,SAAS,SAAS;AAC9B,YAAI,OAAO;AACP,gBAAM,UAAU,IAAI,KAAK,KAAK,KAAK;AAAA,QACvC;AAAA,MACJ;AAAA,IACJ;AAAA,IACA,gBAAgB;AAAA,MACZ,OAAO,SAAU,MAAM,MAAM,SAAS,OAAO,WAAW;AACpD,YAAI,kBAAkB,KAAK,UAAU,GAAG;AACpC,kCAAwB;AACxB,iBAAO;AAAA,QACX;AACA,YAAI,QAAQ,SAAS,SAAS;AAC9B,YAAI,OAAO;AACP,gBAAM,gBAAgB,IAAI,KAAK,KAAK,KAAK;AAAA,QAC7C;AAAA,MAMJ;AAAA,IACJ;AAAA,IACA,oBAAoB;AAAA,MAChB,OAAO,SAAU,MAAM,MAAM,SAAS,MAAM;AACxC,mCAA2B,IAAI,KAAK,UAAU,IAAI,GAAG,IAAI;AAAA,MAC7D;AAAA,MACA,OAAO,SAAU,MAAM,MAAM,SAAS,MAAM;AACxC,YAAI,eAAe,2BAA2B,IAAI,KAAK,UAAU,IAAI,CAAC;AACtE,YAAI,SAAS,cAAc;AAOvB,iBAAO;AAAA,QACX;AACA;AAAA;AAAA;AAAA;AAAA,UAIA,iBAAiB,KACb,KAAK,aAAa,WAAW,MAAM,SAAU,WAAW;AACpD,mBAAO,UAAU,SAAS,KAAK,SAC3B,UAAU,KAAK,UAAU;AAAA,UACjC,CAAC;AAAA,UAAG;AAIJ,iCAAuB,KAAK,KAAK,KAAK,EAAE,UAAU;AAClD,kCAAwB;AACxB,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AAAA,IACA,WAAW;AAAA,MACP,OAAO,SAAU,MAAM;AAInB,YAAI,iBAAiB,IAAI,GAAG;AACxB,kCAAwB;AACxB,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ,CAAC;AACD,MAAI,CAAC,uBAAuB;AAGxB,WAAO;AAAA,EACX;AAMA,MAAI,yBAAyB,SAAU,OAAO;AAC1C,QAAI,CAAC,MAAM,gBAAgB;AACvB,YAAM,iBAAiB,IAAI,IAAI,MAAM,SAAS;AAC9C,UAAI,CAAC,MAAM,SAAS;AAChB,cAAM,gBAAgB,QAAQ,SAAU,mBAAmB;AACvD,iCAAuB,uBAAuB,iBAAiB,CAAC,EAAE,eAAe,QAAQ,SAAU,SAAS;AACxG,kBAAM,eAAe,IAAI,OAAO;AAAA,UACpC,CAAC;AAAA,QACL,CAAC;AAAA,MACL;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAIA,MAAI,uBAAuB,oBAAI,IAAI;AACnC,8BAA4B,YAAY,QAAQ,SAAU,KAAK;AAC3D,QAAI,IAAI,SAAS,KAAK,sBAAsB;AACxC,6BAAuB,wBAAwB,IAAI,QAAQ,IAAI,KAAK,KAAK,CAAC,EAAE,gBAAgB,QAAQ,SAAU,mBAAmB;AAC7H,6BAAqB,IAAI,iBAAiB;AAAA,MAC9C,CAAC;AAAA,IACL,WACS,IAAI,SAAS,KAAK;AAAA;AAAA;AAAA;AAAA,IAKvB,mBAAmB,KACnB,CAAC,uBAAuB,IAAI,KAAK,KAAK,EAAE,SAAS;AACjD,2BAAqB,IAAI,IAAI,KAAK,KAAK;AAAA,IAC3C;AAAA,EACJ,CAAC;AAID,uBAAqB,QAAQ,SAAU,cAAc;AAGjD,2BAAuB,uBAAuB,YAAY,CAAC,EAAE,gBAAgB,QAAQ,SAAU,mBAAmB;AAC9G,2BAAqB,IAAI,iBAAiB;AAAA,IAC9C,CAAC;AAAA,EACL,CAAC;AACD,MAAI,wBAAwB,SAAU,cAAc;AAChD,WAAO,CAAC;AAAA;AAAA;AAAA,KAIP,CAAC,qBAAqB,IAAI,YAAY,KACnC,uBAAuB,YAAY,EAAE;AAAA,EAC7C;AACA,MAAI,eAAe;AAAA,IACf,OAAO,SAAU,MAAM;AACnB,UAAI,sBAAsB,KAAK,KAAK,KAAK,GAAG;AACxC,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;AACA,SAAO,iBAAiB,MAAM,6BAA6B;AAAA;AAAA;AAAA,IAGvD,gBAAgB;AAAA;AAAA,IAEhB,oBAAoB;AAAA,IACpB,qBAAqB;AAAA,MACjB,OAAO,SAAU,MAAM;AAGnB,YAAI,KAAK,qBAAqB;AAC1B,cAAI,sBAAsB;AAAA;AAAA,YAE1B,wBAAwB,KAAK,QAAQ,KAAK,KAAK,KAAK;AAAA,UAAC,EAAE;AAYvD,cAAI,oBAAoB,OAAO,KAAK,oBAAoB,QAAQ;AAC5D,mBAAO,SAAS,SAAS,CAAC,GAAG,IAAI,GAAG,EAAE,qBAAqB,KAAK,oBAAoB,OAAO,SAAU,QAAQ;AACrG,qBAAO,oBAAoB,IAAI,OAAO,SAAS,KAAK,KAAK;AAAA,YAC7D,CAAC,EAAE,CAAC;AAAA,UACZ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ,CAAC,CAAC;AACN;AACO,IAAI,wBAAwB,OAAO,OAAO,SAAU,KAAK;AAC5D,SAAO,MAAM,KAAK;AAAA,IACd,cAAc;AAAA,MACV,OAAO,SAAU,MAAM,MAAM,QAAQ;AAEjC,YAAI,UACA,OAAO,SACH,KAAK,sBAAsB;AAC/B;AAAA,QACJ;AAEA,YAAI,aAAa,KAAK;AACtB,YAAI,CAAC,YAAY;AACb;AAAA,QACJ;AAGA,YAAI,OAAO,WAAW,KAAK,SAAU,WAAW;AAC5C,iBAAQ,QAAQ,SAAS,MACpB,UAAU,KAAK,UAAU,gBACtB,UAAU,KAAK,MAAM,YAAY,MAAM,CAAC,MAAM;AAAA,QAC1D,CAAC;AACD,YAAI,MAAM;AACN;AAAA,QACJ;AAGA,YAAI,QAAQ;AACZ,YAAI,QAAQ,KAAK,KACb,MAAM,cACN,MAAM,WAAW,KAAK,SAAU,GAAG;AAAE,iBAAO,EAAE,KAAK,UAAU;AAAA,QAAU,CAAC,GAAG;AAC3E;AAAA,QACJ;AAEA,eAAO,SAAS,SAAS,CAAC,GAAG,IAAI,GAAG,EAAE,YAAY,cAAc,cAAc,CAAC,GAAG,YAAY,IAAI,GAAG,CAAC,cAAc,GAAG,KAAK,EAAE,CAAC;AAAA,MACnI;AAAA,IACJ;AAAA,EACJ,CAAC;AACL,GAAG;AAAA,EACC,OAAO,SAAU,OAAO;AACpB,WAAO,UAAU;AAAA,EACrB;AACJ,CAAC;AAyGM,SAAS,2BAA2B,UAAU;AACjD,MAAI,aAAa,kBAAkB,QAAQ;AAC3C,MAAI,sBAAsB,WAAW;AACrC,MAAI,wBAAwB,SAAS;AAEjC,WAAO;AAAA,EACX;AAEA,MAAI,cAAc,MAAM,UAAU;AAAA,IAC9B,qBAAqB;AAAA,MACjB,OAAO,SAAU,MAAM;AACnB,eAAO,SAAS,SAAS,CAAC,GAAG,IAAI,GAAG,EAAE,WAAW,QAAQ,CAAC;AAAA,MAC9D;AAAA,IACJ;AAAA,EACJ,CAAC;AACD,SAAO;AACX;AAEO,SAAS,6BAA6B,UAAU;AACnD,gBAAc,QAAQ;AACtB,MAAI,cAAc,6BAA6B;AAAA,IAC3C;AAAA,MACI,MAAM,SAAU,WAAW;AAAE,eAAO,UAAU,KAAK,UAAU;AAAA,MAAU;AAAA,MACvE,QAAQ;AAAA,IACZ;AAAA,EACJ,GAAG,QAAQ;AACX,SAAO;AACX;;;AC9dA,IAAIC,kBAAiB,OAAO,UAAU;AAC/B,SAAS,YAAY;AACxB,MAAI,UAAU,CAAC;AACf,WAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,YAAQ,EAAE,IAAI,UAAU,EAAE;AAAA,EAC9B;AACA,SAAO,eAAe,OAAO;AACjC;AAOO,SAAS,eAAe,SAAS;AACpC,MAAI,SAAS,QAAQ,CAAC,KAAK,CAAC;AAC5B,MAAI,QAAQ,QAAQ;AACpB,MAAI,QAAQ,GAAG;AACX,QAAI,SAAS,IAAI,WAAW;AAC5B,aAAS,IAAI,GAAG,IAAI,OAAO,EAAE,GAAG;AAC5B,eAAS,OAAO,MAAM,QAAQ,QAAQ,CAAC,CAAC;AAAA,IAC5C;AAAA,EACJ;AACA,SAAO;AACX;AACA,IAAI,oBAAoB,SAAU,QAAQ,QAAQ,UAAU;AACxD,SAAO,KAAK,MAAM,OAAO,QAAQ,GAAG,OAAO,QAAQ,CAAC;AACxD;AACA,IAAI;AAAA;AAAA,EAA4B,WAAY;AACxC,aAASC,YAAW,YAAY;AAC5B,UAAI,eAAe,QAAQ;AAAE,qBAAa;AAAA,MAAmB;AAC7D,WAAK,aAAa;AAClB,WAAK,WAAW;AAChB,WAAK,aAAa,oBAAI,IAAI;AAAA,IAC9B;AACA,IAAAA,YAAW,UAAU,QAAQ,SAAU,QAAQ,QAAQ;AACnD,UAAI,QAAQ;AACZ,UAAI,UAAU,CAAC;AACf,eAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,gBAAQ,KAAK,CAAC,IAAI,UAAU,EAAE;AAAA,MAClC;AACA,UAAI,gBAAgB,MAAM,KAAK,gBAAgB,MAAM,GAAG;AACpD,eAAO,KAAK,MAAM,EAAE,QAAQ,SAAU,WAAW;AAC7C,cAAID,gBAAe,KAAK,QAAQ,SAAS,GAAG;AACxC,gBAAI,cAAc,OAAO,SAAS;AAClC,gBAAI,OAAO,SAAS,MAAM,aAAa;AACnC,kBAAIE,UAAS,MAAM,WAAW,MAAM,OAAO,cAAc;AAAA,gBAAC;AAAA,gBACtD;AAAA,gBACA;AAAA,cAAS,GAAG,SAAS,KAAK,CAAC;AAG/B,kBAAIA,YAAW,aAAa;AACxB,yBAAS,MAAM,oBAAoB,MAAM;AACzC,uBAAO,SAAS,IAAIA;AAAA,cACxB;AAAA,YACJ;AAAA,UACJ,OACK;AAGD,qBAAS,MAAM,oBAAoB,MAAM;AACzC,mBAAO,SAAS,IAAI,OAAO,SAAS;AAAA,UACxC;AAAA,QACJ,CAAC;AACD,eAAO;AAAA,MACX;AAEA,aAAO;AAAA,IACX;AACA,IAAAD,YAAW,UAAU,sBAAsB,SAAU,OAAO;AACxD,UAAI,gBAAgB,KAAK,GAAG;AACxB,YAAI,CAAC,KAAK,WAAW,IAAI,KAAK,GAAG;AAC7B,cAAI,MAAM,QAAQ,KAAK,GAAG;AACtB,oBAAQ,MAAM,MAAM,CAAC;AAAA,UACzB,OACK;AACD,oBAAQ,SAAS,EAAE,WAAW,OAAO,eAAe,KAAK,EAAE,GAAG,KAAK;AAAA,UACvE;AACA,eAAK,WAAW,IAAI,KAAK;AAAA,QAC7B;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACA,WAAOA;AAAA,EACX,EAAE;AAAA;;;ACtFF,SAAS,gCAAgC,GAAG,gBAAgB;AAAE,MAAI,KAAK,OAAO,WAAW,eAAe,EAAE,OAAO,QAAQ,KAAK,EAAE,YAAY;AAAG,MAAI;AAAI,YAAQ,KAAK,GAAG,KAAK,CAAC,GAAG,KAAK,KAAK,EAAE;AAAG,MAAI,MAAM,QAAQ,CAAC,MAAM,KAAK,4BAA4B,CAAC,MAAM,kBAAkB,KAAK,OAAO,EAAE,WAAW,UAAU;AAAE,QAAI;AAAI,UAAI;AAAI,QAAI,IAAI;AAAG,WAAO,WAAY;AAAE,UAAI,KAAK,EAAE;AAAQ,eAAO,EAAE,MAAM,KAAK;AAAG,aAAO,EAAE,MAAM,OAAO,OAAO,EAAE,GAAG,EAAE;AAAA,IAAG;AAAA,EAAG;AAAE,QAAM,IAAI,UAAU,uIAAuI;AAAG;AAE3lB,SAAS,4BAA4B,GAAG,QAAQ;AAAE,MAAI,CAAC;AAAG;AAAQ,MAAI,OAAO,MAAM;AAAU,WAAO,kBAAkB,GAAG,MAAM;AAAG,MAAI,IAAI,OAAO,UAAU,SAAS,KAAK,CAAC,EAAE,MAAM,GAAG,EAAE;AAAG,MAAI,MAAM,YAAY,EAAE;AAAa,QAAI,EAAE,YAAY;AAAM,MAAI,MAAM,SAAS,MAAM;AAAO,WAAO,MAAM,KAAK,CAAC;AAAG,MAAI,MAAM,eAAe,2CAA2C,KAAK,CAAC;AAAG,WAAO,kBAAkB,GAAG,MAAM;AAAG;AAE/Z,SAAS,kBAAkB,KAAK,KAAK;AAAE,MAAI,OAAO,QAAQ,MAAM,IAAI;AAAQ,UAAM,IAAI;AAAQ,WAAS,IAAI,GAAG,OAAO,IAAI,MAAM,GAAG,GAAG,IAAI,KAAK,KAAK;AAAE,SAAK,CAAC,IAAI,IAAI,CAAC;AAAA,EAAG;AAAE,SAAO;AAAM;AAEtL,SAAS,kBAAkB,QAAQ,OAAO;AAAE,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AAAE,QAAI,aAAa,MAAM,CAAC;AAAG,eAAW,aAAa,WAAW,cAAc;AAAO,eAAW,eAAe;AAAM,QAAI,WAAW;AAAY,iBAAW,WAAW;AAAM,WAAO,eAAe,QAAQ,WAAW,KAAK,UAAU;AAAA,EAAG;AAAE;AAE5T,SAAS,aAAa,aAAa,YAAY,aAAa;AAAE,MAAI;AAAY,sBAAkB,YAAY,WAAW,UAAU;AAAG,MAAI;AAAa,sBAAkB,aAAa,WAAW;AAAG,SAAO,eAAe,aAAa,aAAa,EAAE,UAAU,MAAM,CAAC;AAAG,SAAO;AAAa;AAG5R,IAAI,aAAa,WAAY;AAC3B,SAAO,OAAO,WAAW;AAC3B;AAEA,IAAI,YAAY,SAAU,MAAM;AAC9B,SAAO,WAAW,KAAK,QAAQ,OAAO,IAAI,CAAC;AAC7C;AAEA,IAAI,YAAY,SAAU,MAAM;AAC9B,SAAO,UAAU,IAAI,IAAI,OAAO,IAAI,IAAI,OAAO;AACjD;AAEA,IAAI,WAAW,KAAK,CAAC,UAAU,YAAY,GAAG;AAC5C,SAAO,aAAa,OAAO,YAAY;AACzC;AAEA,IAAI,iBAAiB,UAAU,UAAU;AACzC,IAAI,mBAAmB,UAAU,YAAY;AAC7C,IAAI,gBAAgB,UAAU,SAAS;AAEvC,SAAS,UAAU,KAAK,KAAK;AAC3B,MAAI,QAAQ,IAAI,GAAG;AACnB,MAAI,SAAS;AAAM,WAAO;AAC1B,MAAI,OAAO,UAAU;AAAY,UAAM,IAAI,UAAU,QAAQ,oBAAoB;AACjF,SAAO;AACT;AAEA,SAAS,WAAW,KAAK;AACvB,MAAI,OAAO,IAAI;AAEf,MAAI,SAAS,QAAW;AACtB,WAAO,KAAK,aAAa;AAEzB,QAAI,SAAS,MAAM;AACjB,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO,SAAS,SAAY,OAAO;AACrC;AAEA,SAAS,aAAa,GAAG;AACvB,SAAO,aAAa;AACtB;AAEA,SAAS,gBAAgB,GAAG;AAC1B,MAAI,gBAAgB,KAAK;AACvB,oBAAgB,IAAI,CAAC;AAAA,EACvB,OAAO;AACL,eAAW,WAAY;AACrB,YAAM;AAAA,IACR,CAAC;AAAA,EACH;AACF;AAEA,SAAS,QAAQ,IAAI;AACnB,UAAQ,QAAQ,EAAE,KAAK,WAAY;AACjC,QAAI;AACF,SAAG;AAAA,IACL,SAAS,GAAG;AACV,sBAAgB,CAAC;AAAA,IACnB;AAAA,EACF,CAAC;AACH;AAEA,SAAS,oBAAoB,cAAc;AACzC,MAAI,UAAU,aAAa;AAC3B,MAAI,YAAY;AAAW;AAC3B,eAAa,WAAW;AAExB,MAAI,CAAC,SAAS;AACZ;AAAA,EACF;AAEA,MAAI;AACF,QAAI,OAAO,YAAY,YAAY;AACjC,cAAQ;AAAA,IACV,OAAO;AACL,UAAI,cAAc,UAAU,SAAS,aAAa;AAElD,UAAI,aAAa;AACf,oBAAY,KAAK,OAAO;AAAA,MAC1B;AAAA,IACF;AAAA,EACF,SAAS,GAAG;AACV,oBAAgB,CAAC;AAAA,EACnB;AACF;AAEA,SAAS,kBAAkB,cAAc;AACvC,eAAa,YAAY;AACzB,eAAa,SAAS;AACtB,eAAa,SAAS;AACxB;AAEA,SAAS,kBAAkB,cAAc;AACvC,MAAI,QAAQ,aAAa;AAEzB,MAAI,CAAC,OAAO;AACV;AAAA,EACF;AAEA,eAAa,SAAS;AACtB,eAAa,SAAS;AAEtB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AACrC,uBAAmB,cAAc,MAAM,CAAC,EAAE,MAAM,MAAM,CAAC,EAAE,KAAK;AAC9D,QAAI,aAAa,WAAW;AAAU;AAAA,EACxC;AACF;AAEA,SAAS,mBAAmB,cAAc,MAAM,OAAO;AACrD,eAAa,SAAS;AACtB,MAAI,WAAW,aAAa;AAE5B,MAAI;AACF,QAAI,IAAI,UAAU,UAAU,IAAI;AAEhC,YAAQ,MAAM;AAAA,MACZ,KAAK;AACH,YAAI;AAAG,YAAE,KAAK,UAAU,KAAK;AAC7B;AAAA,MAEF,KAAK;AACH,0BAAkB,YAAY;AAC9B,YAAI;AAAG,YAAE,KAAK,UAAU,KAAK;AAAA;AAAO,gBAAM;AAC1C;AAAA,MAEF,KAAK;AACH,0BAAkB,YAAY;AAC9B,YAAI;AAAG,YAAE,KAAK,QAAQ;AACtB;AAAA,IACJ;AAAA,EACF,SAAS,GAAG;AACV,oBAAgB,CAAC;AAAA,EACnB;AAEA,MAAI,aAAa,WAAW;AAAU,wBAAoB,YAAY;AAAA,WAAW,aAAa,WAAW;AAAW,iBAAa,SAAS;AAC5I;AAEA,SAAS,SAAS,cAAc,MAAM,OAAO;AAC3C,MAAI,aAAa,WAAW;AAAU;AAEtC,MAAI,aAAa,WAAW,aAAa;AACvC,iBAAa,OAAO,KAAK;AAAA,MACvB;AAAA,MACA;AAAA,IACF,CAAC;AAED;AAAA,EACF;AAEA,MAAI,aAAa,WAAW,SAAS;AACnC,iBAAa,SAAS;AACtB,iBAAa,SAAS,CAAC;AAAA,MACrB;AAAA,MACA;AAAA,IACF,CAAC;AACD,YAAQ,WAAY;AAClB,aAAO,kBAAkB,YAAY;AAAA,IACvC,CAAC;AACD;AAAA,EACF;AAEA,qBAAmB,cAAc,MAAM,KAAK;AAC9C;AAEA,IAAI,eAA4B,WAAY;AAC1C,WAASE,cAAa,UAAU,YAAY;AAG1C,SAAK,WAAW;AAChB,SAAK,YAAY;AACjB,SAAK,SAAS;AACd,SAAK,SAAS;AACd,QAAI,uBAAuB,IAAI,qBAAqB,IAAI;AAExD,QAAI;AACF,WAAK,WAAW,WAAW,KAAK,QAAW,oBAAoB;AAAA,IACjE,SAAS,GAAG;AACV,2BAAqB,MAAM,CAAC;AAAA,IAC9B;AAEA,QAAI,KAAK,WAAW;AAAgB,WAAK,SAAS;AAAA,EACpD;AAEA,MAAI,SAASA,cAAa;AAE1B,SAAO,cAAc,SAAS,cAAc;AAC1C,QAAI,KAAK,WAAW,UAAU;AAC5B,wBAAkB,IAAI;AACtB,0BAAoB,IAAI;AAAA,IAC1B;AAAA,EACF;AAEA,eAAaA,eAAc,CAAC;AAAA,IAC1B,KAAK;AAAA,IACL,KAAK,WAAY;AACf,aAAO,KAAK,WAAW;AAAA,IACzB;AAAA,EACF,CAAC,CAAC;AAEF,SAAOA;AACT,EAAE;AAEF,IAAI,uBAAoC,WAAY;AAClD,WAASC,sBAAqB,cAAc;AAC1C,SAAK,gBAAgB;AAAA,EACvB;AAEA,MAAI,UAAUA,sBAAqB;AAEnC,UAAQ,OAAO,SAAS,KAAK,OAAO;AAClC,aAAS,KAAK,eAAe,QAAQ,KAAK;AAAA,EAC5C;AAEA,UAAQ,QAAQ,SAAS,MAAM,OAAO;AACpC,aAAS,KAAK,eAAe,SAAS,KAAK;AAAA,EAC7C;AAEA,UAAQ,WAAW,SAAS,WAAW;AACrC,aAAS,KAAK,eAAe,UAAU;AAAA,EACzC;AAEA,eAAaA,uBAAsB,CAAC;AAAA,IAClC,KAAK;AAAA,IACL,KAAK,WAAY;AACf,aAAO,KAAK,cAAc,WAAW;AAAA,IACvC;AAAA,EACF,CAAC,CAAC;AAEF,SAAOA;AACT,EAAE;AAEF,IAAI,aAA0B,WAAY;AACxC,WAASC,YAAW,YAAY;AAC9B,QAAI,EAAE,gBAAgBA;AAAa,YAAM,IAAI,UAAU,2CAA2C;AAClG,QAAI,OAAO,eAAe;AAAY,YAAM,IAAI,UAAU,2CAA2C;AACrG,SAAK,cAAc;AAAA,EACrB;AAEA,MAAI,UAAUA,YAAW;AAEzB,UAAQ,YAAY,SAAS,UAAU,UAAU;AAC/C,QAAI,OAAO,aAAa,YAAY,aAAa,MAAM;AACrD,iBAAW;AAAA,QACT,MAAM;AAAA,QACN,OAAO,UAAU,CAAC;AAAA,QAClB,UAAU,UAAU,CAAC;AAAA,MACvB;AAAA,IACF;AAEA,WAAO,IAAI,aAAa,UAAU,KAAK,WAAW;AAAA,EACpD;AAEA,UAAQ,UAAU,SAASC,SAAQ,IAAI;AACrC,QAAI,QAAQ;AAEZ,WAAO,IAAI,QAAQ,SAAU,SAAS,QAAQ;AAC5C,UAAI,OAAO,OAAO,YAAY;AAC5B,eAAO,IAAI,UAAU,KAAK,oBAAoB,CAAC;AAC/C;AAAA,MACF;AAEA,eAAS,OAAO;AACd,qBAAa,YAAY;AACzB,gBAAQ;AAAA,MACV;AAEA,UAAI,eAAe,MAAM,UAAU;AAAA,QACjC,MAAM,SAAU,OAAO;AACrB,cAAI;AACF,eAAG,OAAO,IAAI;AAAA,UAChB,SAAS,GAAG;AACV,mBAAO,CAAC;AACR,yBAAa,YAAY;AAAA,UAC3B;AAAA,QACF;AAAA,QACA,OAAO;AAAA,QACP,UAAU;AAAA,MACZ,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAEA,UAAQ,MAAM,SAAS,IAAI,IAAI;AAC7B,QAAI,SAAS;AAEb,QAAI,OAAO,OAAO;AAAY,YAAM,IAAI,UAAU,KAAK,oBAAoB;AAC3E,QAAI,IAAI,WAAW,IAAI;AACvB,WAAO,IAAI,EAAE,SAAU,UAAU;AAC/B,aAAO,OAAO,UAAU;AAAA,QACtB,MAAM,SAAU,OAAO;AACrB,cAAI;AACF,oBAAQ,GAAG,KAAK;AAAA,UAClB,SAAS,GAAG;AACV,mBAAO,SAAS,MAAM,CAAC;AAAA,UACzB;AAEA,mBAAS,KAAK,KAAK;AAAA,QACrB;AAAA,QACA,OAAO,SAAU,GAAG;AAClB,mBAAS,MAAM,CAAC;AAAA,QAClB;AAAA,QACA,UAAU,WAAY;AACpB,mBAAS,SAAS;AAAA,QACpB;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAEA,UAAQ,SAAS,SAAS,OAAO,IAAI;AACnC,QAAI,SAAS;AAEb,QAAI,OAAO,OAAO;AAAY,YAAM,IAAI,UAAU,KAAK,oBAAoB;AAC3E,QAAI,IAAI,WAAW,IAAI;AACvB,WAAO,IAAI,EAAE,SAAU,UAAU;AAC/B,aAAO,OAAO,UAAU;AAAA,QACtB,MAAM,SAAU,OAAO;AACrB,cAAI;AACF,gBAAI,CAAC,GAAG,KAAK;AAAG;AAAA,UAClB,SAAS,GAAG;AACV,mBAAO,SAAS,MAAM,CAAC;AAAA,UACzB;AAEA,mBAAS,KAAK,KAAK;AAAA,QACrB;AAAA,QACA,OAAO,SAAU,GAAG;AAClB,mBAAS,MAAM,CAAC;AAAA,QAClB;AAAA,QACA,UAAU,WAAY;AACpB,mBAAS,SAAS;AAAA,QACpB;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAEA,UAAQ,SAAS,SAAS,OAAO,IAAI;AACnC,QAAI,SAAS;AAEb,QAAI,OAAO,OAAO;AAAY,YAAM,IAAI,UAAU,KAAK,oBAAoB;AAC3E,QAAI,IAAI,WAAW,IAAI;AACvB,QAAI,UAAU,UAAU,SAAS;AACjC,QAAI,WAAW;AACf,QAAI,OAAO,UAAU,CAAC;AACtB,QAAI,MAAM;AACV,WAAO,IAAI,EAAE,SAAU,UAAU;AAC/B,aAAO,OAAO,UAAU;AAAA,QACtB,MAAM,SAAU,OAAO;AACrB,cAAI,QAAQ,CAAC;AACb,qBAAW;AAEX,cAAI,CAAC,SAAS,SAAS;AACrB,gBAAI;AACF,oBAAM,GAAG,KAAK,KAAK;AAAA,YACrB,SAAS,GAAG;AACV,qBAAO,SAAS,MAAM,CAAC;AAAA,YACzB;AAAA,UACF,OAAO;AACL,kBAAM;AAAA,UACR;AAAA,QACF;AAAA,QACA,OAAO,SAAU,GAAG;AAClB,mBAAS,MAAM,CAAC;AAAA,QAClB;AAAA,QACA,UAAU,WAAY;AACpB,cAAI,CAAC,YAAY,CAAC;AAAS,mBAAO,SAAS,MAAM,IAAI,UAAU,iCAAiC,CAAC;AACjG,mBAAS,KAAK,GAAG;AACjB,mBAAS,SAAS;AAAA,QACpB;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAEA,UAAQ,SAAS,SAASC,UAAS;AACjC,QAAI,SAAS;AAEb,aAAS,OAAO,UAAU,QAAQ,UAAU,IAAI,MAAM,IAAI,GAAG,OAAO,GAAG,OAAO,MAAM,QAAQ;AAC1F,cAAQ,IAAI,IAAI,UAAU,IAAI;AAAA,IAChC;AAEA,QAAI,IAAI,WAAW,IAAI;AACvB,WAAO,IAAI,EAAE,SAAU,UAAU;AAC/B,UAAI;AACJ,UAAI,QAAQ;AAEZ,eAAS,UAAU,MAAM;AACvB,uBAAe,KAAK,UAAU;AAAA,UAC5B,MAAM,SAAU,GAAG;AACjB,qBAAS,KAAK,CAAC;AAAA,UACjB;AAAA,UACA,OAAO,SAAU,GAAG;AAClB,qBAAS,MAAM,CAAC;AAAA,UAClB;AAAA,UACA,UAAU,WAAY;AACpB,gBAAI,UAAU,QAAQ,QAAQ;AAC5B,6BAAe;AACf,uBAAS,SAAS;AAAA,YACpB,OAAO;AACL,wBAAU,EAAE,KAAK,QAAQ,OAAO,CAAC,CAAC;AAAA,YACpC;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH;AAEA,gBAAU,MAAM;AAChB,aAAO,WAAY;AACjB,YAAI,cAAc;AAChB,uBAAa,YAAY;AACzB,yBAAe;AAAA,QACjB;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAEA,UAAQ,UAAU,SAAS,QAAQ,IAAI;AACrC,QAAI,SAAS;AAEb,QAAI,OAAO,OAAO;AAAY,YAAM,IAAI,UAAU,KAAK,oBAAoB;AAC3E,QAAI,IAAI,WAAW,IAAI;AACvB,WAAO,IAAI,EAAE,SAAU,UAAU;AAC/B,UAAI,gBAAgB,CAAC;AAErB,UAAI,QAAQ,OAAO,UAAU;AAAA,QAC3B,MAAM,SAAU,OAAO;AACrB,cAAI,IAAI;AACN,gBAAI;AACF,sBAAQ,GAAG,KAAK;AAAA,YAClB,SAAS,GAAG;AACV,qBAAO,SAAS,MAAM,CAAC;AAAA,YACzB;AAAA,UACF;AAEA,cAAI,QAAQ,EAAE,KAAK,KAAK,EAAE,UAAU;AAAA,YAClC,MAAM,SAAUC,QAAO;AACrB,uBAAS,KAAKA,MAAK;AAAA,YACrB;AAAA,YACA,OAAO,SAAU,GAAG;AAClB,uBAAS,MAAM,CAAC;AAAA,YAClB;AAAA,YACA,UAAU,WAAY;AACpB,kBAAI,IAAI,cAAc,QAAQ,KAAK;AACnC,kBAAI,KAAK;AAAG,8BAAc,OAAO,GAAG,CAAC;AACrC,6BAAe;AAAA,YACjB;AAAA,UACF,CAAC;AACD,wBAAc,KAAK,KAAK;AAAA,QAC1B;AAAA,QACA,OAAO,SAAU,GAAG;AAClB,mBAAS,MAAM,CAAC;AAAA,QAClB;AAAA,QACA,UAAU,WAAY;AACpB,yBAAe;AAAA,QACjB;AAAA,MACF,CAAC;AAED,eAAS,iBAAiB;AACxB,YAAI,MAAM,UAAU,cAAc,WAAW;AAAG,mBAAS,SAAS;AAAA,MACpE;AAEA,aAAO,WAAY;AACjB,sBAAc,QAAQ,SAAU,GAAG;AACjC,iBAAO,EAAE,YAAY;AAAA,QACvB,CAAC;AACD,cAAM,YAAY;AAAA,MACpB;AAAA,IACF,CAAC;AAAA,EACH;AAEA,UAAQ,gBAAgB,IAAI,WAAY;AACtC,WAAO;AAAA,EACT;AAEA,EAAAH,YAAW,OAAO,SAASI,MAAK,GAAG;AACjC,QAAI,IAAI,OAAO,SAAS,aAAa,OAAOJ;AAC5C,QAAI,KAAK;AAAM,YAAM,IAAI,UAAU,IAAI,mBAAmB;AAC1D,QAAI,SAAS,UAAU,GAAG,gBAAgB;AAE1C,QAAI,QAAQ;AACV,UAAI,aAAa,OAAO,KAAK,CAAC;AAC9B,UAAI,OAAO,UAAU,MAAM;AAAY,cAAM,IAAI,UAAU,aAAa,mBAAmB;AAC3F,UAAI,aAAa,UAAU,KAAK,WAAW,gBAAgB;AAAG,eAAO;AACrE,aAAO,IAAI,EAAE,SAAU,UAAU;AAC/B,eAAO,WAAW,UAAU,QAAQ;AAAA,MACtC,CAAC;AAAA,IACH;AAEA,QAAI,UAAU,UAAU,GAAG;AACzB,eAAS,UAAU,GAAG,cAAc;AAEpC,UAAI,QAAQ;AACV,eAAO,IAAI,EAAE,SAAU,UAAU;AAC/B,kBAAQ,WAAY;AAClB,gBAAI,SAAS;AAAQ;AAErB,qBAAS,YAAY,gCAAgC,OAAO,KAAK,CAAC,CAAC,GAAG,OAAO,EAAE,QAAQ,UAAU,GAAG,QAAO;AACzG,kBAAI,OAAO,MAAM;AACjB,uBAAS,KAAK,IAAI;AAClB,kBAAI,SAAS;AAAQ;AAAA,YACvB;AAEA,qBAAS,SAAS;AAAA,UACpB,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAAA,IACF;AAEA,QAAI,MAAM,QAAQ,CAAC,GAAG;AACpB,aAAO,IAAI,EAAE,SAAU,UAAU;AAC/B,gBAAQ,WAAY;AAClB,cAAI,SAAS;AAAQ;AAErB,mBAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,EAAE,GAAG;AACjC,qBAAS,KAAK,EAAE,CAAC,CAAC;AAClB,gBAAI,SAAS;AAAQ;AAAA,UACvB;AAEA,mBAAS,SAAS;AAAA,QACpB,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAEA,UAAM,IAAI,UAAU,IAAI,oBAAoB;AAAA,EAC9C;AAEA,EAAAA,YAAW,KAAK,SAAS,KAAK;AAC5B,aAAS,QAAQ,UAAU,QAAQ,QAAQ,IAAI,MAAM,KAAK,GAAG,QAAQ,GAAG,QAAQ,OAAO,SAAS;AAC9F,YAAM,KAAK,IAAI,UAAU,KAAK;AAAA,IAChC;AAEA,QAAI,IAAI,OAAO,SAAS,aAAa,OAAOA;AAC5C,WAAO,IAAI,EAAE,SAAU,UAAU;AAC/B,cAAQ,WAAY;AAClB,YAAI,SAAS;AAAQ;AAErB,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AACrC,mBAAS,KAAK,MAAM,CAAC,CAAC;AACtB,cAAI,SAAS;AAAQ;AAAA,QACvB;AAEA,iBAAS,SAAS;AAAA,MACpB,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAEA,eAAaA,aAAY,MAAM,CAAC;AAAA,IAC9B,KAAK;AAAA,IACL,KAAK,WAAY;AACf,aAAO;AAAA,IACT;AAAA,EACF,CAAC,CAAC;AAEF,SAAOA;AACT,EAAE;AAEF,IAAI,WAAW,GAAG;AAChB,SAAO,eAAe,YAAY,OAAO,YAAY,GAAG;AAAA,IACtD,OAAO;AAAA,MACL,QAAQ;AAAA,MACR;AAAA,IACF;AAAA,IACA,cAAc;AAAA,EAChB,CAAC;AACH;;;AC7jBe,SAAR,yBAA0CK,OAAM;AACtD,MAAIC;AACJ,MAAIC,UAASF,MAAK;AAElB,MAAI,OAAOE,YAAW,YAAY;AACjC,QAAIA,QAAO,YAAY;AACtB,MAAAD,UAASC,QAAO;AAAA,IACjB,OAAO;AAEN,UAAI,OAAOA,QAAO,QAAQ,YAAY;AAIrC,QAAAD,UAASC,QAAO,IAAI,8CAA8C;AAAA,MACnE,OAAO;AAIN,QAAAD,UAASC,QAAO,8CAA8C;AAAA,MAC/D;AACA,UAAI;AACH,QAAAA,QAAO,aAAaD;AAAA,MACrB,SAAS,KAAK;AAAA,MAId;AAAA,IACD;AAAA,EACD,OAAO;AACN,IAAAA,UAAS;AAAA,EACV;AAEA,SAAOA;AACR;;;AC9BA,IAAI;AAEJ,IAAI,OAAO,SAAS,aAAa;AAC/B,SAAO;AACT,WAAW,OAAO,WAAW,aAAa;AACxC,SAAO;AACT,WAAW,OAAO,WAAW,aAAa;AACxC,SAAO;AACT,WAAW,OAAO,WAAW,aAAa;AACxC,SAAO;AACT,OAAO;AACL,SAAO,SAAS,aAAa,EAAE;AACjC;AAEA,IAAI,SAAS,yBAAS,IAAI;;;ACV1B,IAAI,YAAY,WAAW;AAC3B,IAAI,gBAAgB;AACpB,IAAI,CAAC,UAAU,aAAa,GAAG;AAE3B,YAAU,aAAa,IAAI,WAAY;AACnC,WAAO;AAAA,EACX;AACJ;;;ACdA,IAAI,WAAW,OAAO,UAAU;AAIzB,SAAS,UAAU,OAAO;AAC7B,SAAO,gBAAgB,KAAK;AAChC;AACA,SAAS,gBAAgB,KAAK,MAAM;AAChC,UAAQ,SAAS,KAAK,GAAG,GAAG;AAAA,IACxB,KAAK,kBAAkB;AACnB,aAAO,QAAQ,oBAAI,IAAI;AACvB,UAAI,KAAK,IAAI,GAAG;AACZ,eAAO,KAAK,IAAI,GAAG;AACvB,UAAI,SAAS,IAAI,MAAM,CAAC;AACxB,WAAK,IAAI,KAAK,MAAM;AACpB,aAAO,QAAQ,SAAU,OAAO,GAAG;AAC/B,eAAO,CAAC,IAAI,gBAAgB,OAAO,IAAI;AAAA,MAC3C,CAAC;AACD,aAAO;AAAA,IACX;AAAA,IACA,KAAK,mBAAmB;AACpB,aAAO,QAAQ,oBAAI,IAAI;AACvB,UAAI,KAAK,IAAI,GAAG;AACZ,eAAO,KAAK,IAAI,GAAG;AAGvB,UAAI,SAAS,OAAO,OAAO,OAAO,eAAe,GAAG,CAAC;AACrD,WAAK,IAAI,KAAK,MAAM;AACpB,aAAO,KAAK,GAAG,EAAE,QAAQ,SAAU,KAAK;AACpC,eAAO,GAAG,IAAI,gBAAgB,IAAI,GAAG,GAAG,IAAI;AAAA,MAChD,CAAC;AACD,aAAO;AAAA,IACX;AAAA,IACA;AACI,aAAO;AAAA,EACf;AACJ;;;ACnCA,SAAS,WAAW,OAAO;AACvB,MAAI,UAAU,oBAAI,IAAI,CAAC,KAAK,CAAC;AAC7B,UAAQ,QAAQ,SAAU,KAAK;AAC3B,QAAI,gBAAgB,GAAG,KAAK,cAAc,GAAG,MAAM,KAAK;AACpD,aAAO,oBAAoB,GAAG,EAAE,QAAQ,SAAU,MAAM;AACpD,YAAI,gBAAgB,IAAI,IAAI,CAAC;AACzB,kBAAQ,IAAI,IAAI,IAAI,CAAC;AAAA,MAC7B,CAAC;AAAA,IACL;AAAA,EACJ,CAAC;AACD,SAAO;AACX;AACA,SAAS,cAAc,KAAK;AACxB,MAAI,WAAW,YAAY,SAAS,CAAC,OAAO,SAAS,GAAG,GAAG;AACvD,QAAI;AACA,aAAO,OAAO,GAAG;AAAA,IACrB,SACO,GAAG;AAIN,UAAI,aAAa;AACb,eAAO;AACX,YAAM;AAAA,IACV;AAAA,EACJ;AACA,SAAO;AACX;AACO,SAAS,gBAAgB,KAAK;AACjC,MAAI,WAAW,YAAY,OAAO;AAC9B,eAAW,GAAG;AAAA,EAClB;AACA,SAAO;AACX;;;AClCO,SAAS,uBAAuB,WAAW,QAAQ,UAAU;AAIhE,MAAI,sBAAsB,CAAC;AAC3B,YAAU,QAAQ,SAAU,KAAK;AAAE,WAAO,IAAI,MAAM,KAAK,oBAAoB,KAAK,GAAG;AAAA,EAAG,CAAC;AACzF,sBAAoB,QAAQ,SAAU,KAAK;AAAE,WAAO,IAAI,MAAM,EAAE,QAAQ;AAAA,EAAG,CAAC;AAChF;;;ACJO,SAAS,SAAS,YAAY,OAAO,SAAS;AACjD,SAAO,IAAI,WAAW,SAAU,UAAU;AACtC,QAAI,eAAe;AAAA;AAAA;AAAA;AAAA,MAIf,MAAM,SAAU,UAAU;AACtB,eAAO,IAAI,QAAQ,SAAU,SAAS;AAAE,iBAAO,QAAQ,SAAS,CAAC;AAAA,QAAG,CAAC;AAAA,MACzE;AAAA,IACJ;AACA,aAAS,aAAa,UAAU,KAAK;AACjC,aAAO,SAAU,KAAK;AAClB,YAAI,UAAU;AACV,cAAI,OAAO,WAAY;AAGnB,mBAAO,SAAS;AAAA;AAAA,cACY;AAAA,gBACtB,SAAS,GAAG;AAAA,UACtB;AACA,yBAAe,aAAa,KAAK,MAAM,IAAI,EAAE,KAAK,SAAUE,SAAQ;AAAE,mBAAO,SAAS,KAAKA,OAAM;AAAA,UAAG,GAAG,SAAU,OAAO;AAAE,mBAAO,SAAS,MAAM,KAAK;AAAA,UAAG,CAAC;AAAA,QAC7J,OACK;AACD,mBAAS,GAAG,EAAE,GAAG;AAAA,QACrB;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,UAAU;AAAA,MACV,MAAM,aAAa,OAAO,MAAM;AAAA,MAChC,OAAO,aAAa,SAAS,OAAO;AAAA,MACpC,UAAU,WAAY;AAGE,qBAAa,KAAK,WAAY;AAAE,iBAAO,SAAS,SAAS;AAAA,QAAG,CAAC;AAAA,MACrF;AAAA,IACJ;AACA,QAAI,MAAM,WAAW,UAAU,OAAO;AACtC,WAAO,WAAY;AAAE,aAAO,IAAI,YAAY;AAAA,IAAG;AAAA,EACnD,CAAC;AACL;;;AChCO,SAAS,sBAAsB,UAAU;AAC5C,WAAS,IAAI,KAAK;AAId,WAAO,eAAe,UAAU,KAAK,EAAE,OAAO,WAAW,CAAC;AAAA,EAC9D;AACA,MAAI,gBAAgB,OAAO,SAAS;AAChC,QAAI,OAAO,OAAO;AAAA,EACtB;AAIA,MAAI,WAAW;AACf,SAAO;AACX;;;ACrBA,SAAS,cAAc,OAAO;AAC1B,SAAO,SAAS,OAAO,MAAM,SAAS;AAC1C;AA8BA,IAAI;AAAA;AAAA,EAAyB,SAAU,QAAQ;AAC3C,cAAUC,UAAS,MAAM;AAGzB,aAASA,SAAQ,SAAS;AACtB,UAAI,QAAQ,OAAO,KAAK,MAAM,SAAU,UAAU;AAC9C,cAAM,YAAY,QAAQ;AAC1B,eAAO,WAAY;AAAE,iBAAO,MAAM,eAAe,QAAQ;AAAA,QAAG;AAAA,MAChE,CAAC,KAAK;AAIN,YAAM,YAAY,oBAAI,IAAI;AAC1B,YAAM,UAAU,IAAI,QAAQ,SAAU,SAAS,QAAQ;AACnD,cAAM,UAAU;AAChB,cAAM,SAAS;AAAA,MACnB,CAAC;AAGD,YAAM,WAAW;AAAA,QACb,MAAM,SAAUC,SAAQ;AACpB,cAAI,MAAM,QAAQ,MAAM;AACpB,kBAAM,SAAS,CAAC,QAAQA,OAAM;AAC9B,kBAAM,OAAO,QAAQA,OAAM;AAC3B,mCAAuB,MAAM,WAAW,QAAQA,OAAM;AAAA,UAC1D;AAAA,QACJ;AAAA,QACA,OAAO,SAAU,OAAO;AACpB,cAAI,MAAM,MAAM;AAChB,cAAI,QAAQ,MAAM;AAId,gBAAI;AACA,yBAAW,WAAY;AAAE,uBAAO,IAAI,YAAY;AAAA,cAAG,CAAC;AACxD,kBAAM,MAAM;AACZ,kBAAM,SAAS,CAAC,SAAS,KAAK;AAC9B,kBAAM,OAAO,KAAK;AAClB,kBAAM,OAAO,SAAS,KAAK;AAC3B,mCAAuB,MAAM,WAAW,SAAS,KAAK;AAAA,UAC1D;AAAA,QACJ;AAAA,QACA,UAAU,WAAY;AAClB,cAAIC,MAAK,OAAO,MAAMA,IAAG,KAAK,KAAKA,IAAG,SAASC,WAAU,OAAO,SAAS,CAAC,IAAI;AAC9E,cAAI,QAAQ,MAAM;AAMd,gBAAI,QAAQA,SAAQ,MAAM;AAC1B,gBAAI,CAAC,OAAO;AACR,kBAAI;AACA,2BAAW,WAAY;AAAE,yBAAO,IAAI,YAAY;AAAA,gBAAG,CAAC;AACxD,oBAAM,MAAM;AACZ,kBAAI,MAAM,UAAU,MAAM,OAAO,CAAC,MAAM,QAAQ;AAC5C,sBAAM,QAAQ,MAAM,OAAO,CAAC,CAAC;AAAA,cACjC,OACK;AACD,sBAAM,QAAQ;AAAA,cAClB;AACA,oBAAM,OAAO,UAAU;AAOvB,qCAAuB,MAAM,WAAW,UAAU;AAAA,YACtD,WACS,cAAc,KAAK,GAAG;AAC3B,oBAAM,KAAK,SAAU,KAAK;AAAE,uBAAQ,MAAM,MAAM,IAAI,UAAU,MAAM,QAAQ;AAAA,cAAI,CAAC;AAAA,YACrF,OACK;AACD,oBAAM,MAAM,MAAM,UAAU,MAAM,QAAQ;AAAA,YAC9C;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AACA,YAAM,sBAAsB,oBAAI,IAAI;AAEpC,YAAM,SAAS,SAAU,QAAQ;AAC7B,cAAM,OAAO,MAAM;AACnB,cAAM,UAAU,CAAC;AACjB,cAAM,SAAS,SAAS;AAAA,MAC5B;AAIA,YAAM,QAAQ,MAAM,SAAU,GAAG;AAAA,MAAE,CAAC;AAIpC,UAAI,OAAO,YAAY,YAAY;AAC/B,kBAAU,CAAC,IAAI,WAAW,OAAO,CAAC;AAAA,MACtC;AACA,UAAI,cAAc,OAAO,GAAG;AACxB,gBAAQ,KAAK,SAAU,UAAU;AAAE,iBAAO,MAAM,MAAM,QAAQ;AAAA,QAAG,GAAG,MAAM,SAAS,KAAK;AAAA,MAC5F,OACK;AACD,cAAM,MAAM,OAAO;AAAA,MACvB;AACA,aAAO;AAAA,IACX;AACA,IAAAH,SAAQ,UAAU,QAAQ,SAAU,SAAS;AACzC,UAAI,KAAK,QAAQ;AACb;AAIJ,WAAK,UAAU,MAAM,KAAK,OAAO;AAKjC,WAAK,SAAS,SAAS;AAAA,IAC3B;AACA,IAAAA,SAAQ,UAAU,qBAAqB,SAAU,UAAU;AACvD,UAAI,KAAK,QAAQ;AACb,YAAI,cAAc,KAAK,OAAO,CAAC;AAC/B,YAAI,SAAS,SAAS,WAAW;AACjC,YAAI,QAAQ;AACR,iBAAO,KAAK,UAAU,KAAK,OAAO,CAAC,CAAC;AAAA,QACxC;AAIA,YAAI,KAAK,QAAQ,QAAQ,gBAAgB,UAAU,SAAS,UAAU;AAClE,mBAAS,SAAS;AAAA,QACtB;AAAA,MACJ;AAAA,IACJ;AACA,IAAAA,SAAQ,UAAU,cAAc,SAAU,UAAU;AAChD,UAAI,CAAC,KAAK,UAAU,IAAI,QAAQ,GAAG;AAG/B,aAAK,mBAAmB,QAAQ;AAChC,aAAK,UAAU,IAAI,QAAQ;AAAA,MAC/B;AAAA,IACJ;AACA,IAAAA,SAAQ,UAAU,iBAAiB,SAAU,UAAU;AACnD,UAAI,KAAK,UAAU,OAAO,QAAQ,KAAK,KAAK,UAAU,OAAO,GAAG;AAK5D,aAAK,SAAS,SAAS;AAAA,MAC3B;AAAA,IACJ;AACA,IAAAA,SAAQ,UAAU,SAAS,SAAU,QAAQ,KAAK;AAC9C,UAAI,sBAAsB,KAAK;AAC/B,UAAI,oBAAoB,MAAM;AAG1B,aAAK,sBAAsB,oBAAI,IAAI;AACnC,4BAAoB,QAAQ,SAAU,UAAU;AAAE,iBAAO,SAAS,QAAQ,GAAG;AAAA,QAAG,CAAC;AAAA,MACrF;AAAA,IACJ;AAOA,IAAAA,SAAQ,UAAU,aAAa,SAAU,UAAU;AAC/C,UAAI,SAAS;AACb,WAAK,oBAAoB,IAAI,SAAU,QAAQ,KAAK;AAChD,YAAI,CAAC,QAAQ;AACT,mBAAS;AACT,mBAAS,QAAQ,GAAG;AAAA,QACxB;AAAA,MACJ,CAAC;AAAA,IACL;AACA,WAAOA;AAAA,EACX,EAAE,UAAU;AAAA;AAIZ,sBAAsB,OAAO;;;ACnNtB,SAAS,kCAAkC,OAAO;AACrD,SAAO,iBAAiB;AAC5B;AACO,SAAS,8BAA8B,OAAO;AACjD,SAAO,aAAa,SAAS,UAAU;AAC3C;AACO,SAAS,uBAAuB,OAAO;AAC1C,SAAQ,kCAAkC,KAAK,KAC3C,8BAA8B,KAAK;AAC3C;AAIO,SAAS,sBAAsB,OAAO;AACzC,SAAO,gBAAgB,KAAK,KAAK,aAAa;AAClD;AACO,SAAS,qBAAqB,YAAYI,SAAQ;AACrD,MAAI,aAAa;AACjB,MAAI,SAAS,IAAI,WAAW;AAC5B,MAAI,kCAAkCA,OAAM,KACxC,gBAAgBA,QAAO,WAAW,GAAG;AACrC,IAAAA,QAAO,YAAY,QAAQ,SAAUC,KAAI;AACrC,UAAI,OAAOA,IAAG,MAAM,OAAOA,IAAG;AAC9B,eAAS,IAAI,KAAK,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AACvC,YAAI,MAAM,KAAK,CAAC;AAChB,YAAI,eAAe,CAAC,MAAM,CAAC,GAAG;AAC9B,YAAI,WAAW,eAAe,CAAC,IAAI,CAAC;AACpC,iBAAS,GAAG,IAAI;AAChB,eAAO;AAAA,MACX;AACA,mBAAa,OAAO,MAAM,YAAY,IAAI;AAAA,IAC9C,CAAC;AAAA,EACL;AACA,SAAO;AACX;;;ACnCO,SAAS,sBAAsBC,SAAQ;AAC1C,MAAI,SAAS,2BAA2BA,OAAM;AAC9C,SAAO,gBAAgB,MAAM;AACjC;AACO,SAAS,2BAA2BA,SAAQ;AAC/C,MAAI,gBAAgB,gBAAgBA,QAAO,MAAM,IAAIA,QAAO,OAAO,MAAM,CAAC,IAAI,CAAC;AAC/E,MAAI,kCAAkCA,OAAM,KACxC,gBAAgBA,QAAO,WAAW,GAAG;AACrC,IAAAA,QAAO,YAAY,QAAQ,SAAU,mBAAmB;AACpD,UAAI,kBAAkB,QAAQ;AAC1B,sBAAc,KAAK,MAAM,eAAe,kBAAkB,MAAM;AAAA,MACpE;AAAA,IACJ,CAAC;AAAA,EACL;AACA,SAAO;AACX;;;ACbO,SAAS,UAAU;AACtB,MAAI,UAAU,CAAC;AACf,WAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,YAAQ,EAAE,IAAI,UAAU,EAAE;AAAA,EAC9B;AACA,MAAIC,UAAS,uBAAO,OAAO,IAAI;AAC/B,UAAQ,QAAQ,SAAU,KAAK;AAC3B,QAAI,CAAC;AACD;AACJ,WAAO,KAAK,GAAG,EAAE,QAAQ,SAAU,KAAK;AACpC,UAAI,QAAQ,IAAI,GAAG;AACnB,UAAI,UAAU,QAAQ;AAClB,QAAAA,QAAO,GAAG,IAAI;AAAA,MAClB;AAAA,IACJ,CAAC;AAAA,EACL,CAAC;AACD,SAAOA;AACX;;;ACnBO,SAAS,aAAa,UAAU,SAAS;AAC5C,SAAO,QAAQ,UAAU,SAAS,QAAQ,aAAa;AAAA,IACnD,WAAW,QAAQ,SAAS,SAAS,CAAC,GAAI,YAAY,SAAS,SAAU,GAAG,QAAQ,SAAS,CAAC;AAAA,EAClG,CAAC;AACL;;;ACLO,SAAS,UAAU,YAAY;AAClC,SAAO,IAAI,WAAW,SAAU,UAAU;AACtC,aAAS,MAAM,UAAU;AAAA,EAC7B,CAAC;AACL;;;ACJO,SAAS,UAAU,YAAY;AAClC,MAAI,YAAY;AAChB,SAAO,IAAI,QAAQ,SAAU,SAAS,QAAQ;AAC1C,eAAW,UAAU;AAAA,MACjB,MAAM,SAAU,MAAM;AAClB,YAAI,WAAW;AACX,qBAAW,YAAY,SAASC,WAAU,KAAK,EAAE;AAAA,QACrD,OACK;AACD,sBAAY;AACZ,kBAAQ,IAAI;AAAA,QAChB;AAAA,MACJ;AAAA,MACA,OAAO;AAAA,IACX,CAAC;AAAA,EACL,CAAC;AACL;;;AChBO,SAAS,YAAY,SAAS;AACjC,SAAO,IAAI,WAAW,SAAU,UAAU;AACtC,YACK,KAAK,SAAU,OAAO;AACvB,eAAS,KAAK,KAAK;AACnB,eAAS,SAAS;AAAA,IACtB,CAAC,EACI,MAAM,SAAS,MAAM,KAAK,QAAQ,CAAC;AAAA,EAC5C,CAAC;AACL;;;ACVO,IAAI,mBAAmB,SAAU,UAAUC,SAAQ,SAAS;AAC/D,MAAI,QAAQ,IAAI,MAAM,OAAO;AAC7B,QAAM,OAAO;AACb,QAAM,WAAW;AACjB,QAAM,aAAa,SAAS;AAC5B,QAAM,SAASA;AACf,QAAM;AACV;;;ACNO,SAAS,kBAAkB,WAAW;AACzC,MAAI,mBAAmB;AAAA,IACnB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACA,WAAS,KAAK,GAAGC,MAAK,OAAO,KAAK,SAAS,GAAG,KAAKA,IAAG,QAAQ,MAAM;AAChE,QAAI,MAAMA,IAAG,EAAE;AACf,QAAI,iBAAiB,QAAQ,GAAG,IAAI,GAAG;AACnC,YAAM,kBAAkB,IAAI,GAAG;AAAA,IACnC;AAAA,EACJ;AACA,SAAO;AACX;;;ACfO,SAAS,gBAAgB,UAAU,WAAW;AACjD,MAAI,UAAU,SAAS,CAAC,GAAG,QAAQ;AACnC,MAAI,aAAa,SAAU,MAAM;AAC7B,QAAI,OAAO,SAAS,YAAY;AAC5B,gBAAU,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,KAAK,OAAO,CAAC;AAAA,IAC3D,OACK;AACD,gBAAU,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,IAAI;AAAA,IAClD;AAAA,EACJ;AACA,MAAI,aAAa,WAAY;AAAE,WAAQ,SAAS,CAAC,GAAG,OAAO;AAAA,EAAI;AAC/D,SAAO,eAAe,WAAW,cAAc;AAAA,IAC3C,YAAY;AAAA,IACZ,OAAO;AAAA,EACX,CAAC;AACD,SAAO,eAAe,WAAW,cAAc;AAAA,IAC3C,YAAY;AAAA,IACZ,OAAO;AAAA,EACX,CAAC;AACD,SAAO;AACX;;;ACpBO,SAAS,mBAAmB,WAAW;AAC1C,MAAI,uBAAuB;AAAA,IACvB,WAAW,UAAU,aAAa,CAAC;AAAA,IACnC,YAAY,UAAU,cAAc,CAAC;AAAA,IACrC,eAAe,UAAU;AAAA,IACzB,OAAO,UAAU;AAAA,EACrB;AAEA,MAAI,CAAC,qBAAqB,eAAe;AACrC,yBAAqB,gBACjB,OAAO,qBAAqB,UAAU,WAClC,iBAAiB,qBAAqB,KAAK,KAAK,SAC9C;AAAA,EACd;AACA,SAAO;AACX;;;ACdO,SAAS,yBAAyB,WAAW,OAAO;AACvD,MAAIC,UAAS,SAAS,CAAC,GAAG,SAAS;AACnC,MAAI,cAAc,IAAI,IAAI,OAAO,KAAK,SAAS,CAAC;AAChD,QAAM,OAAO;AAAA,IACT,UAAU,SAAU,MAAM,MAAM,QAAQ;AAKpC,UAAI,UACA,OAAO,SAAS,sBAAsB;AACtC,oBAAY,OAAO,KAAK,KAAK,KAAK;AAAA,MACtC;AAAA,IACJ;AAAA,EACJ,CAAC;AACD,cAAY,QAAQ,SAAU,MAAM;AAChC,WAAOA,QAAO,IAAI;AAAA,EACtB,CAAC;AACD,SAAOA;AACX;;;AClBA,SAAS,YAAY,IAAI,SAAS;AAC9B,SAAQ,UAAU,QAAQ,EAAE,IAAI,WAAW,GAAG;AAClD;AACA,SAAS,OAAO,SAAS;AACrB,SAAO,OAAO,YAAY,aAAa,IAAI,WAAW,OAAO,IAAI;AACrE;AACA,SAAS,cAAc,MAAM;AACzB,SAAO,KAAK,QAAQ,UAAU;AAClC;AACA,IAAI;AAAA;AAAA,EAA4B,WAAY;AACxC,aAASC,YAAW,SAAS;AACzB,UAAI;AACA,aAAK,UAAU;AAAA,IACvB;AACA,IAAAA,YAAW,QAAQ,WAAY;AAC3B,aAAO,IAAIA,YAAW,WAAY;AAAE,eAAO,WAAW,GAAG;AAAA,MAAG,CAAC;AAAA,IACjE;AACA,IAAAA,YAAW,OAAO,SAAU,OAAO;AAC/B,UAAI,MAAM,WAAW;AACjB,eAAOA,YAAW,MAAM;AAC5B,aAAO,MAAM,IAAI,MAAM,EAAE,OAAO,SAAU,GAAG,GAAG;AAAE,eAAO,EAAE,OAAO,CAAC;AAAA,MAAG,CAAC;AAAA,IAC3E;AACA,IAAAA,YAAW,QAAQ,SAAU,MAAM,MAAM,OAAO;AAC5C,UAAI,WAAW,OAAO,IAAI;AAC1B,UAAI,YAAY,OAAO,SAAS,IAAIA,YAAW,WAAW,CAAC;AAC3D,UAAI,cAAc,QAAQ,KAAK,cAAc,SAAS,GAAG;AACrD,eAAO,IAAIA,YAAW,SAAU,WAAW;AACvC,iBAAO,KAAK,SAAS,IACjB,SAAS,QAAQ,SAAS,KAAK,WAAW,GAAG,IAC3C,UAAU,QAAQ,SAAS,KAAK,WAAW,GAAG;AAAA,QACxD,CAAC;AAAA,MACL,OACK;AACD,eAAO,IAAIA,YAAW,SAAU,WAAW,SAAS;AAChD,iBAAO,KAAK,SAAS,IACjB,SAAS,QAAQ,WAAW,OAAO,KAAK,WAAW,GAAG,IACpD,UAAU,QAAQ,WAAW,OAAO,KAAK,WAAW,GAAG;AAAA,QACjE,CAAC;AAAA,MACL;AAAA,IACJ;AACA,IAAAA,YAAW,UAAU,SAAU,MAAM,WAAW;AAC5C,aAAQ,KAAK,QAAQ,gBAAgB,UAAU,SAAS,mBAAmB,kBAAkB,SAAS,CAAC,CAAC,CAAC,KAAK,WAAW,GAAG;AAAA,IAChI;AACA,IAAAA,YAAW,SAAS,SAAU,OAAO,QAAQ;AACzC,UAAI,YAAY,OAAO,KAAK;AAC5B,UAAI,cAAc,SAAS,GAAG;AAC1B,mBAAW,YAAY,SAASC,WAAU,KAAK,IAAI,SAAS;AAC5D,eAAO;AAAA,MACX;AACA,UAAI,WAAW,OAAO,MAAM;AAC5B,UAAI,cAAc,QAAQ,GAAG;AACzB,eAAO,IAAID,YAAW,SAAU,WAAW;AACvC,iBAAO,UAAU,QAAQ,WAAW,SAAU,IAAI;AAAE,mBAAO,SAAS,QAAQ,EAAE,KAAK,WAAW,GAAG;AAAA,UAAG,CAAC,KAAK,WAAW,GAAG;AAAA,QAC5H,CAAC;AAAA,MACL,OACK;AACD,eAAO,IAAIA,YAAW,SAAU,WAAW,SAAS;AAChD,iBAAQ,UAAU,QAAQ,WAAW,SAAU,IAAI;AAC/C,mBAAO,SAAS,QAAQ,IAAI,OAAO,KAAK,WAAW,GAAG;AAAA,UAC1D,CAAC,KAAK,WAAW,GAAG;AAAA,QACxB,CAAC;AAAA,MACL;AAAA,IACJ;AACA,IAAAA,YAAW,UAAU,QAAQ,SAAU,MAAM,MAAM,OAAO;AACtD,aAAO,KAAK,OAAOA,YAAW,MAAM,MAAM,MAAM,SAAS,IAAIA,YAAW,WAAW,CAAC,CAAC;AAAA,IACzF;AACA,IAAAA,YAAW,UAAU,SAAS,SAAU,MAAM;AAC1C,aAAOA,YAAW,OAAO,MAAM,IAAI;AAAA,IACvC;AACA,IAAAA,YAAW,UAAU,UAAU,SAAU,WAAW,SAAS;AACzD,YAAM,kBAAkB,EAAE;AAAA,IAC9B;AACA,IAAAA,YAAW,UAAU,UAAU,SAAU,OAAO,UAAU;AACtD,UAAI,YAAY,SAAS,OAAO;AAC5B,iBAAS,MAAM,KAAK;AAOpB,eAAO;AAAA,MACX;AAEA,YAAM;AAAA,IACV;AACA,IAAAA,YAAW,UAAU,aAAa,SAAU,IAAI;AAC5C,WAAK,UAAU;AACf,aAAO;AAAA,IACX;AACA,WAAOA;AAAA,EACX,EAAE;AAAA;;;AC7FK,IAAI,QAAQ,WAAW;;;ACAvB,IAAI,OAAO,WAAW;;;ACAtB,IAAI,QAAQ,WAAW;;;ACAvB,IAAI,SAAS,WAAW;;;ACAxB,IAAI,UAAU,WAAW;;;ACGjB,SAAR,cAA+B,QAAQ;AAC1C,MAAIE;AACJ,MAAI,WAAW,OAAO,OAAO,aAAa,EAAE;AAC5C,SAAOA,MAAK;AAAA,IACJ,MAAM,WAAY;AACd,aAAO,SAAS,KAAK;AAAA,IACzB;AAAA,EACJ,GACAA,IAAG,OAAO,aAAa,IAAI,WAAY;AACnC,WAAO;AAAA,EACX,GACAA;AACR;;;ACXe,SAAR,mBAAoC,QAAQ;AAC/C,MAAI,UAAU;AACd,MAAI,QAAQ;AACZ,MAAI,OAAO;AACX,MAAI,OAAO,CAAC;AACZ,MAAI,UAAU,CAAC;AACf,WAAS,OAAO,OAAO;AACnB,QAAI;AACA;AACJ,QAAI,QAAQ,QAAQ;AAChB,UAAI,aAAa,QAAQ,MAAM;AAC/B,UAAI,MAAM,QAAQ,UAAU,KAAK,WAAW,CAAC,GAAG;AAC5C,eAAO,WAAW,CAAC,EAAE,EAAE,OAAO,OAAO,MAAM,MAAM,CAAC;AAAA,MACtD;AAAA,IACJ;AACA,SAAK,KAAK,KAAK;AAAA,EACnB;AACA,WAAS,QAAQ,KAAK;AAClB,YAAQ;AACR,QAAI,MAAM,QAAQ,MAAM;AACxB,QAAI,QAAQ,SAAU,MAAM;AACxB,WAAK,CAAC,EAAE,GAAG;AAAA,IACf,CAAC;AACD,KAAC,WAAW,QAAQ;AAAA,EACxB;AACA,WAAS,QAAQ;AACb,WAAO;AACP,QAAI,MAAM,QAAQ,MAAM;AACxB,QAAI,QAAQ,SAAU,MAAM;AACxB,WAAK,CAAC,EAAE,EAAE,OAAO,QAAW,MAAM,KAAK,CAAC;AAAA,IAC5C,CAAC;AACD,KAAC,WAAW,QAAQ;AAAA,EACxB;AACA,YAAU,WAAY;AAClB,cAAU;AACV,WAAO,eAAe,QAAQ,MAAM;AACpC,WAAO,eAAe,SAAS,OAAO;AACtC,WAAO,eAAe,OAAO,KAAK;AAClC,WAAO,eAAe,UAAU,KAAK;AACrC,WAAO,eAAe,SAAS,KAAK;AAAA,EACxC;AACA,SAAO,GAAG,QAAQ,MAAM;AACxB,SAAO,GAAG,SAAS,OAAO;AAC1B,SAAO,GAAG,OAAO,KAAK;AACtB,SAAO,GAAG,UAAU,KAAK;AACzB,SAAO,GAAG,SAAS,KAAK;AACxB,WAAS,UAAU;AACf,WAAO,IAAI,QAAQ,SAAU,SAAS,QAAQ;AAC1C,UAAI;AACA,eAAO,OAAO,KAAK;AACvB,UAAI,KAAK;AACL,eAAO,QAAQ,EAAE,OAAO,KAAK,MAAM,GAAG,MAAM,MAAM,CAAC;AACvD,UAAI;AACA,eAAO,QAAQ,EAAE,OAAO,QAAW,MAAM,KAAK,CAAC;AACnD,cAAQ,KAAK,CAAC,SAAS,MAAM,CAAC;AAAA,IAClC,CAAC;AAAA,EACL;AACA,MAAI,WAAW;AAAA,IACX,MAAM,WAAY;AACd,aAAO,QAAQ;AAAA,IACnB;AAAA,EACJ;AACA,MAAI,2BAA2B;AAC3B,aAAS,OAAO,aAAa,IAAI,WAAY;AACzC,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX;;;ACpEe,SAAR,gBAAiC,SAAS;AAC7C,MAAI,WAAW;AACf,MAAI,WAAW;AAAA,IACX,MAAM,WAAY;AACd,UAAI;AACA,eAAO,QAAQ,QAAQ;AAAA,UACnB,OAAO;AAAA,UACP,MAAM;AAAA,QACV,CAAC;AACL,iBAAW;AACX,aAAO,IAAI,QAAQ,SAAU,SAAS,QAAQ;AAC1C,gBACK,KAAK,SAAU,OAAO;AACvB,kBAAQ,EAAE,OAAc,MAAM,MAAM,CAAC;AAAA,QACzC,CAAC,EACI,MAAM,MAAM;AAAA,MACrB,CAAC;AAAA,IACL;AAAA,EACJ;AACA,MAAI,2BAA2B;AAC3B,aAAS,OAAO,aAAa,IAAI,WAAY;AACzC,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX;;;ACzBe,SAAR,eAAgC,QAAQ;AAC3C,MAAI,WAAW;AAAA,IACX,MAAM,WAAY;AACd,aAAO,OAAO,KAAK;AAAA,IACvB;AAAA,EACJ;AACA,MAAI,2BAA2B;AAC3B,aAAS,OAAO,aAAa,IAAI,WAAY;AACzC,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX;;;ACRA,SAAS,eAAe,OAAO;AAC3B,SAAO,CAAC,CAAC,MAAM;AACnB;AACA,SAAS,iBAAiB,OAAO;AAC7B,SAAO,CAAC,CAAC,MAAM;AACnB;AACA,SAAS,wBAAwB,OAAO;AACpC,SAAO,CAAC,EAAE,6BACN,MAAM,OAAO,aAAa;AAClC;AACA,SAAS,iBAAiB,OAAO;AAC7B,SAAO,CAAC,CAAC,MAAM;AACnB;AACA,SAAS,OAAO,OAAO;AACnB,SAAO,CAAC,CAAC,MAAM;AACnB;AACA,SAAS,qBAAqB,OAAO;AACjC,SAAO,CAAC,CAAC,MAAM;AACnB;AACO,SAAS,iBAAiB,UAAU;AACvC,MAAI,OAAO;AACX,MAAI,eAAe,QAAQ;AACvB,WAAO,SAAS;AACpB,MAAI,wBAAwB,IAAI;AAC5B,WAAO,cAAc,IAAI;AAC7B,MAAI,iBAAiB,IAAI;AACrB,WAAO,eAAe,KAAK,UAAU,CAAC;AAG1C,MAAI,iBAAiB,IAAI,GAAG;AACxB,WAAO,eAAe,KAAK,OAAO,EAAE,UAAU,CAAC;AAAA,EACnD;AACA,MAAI,OAAO,IAAI;AACX,WAAO,gBAAgB,KAAK,YAAY,CAAC;AAC7C,MAAI,qBAAqB,IAAI;AACzB,WAAO,mBAAmB,IAAI;AAClC,QAAM,IAAI,MAAM,4EAA4E;AAChG;;;ACxCO,IAAI,yBAAyB,OAAO;AACpC,SAAS,+BAA+BC,SAAQ;AACnD,MAAIA,QAAO,YAAY;AACnB,WAAO,MAAM,QAAQA,QAAO,WAAW,sBAAsB,CAAC;AAAA,EAClE;AACA,SAAO;AACX;AACO,SAAS,cAAc,KAAK;AAC/B,SAAO,IAAI,eAAe,eAAe;AAC7C;AAKA,IAAI,uBAAuB,SAAU,KAAK;AACtC,MAAI,SAAS,cAAc,cAAc,cAAc,CAAC,GAAG,IAAI,eAAe,IAAI,GAAG,IAAI,cAAc,IAAI,GAAG,IAAI,gBAAgB,IAAI;AACtI,MAAI,IAAI;AACJ,WAAO,KAAK,IAAI,YAAY;AAChC,SAAQ,OAEH,IAAI,SAAUC,MAAK;AACpB,WAAQ,gBAAgBA,IAAG,KAAKA,KAAI,WAAY;AAAA,EACpD,CAAC,EACI,KAAK,IAAI;AAClB;AACA,IAAI;AAAA;AAAA,EAA6B,SAAU,QAAQ;AAC/C,cAAUC,cAAa,MAAM;AAI7B,aAASA,aAAYC,KAAI;AACrB,UAAI,gBAAgBA,IAAG,eAAe,iBAAiBA,IAAG,gBAAgB,eAAeA,IAAG,cAAc,eAAeA,IAAG,cAAc,eAAeA,IAAG,cAAc,YAAYA,IAAG;AACzL,UAAI,QAAQ,OAAO,KAAK,MAAM,YAAY,KAAK;AAC/C,YAAM,OAAO;AACb,YAAM,gBAAgB,iBAAiB,CAAC;AACxC,YAAM,iBAAiB,kBAAkB,CAAC;AAC1C,YAAM,eAAe,gBAAgB,CAAC;AACtC,YAAM,eAAe,gBAAgB;AACrC,YAAM,UAAU,gBAAgB,qBAAqB,KAAK;AAC1D,YAAM,YAAY;AAGlB,YAAM,YAAYD,aAAY;AAC9B,aAAO;AAAA,IACX;AACA,WAAOA;AAAA,EACX,EAAE,KAAK;AAAA;;;AC/CP,IAAIE,kBAAiB,OAAO,UAAU;AAC/B,SAAS,kBAAkB,UAAU,WAAW;AACnD,MAAIC;AACJ,SAAO,UAAU,MAAM,QAAQ,QAAQ,WAAY;AAC/C,QAAI,SAAS,aAAa,WAAW,aAAa,UAAU,QAAQ,UAAU,SAAS,IAAI,OAAO,MAAM,OAAO,YAAY,IAAI,SAAS,GAAG,SAAS,eAAe,MAAMC,SAAQ;AACjL,QAAI,IAAI;AACR,WAAO,YAAY,MAAM,SAAU,IAAI;AACnC,cAAQ,GAAG,OAAO;AAAA,QACd,KAAK;AACD,cAAI,gBAAgB,QAAW;AAC3B,kBAAM,IAAI,MAAM,2EAA2E;AAAA,UAC/F;AACA,oBAAU,IAAI,YAAY,OAAO;AACjC,yBAAeD,MAAK,SAAS,aAAa,QAAQA,QAAO,SAAS,SAASA,IAAG,IAAI,cAAc;AAChG,sBAAY;AACZ,yBAAe,gBAAgB,QAAQ,gBAAgB,SAAS,SAAS,YAAY,SAAS,SAAS,KACnG,gBAAgB,QAAQ,gBAAgB,SAAS,SAAS,YAAY,WAAW,gBAAgB,QAAQ,gBAAgB,SAAS,SAAS,YAAY,QAAQ,SAAS,KAAK,UAAU,MAAM,EAAE,QAAQ,SAAS,EAAE,EAAE,QAAQ,YAAY,EAAE,EAAE,KAAK,IAC/O;AACN,qBAAW,SAAS,OAAO,WAAW;AACtC,mBAAS;AACT,qBAAW,iBAAiB,QAAQ;AACpC,oBAAU;AACV,aAAG,QAAQ;AAAA,QACf,KAAK;AACD,cAAI,CAAC;AAAS,mBAAO,CAAC,GAAa,CAAC;AACpC,iBAAO,CAAC,GAAa,SAAS,KAAK,CAAC;AAAA,QACxC,KAAK;AACD,eAAK,GAAG,KAAK,GAAG,QAAQ,GAAG,OAAO,OAAO,GAAG;AAC5C,kBAAQ,OAAO,UAAU,WAAW,QAAQ,QAAQ,OAAO,KAAK;AAChE,uBAAa,OAAO,SAAS,SAAS,SAAS;AAC/C,oBAAU,CAAC;AACX,oBAAU;AACV,eAAK,OAAO,QAAQ,UAAU,UAAU;AACxC,iBAAO,KAAK,IAAI;AACZ,sBAAU;AACV,iBAAK;AAAA,cACD,OAAO,MAAM,GAAG,EAAE;AAAA,cAClB,OAAO,MAAM,KAAK,SAAS,MAAM;AAAA,YACrC,GAAG,UAAU,GAAG,CAAC,GAAG,SAAS,GAAG,CAAC;AACjC,gBAAI,QAAQ,QAAQ,UAAU;AAC9B,sBAAU,aAAa,QAAQ,MAAM,GAAG,CAAC,CAAC;AAC1C,4BAAgB,QAAQ,cAAc;AACtC,gBAAI,iBACA,cAAc,YAAY,EAAE,QAAQ,kBAAkB,MAAM,IAAI;AAChE,oBAAM,IAAI,MAAM,+DAA+D;AAAA,YACnF;AACA,mBAAO,QAAQ,MAAM,CAAC;AACtB,gBAAI,MAAM;AACN,cAAAC,UAAS,cAAc,UAAU,IAAI;AACrC,kBAAI,OAAO,KAAKA,OAAM,EAAE,SAAS,KAC7B,UAAUA,WACV,iBAAiBA,WACjB,YAAYA,WACZ,aAAaA,SAAQ;AACrB,oBAAI,sBAAsBA,OAAM,GAAG;AAC/B,yBAAO,CAAC;AACR,sBAAI,aAAaA,SAAQ;AACrB,2BAAO,SAAS,CAAC,GAAGA,QAAO,OAAO;AAAA,kBACtC;AACA,sBAAI,YAAYA,SAAQ;AACpB,2BAAO,SAAS,SAAS,CAAC,GAAG,IAAI,GAAG,EAAE,YAAY,SAAS,SAAS,CAAC,GAAI,gBAAgB,OAAO,KAAK,aAAa,IAAK,IAAI,KAAK,CAAC,GAAG,GAAG,sBAAsB,IAAIA,QAAO,QAAQ,GAAG,EAAE,CAAC;AAAA,kBAC1L;AACA,4BAAU,IAAI;AAAA,gBAClB,OACK;AAGD,4BAAUA,OAAM;AAAA,gBACpB;AAAA,cACJ;AAAA;AAAA;AAAA,gBAIA,OAAO,KAAKA,OAAM,EAAE,WAAW,KAC3B,aAAaA,WACb,CAACA,QAAO;AAAA,gBAAS;AACjB,uBAAO;AAAA,kBAAC;AAAA;AAAA,gBAAY;AAAA,cACxB;AAAA,YACJ;AACA,iBAAK,OAAO,QAAQ,QAAQ;AAAA,UAChC;AACA,iBAAO,CAAC,GAAa,CAAC;AAAA,QAC1B,KAAK;AAAG,iBAAO;AAAA,YAAC;AAAA;AAAA,UAAY;AAAA,MAChC;AAAA,IACJ,CAAC;AAAA,EACL,CAAC;AACL;AACO,SAAS,aAAa,YAAY;AACrC,MAAI,cAAc,CAAC;AACnB,aAAW,MAAM,IAAI,EAAE,QAAQ,SAAU,MAAM;AAC3C,QAAI,IAAI,KAAK,QAAQ,GAAG;AACxB,QAAI,IAAI,IAAI;AAER,UAAI,SAAS,KAAK,MAAM,GAAG,CAAC,EAAE,KAAK,EAAE,YAAY;AACjD,UAAI,QAAQ,KAAK,MAAM,IAAI,CAAC,EAAE,KAAK;AACnC,kBAAY,MAAM,IAAI;AAAA,IAC1B;AAAA,EACJ,CAAC;AACD,SAAO;AACX;AACO,SAAS,cAAc,UAAU,UAAU;AAC9C,MAAI,SAAS,UAAU,KAAK;AAExB,QAAI,YAAY,WAAY;AACxB,UAAI;AACA,eAAO,KAAK,MAAM,QAAQ;AAAA,MAC9B,SACO,KAAK;AACR,eAAO;AAAA,MACX;AAAA,IACJ;AACA,qBAAiB,UAAU,UAAU,GAAG,iDAAiD,OAAO,SAAS,MAAM,CAAC;AAAA,EACpH;AACA,MAAI;AACA,WAAO,KAAK,MAAM,QAAQ;AAAA,EAC9B,SACO,KAAK;AACR,QAAI,aAAa;AACjB,eAAW,OAAO;AAClB,eAAW,WAAW;AACtB,eAAW,aAAa,SAAS;AACjC,eAAW,WAAW;AACtB,UAAM;AAAA,EACV;AACJ;AACO,SAAS,YAAY,KAAK,UAAU;AAMvC,MAAI,IAAI,UAAU,IAAI,OAAO,UAAU,IAAI,OAAO,MAAM;AA4BpD,aAAS,KAAK,IAAI,MAAM;AAAA,EAC5B;AACA,WAAS,MAAM,GAAG;AACtB;AACO,SAAS,0BAA0B,YAAY;AAClD,SAAO,SAAU,UAAU;AACvB,WAAO,SACF,KAAK,EACL,KAAK,SAAU,UAAU;AAAE,aAAO,cAAc,UAAU,QAAQ;AAAA,IAAG,CAAC,EACtE,KAAK,SAAUA,SAAQ;AACxB,UAAI,CAAC,MAAM,QAAQA,OAAM,KACrB,CAACF,gBAAe,KAAKE,SAAQ,MAAM,KACnC,CAACF,gBAAe,KAAKE,SAAQ,QAAQ,GAAG;AAExC,yBAAiB,UAAUA,SAAQ,0CAA0C,OAAO,MAAM,QAAQ,UAAU,IACxG,WAAW,IAAI,SAAU,IAAI;AAAE,iBAAO,GAAG;AAAA,QAAe,CAAC,IACvD,WAAW,eAAe,IAAI,CAAC;AAAA,MACzC;AACA,aAAOA;AAAA,IACX,CAAC;AAAA,EACL;AACJ;;;ACxLO,IAAI,0BAA0B,SAAU,GAAG,OAAO;AACrD,MAAI;AACJ,MAAI;AACA,iBAAa,KAAK,UAAU,CAAC;AAAA,EACjC,SACO,GAAG;AACN,QAAI,aAAa,kBAAkB,IAAI,OAAO,EAAE,OAAO;AACvD,eAAW,aAAa;AACxB,UAAM;AAAA,EACV;AACA,SAAO;AACX;;;ACVA,IAAI,qBAAqB;AAAA,EACrB,cAAc;AAAA,EACd,mBAAmB;AAAA,EACnB,oBAAoB;AACxB;AACA,IAAI,iBAAiB;AAAA;AAAA,EAEjB,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaR,gBAAgB;AACpB;AACA,IAAI,iBAAiB;AAAA,EACjB,QAAQ;AACZ;AACO,IAAI,qBAAqB;AAAA,EAC5B,MAAM;AAAA,EACN,SAAS;AAAA,EACT,SAAS;AACb;AACO,IAAI,iBAAiB,SAAU,KAAK,SAAS;AAAE,SAAO,QAAQ,GAAG;AAAG;AACpE,SAAS,yBAAyB,WAAW,gBAAgB;AAChE,MAAI,UAAU,CAAC;AACf,WAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,YAAQ,KAAK,CAAC,IAAI,UAAU,EAAE;AAAA,EAClC;AACA,UAAQ,QAAQ,cAAc;AAC9B,SAAO,iCAAiC,MAAM,QAAQ,cAAc;AAAA,IAAC;AAAA,IACjE;AAAA,EAAc,GAAG,SAAS,KAAK,CAAC;AACxC;AACO,SAAS,iCAAiC,WAAW,SAAS;AACjE,MAAI,UAAU,CAAC;AACf,WAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,YAAQ,KAAK,CAAC,IAAI,UAAU,EAAE;AAAA,EAClC;AACA,MAAI,UAAU,CAAC;AACf,MAAI,OAAO,CAAC;AACZ,UAAQ,QAAQ,SAAU,QAAQ;AAC9B,cAAU,SAAS,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,OAAO,OAAO,GAAG,EAAE,SAAS,SAAS,SAAS,CAAC,GAAG,QAAQ,OAAO,GAAG,OAAO,OAAO,EAAE,CAAC;AACxI,QAAI,OAAO,aAAa;AACpB,cAAQ,cAAc,OAAO;AAAA,IACjC;AACA,WAAO,SAAS,SAAS,CAAC,GAAG,IAAI,GAAG,OAAO,IAAI;AAAA,EACnD,CAAC;AACD,MAAI,QAAQ,SAAS;AACjB,YAAQ,UAAU,uBAAuB,QAAQ,SAAS,KAAK,kBAAkB;AAAA,EACrF;AAEA,MAAI,gBAAgB,UAAU,eAAe,aAAa,UAAU,YAAY,YAAY,UAAU,WAAW,QAAQ,UAAU;AACnI,MAAI,OAAO,EAAE,eAA8B,UAAqB;AAChE,MAAI,KAAK;AACL,SAAK,aAAa;AAEtB,MAAI,KAAK;AACL,SAAK,QAAQ,QAAQ,OAAOC,MAAK;AACrC,SAAO;AAAA,IACH;AAAA,IACA;AAAA,EACJ;AACJ;AAIA,SAAS,uBAAuB,SAAS,oBAAoB;AAEzD,MAAI,CAAC,oBAAoB;AACrB,QAAI,sBAAsB,uBAAO,OAAO,IAAI;AAC5C,WAAO,KAAK,OAAO,OAAO,CAAC,EAAE,QAAQ,SAAU,MAAM;AACjD,0BAAoB,KAAK,YAAY,CAAC,IAAI,QAAQ,IAAI;AAAA,IAC1D,CAAC;AACD,WAAO;AAAA,EACX;AAKA,MAAI,aAAa,uBAAO,OAAO,IAAI;AACnC,SAAO,KAAK,OAAO,OAAO,CAAC,EAAE,QAAQ,SAAU,MAAM;AACjD,eAAW,KAAK,YAAY,CAAC,IAAI;AAAA,MAC7B,cAAc;AAAA,MACd,OAAO,QAAQ,IAAI;AAAA,IACvB;AAAA,EACJ,CAAC;AACD,MAAI,oBAAoB,uBAAO,OAAO,IAAI;AAC1C,SAAO,KAAK,UAAU,EAAE,QAAQ,SAAU,MAAM;AAC5C,sBAAkB,WAAW,IAAI,EAAE,YAAY,IAAI,WAAW,IAAI,EAAE;AAAA,EACxE,CAAC;AACD,SAAO;AACX;;;ACnGO,IAAI,eAAe,SAAU,SAAS;AACzC,MAAI,CAAC,WAAW,OAAO,UAAU,aAAa;AAC1C,UAAM,kBAAkB,EAAE;AAAA,EAC9B;AACJ;;;ACAO,IAAI,0BAA0B,WAAY;AAC7C,MAAI,OAAO,oBAAoB;AAC3B,WAAO,EAAE,YAAY,OAAO,QAAQ,MAAM;AAC9C,MAAI,aAAa,IAAI,gBAAgB;AACrC,MAAI,SAAS,WAAW;AACxB,SAAO,EAAE,YAAwB,OAAe;AACpD;;;ACXO,IAAI,YAAY,SAAU,WAAW,aAAa;AACrD,MAAI,UAAU,UAAU,WAAW;AACnC,MAAI,aAAa,QAAQ;AACzB,MAAI,YAAY;AACZ,WAAO;AAAA,EACX,WACS,OAAO,gBAAgB,YAAY;AACxC,WAAO,YAAY,SAAS;AAAA,EAChC,OACK;AACD,WAAO,eAAe;AAAA,EAC1B;AACJ;;;ACTO,SAAS,iBAAiB,WAAW,MAAM;AAG9C,MAAI,cAAc,CAAC;AACnB,MAAI,gBAAgB,SAAU,KAAK,OAAO;AACtC,gBAAY,KAAK,GAAG,OAAO,KAAK,GAAG,EAAE,OAAO,mBAAmB,KAAK,CAAC,CAAC;AAAA,EAC1E;AACA,MAAI,WAAW,MAAM;AACjB,kBAAc,SAAS,KAAK,KAAK;AAAA,EACrC;AACA,MAAI,KAAK,eAAe;AACpB,kBAAc,iBAAiB,KAAK,aAAa;AAAA,EACrD;AACA,MAAI,KAAK,WAAW;AAChB,QAAI,sBAAsB;AAC1B,QAAI;AACA,4BAAsB,wBAAwB,KAAK,WAAW,eAAe;AAAA,IACjF,SACO,YAAY;AACf,aAAO,EAAE,WAAuB;AAAA,IACpC;AACA,kBAAc,aAAa,mBAAmB;AAAA,EAClD;AACA,MAAI,KAAK,YAAY;AACjB,QAAI,uBAAuB;AAC3B,QAAI;AACA,6BAAuB,wBAAwB,KAAK,YAAY,gBAAgB;AAAA,IACpF,SACO,YAAY;AACf,aAAO,EAAE,WAAuB;AAAA,IACpC;AACA,kBAAc,cAAc,oBAAoB;AAAA,EACpD;AAOA,MAAI,WAAW,IAAI,cAAc;AACjC,MAAI,gBAAgB,UAAU,QAAQ,GAAG;AACzC,MAAI,kBAAkB,IAAI;AACtB,eAAW,UAAU,OAAO,aAAa;AACzC,kBAAc,UAAU,OAAO,GAAG,aAAa;AAAA,EACnD;AACA,MAAI,oBAAoB,YAAY,QAAQ,GAAG,MAAM,KAAK,MAAM;AAChE,MAAI,SAAS,cAAc,oBAAoB,YAAY,KAAK,GAAG,IAAI;AACvE,SAAO,EAAE,OAAe;AAC5B;;;ACvCA,IAAI,cAAc,MAAM,WAAY;AAAE,SAAO;AAAO,CAAC;AAC9C,IAAI,iBAAiB,SAAU,aAAa;AAC/C,MAAI,gBAAgB,QAAQ;AAAE,kBAAc,CAAC;AAAA,EAAG;AAChD,MAAIC,MAAK,YAAY,KAAK,MAAMA,QAAO,SAAS,aAAaA,KAE7D,iBAAiB,YAAY,OAAO,KAAK,YAAY,OAAOC,SAAQ,OAAO,SAAS,iBAAiB,IAAI,oBAAoB,YAAY,mBAAmB,qBAAqB,YAAY,oBAAoB,mBAAmB,YAAY,kBAAkB,KAAK,YAAY,wBAAwB,yBAAyB,OAAO,SAAS,QAAQ,IAAI,iBAAiB,OAAO,aAAa,CAAC,OAAO,SAAS,SAAS,qBAAqB,sBAAsB,oBAAoB,wBAAwB,CAAC;AACvf,MAAI,WAAW,YAAY,OAAO;AAG9B,iBAAa,kBAAkB,WAAW;AAAA,EAC9C;AACA,MAAI,aAAa;AAAA,IACb,MAAM,EAAE,mBAAsC,mBAAuC;AAAA,IACrF,SAAS,eAAe;AAAA,IACxB,aAAa,eAAe;AAAA,IAC5B,SAAS,eAAe;AAAA,EAC5B;AACA,SAAO,IAAI,WAAW,SAAU,WAAW;AACvC,QAAI,YAAY,UAAU,WAAW,GAAG;AACxC,QAAI,UAAU,UAAU,WAAW;AAOnC,QAAI,yBAAyB,CAAC;AAC9B,QAAI,QAAQ,iBAAiB;AACzB,UAAID,MAAK,QAAQ,iBAAiB,SAASA,IAAG,MAAME,WAAUF,IAAG;AACjE,UAAI,QAAQ;AACR,+BAAuB,2BAA2B,IAAI;AAAA,MAC1D;AACA,UAAIE,UAAS;AACT,+BAAuB,8BAA8B,IAAIA;AAAA,MAC7D;AAAA,IACJ;AACA,QAAI,iBAAiB,SAAS,SAAS,CAAC,GAAG,sBAAsB,GAAG,QAAQ,OAAO;AACnF,QAAI,gBAAgB;AAAA,MAChB,MAAM,QAAQ;AAAA,MACd,SAAS,QAAQ;AAAA,MACjB,aAAa,QAAQ;AAAA,MACrB,SAAS;AAAA,IACb;AACA,QAAI,cAAc,CAAC,QAAQ,GAAG,UAAU,KAAK,GAAG;AAC5C,UAAI,mBAAmB,6BAA6B,UAAU,KAAK;AACnE,UAAI,CAAC,kBAAkB;AACnB,eAAO,UAAU,IAAI,MAAM,uMAAuM,CAAC;AAAA,MACvO;AACA,gBAAU,QAAQ;AAAA,IACtB;AAEA,QAAIC,MAAK,iCAAiC,WAAWF,QAAO,oBAAoB,YAAY,aAAa,GAAG,UAAUE,IAAG,SAAS,OAAOA,IAAG;AAC5I,QAAI,KAAK,aAAa,CAAC,wBAAwB;AAC3C,WAAK,YAAY,yBAAyB,KAAK,WAAW,UAAU,KAAK;AAAA,IAC7E;AACA,QAAI;AACJ,QAAI,CAAC,QAAQ,UAAU,OAAO,oBAAoB,aAAa;AAC3D,mBAAa,IAAI,gBAAgB;AACjC,cAAQ,SAAS,WAAW;AAAA,IAChC;AAEA,QAAI,uBAAuB,SAAU,GAAG;AACpC,aAAO,EAAE,SAAS,yBAAyB,EAAE,cAAc;AAAA,IAC/D;AACA,QAAI,2BAA2B,SAAU,GAAG;AACxC,aAAO,EAAE,SAAS,yBAAyB,EAAE,cAAc;AAAA,IAC/D;AACA,QAAI,iBAAiB,yBAAyB,kBAAkB,UAAU,KAAK,CAAC;AAEhF,QAAI,WAAW,cAAc,CAAC,OAAO,GAAG,UAAU,KAAK;AACvD,QAAI,oBACA,CAAC,UAAU,MAAM,YAAY,KAAK,oBAAoB,GAAG;AACzD,cAAQ,SAAS;AAAA,IACrB;AACA,QAAI,YAAY,gBAAgB;AAC5B,cAAQ,UAAU,QAAQ,WAAW,CAAC;AACtC,UAAI,eAAe;AAGnB,UAAI,kBAAkB,UAAU;AAC5B,mBAAW,YAAY,SAASC,WAAU,KAAK,EAAE;AAAA,MACrD;AACA,UAAI,gBAAgB;AAChB,wBACI;AAAA,MACR,WACS,UAAU;AACf,wBAAgB;AAAA,MACpB;AACA,cAAQ,QAAQ,SAAS;AAAA,IAC7B;AACA,QAAI,QAAQ,WAAW,OAAO;AAC1B,UAAIC,MAAK,iBAAiB,WAAW,IAAI,GAAG,SAASA,IAAG,QAAQ,aAAaA,IAAG;AAChF,UAAI,YAAY;AACZ,eAAO,UAAU,UAAU;AAAA,MAC/B;AACA,kBAAY;AAAA,IAChB,OACK;AACD,UAAI;AACA,gBAAQ,OAAO,wBAAwB,MAAM,SAAS;AAAA,MAC1D,SACOC,aAAY;AACf,eAAO,UAAUA,WAAU;AAAA,MAC/B;AAAA,IACJ;AACA,WAAO,IAAI,WAAW,SAAU,UAAU;AAMtC,UAAI,eAAe,kBAAkB,MAAM,WAAY;AAAE,eAAO;AAAA,MAAO,CAAC,KAAK;AAC7E,UAAI,eAAe,SAAS,KAAK,KAAK,QAAQ;AAC9C,mBAAa,WAAW,OAAO,EAC1B,KAAK,SAAU,UAAU;AAC1B,YAAIN;AACJ,kBAAU,WAAW,EAAE,SAAmB,CAAC;AAC3C,YAAI,SAASA,MAAK,SAAS,aAAa,QAAQA,QAAO,SAAS,SAASA,IAAG,IAAI,cAAc;AAC9F,YAAI,UAAU,QAAQ,qBAAqB,KAAK,KAAK,GAAG;AACpD,iBAAO,kBAAkB,UAAU,YAAY;AAAA,QACnD,OACK;AACD,iBAAO,0BAA0B,SAAS,EAAE,QAAQ,EAAE,KAAK,YAAY;AAAA,QAC3E;AAAA,MACJ,CAAC,EACI,KAAK,WAAY;AAClB,qBAAa;AACb,iBAAS,SAAS;AAAA,MACtB,CAAC,EACI,MAAM,SAAU,KAAK;AACtB,qBAAa;AACb,oBAAY,KAAK,QAAQ;AAAA,MAC7B,CAAC;AACD,aAAO,WAAY;AAGf,YAAI;AACA,qBAAW,MAAM;AAAA,MACzB;AAAA,IACJ,CAAC;AAAA,EACL,CAAC;AACL;;;ACvJA,IAAI;AAAA;AAAA,EAA0B,SAAU,QAAQ;AAC5C,cAAUO,WAAU,MAAM;AAC1B,aAASA,UAAS,SAAS;AACvB,UAAI,YAAY,QAAQ;AAAE,kBAAU,CAAC;AAAA,MAAG;AACxC,UAAI,QAAQ,OAAO,KAAK,MAAM,eAAe,OAAO,EAAE,OAAO,KAAK;AAClE,YAAM,UAAU;AAChB,aAAO;AAAA,IACX;AACA,WAAOA;AAAA,EACX,EAAE,UAAU;AAAA;;;ACZZ,IAAM,EAAE,UAAAC,WAAU,gBAAAC,gBAAe,IAAI,OAAO;AAC5C,IAAM,UAAU,SAAS,UAAU;AACnC,IAAM,sBAAsB,oBAAI,IAAI;AAI7B,SAAS,MAAM,GAAG,GAAG;AACxB,MAAI;AACA,WAAO,MAAM,GAAG,CAAC;AAAA,EACrB,UACA;AACI,wBAAoB,MAAM;AAAA,EAC9B;AACJ;AAEA,IAAO,cAAQ;AACf,SAAS,MAAM,GAAG,GAAG;AAEjB,MAAI,MAAM,GAAG;AACT,WAAO;AAAA,EACX;AAGA,QAAM,OAAOD,UAAS,KAAK,CAAC;AAC5B,QAAM,OAAOA,UAAS,KAAK,CAAC;AAI5B,MAAI,SAAS,MAAM;AACf,WAAO;AAAA,EACX;AACA,UAAQ,MAAM;AAAA,IACV,KAAK;AAGD,UAAI,EAAE,WAAW,EAAE;AACf,eAAO;AAAA,IAEf,KAAK,mBAAmB;AACpB,UAAI,mBAAmB,GAAG,CAAC;AACvB,eAAO;AACX,YAAM,QAAQ,YAAY,CAAC;AAC3B,YAAM,QAAQ,YAAY,CAAC;AAG3B,YAAM,WAAW,MAAM;AACvB,UAAI,aAAa,MAAM;AACnB,eAAO;AAEX,eAAS,IAAI,GAAG,IAAI,UAAU,EAAE,GAAG;AAC/B,YAAI,CAACC,gBAAe,KAAK,GAAG,MAAM,CAAC,CAAC,GAAG;AACnC,iBAAO;AAAA,QACX;AAAA,MACJ;AAEA,eAAS,IAAI,GAAG,IAAI,UAAU,EAAE,GAAG;AAC/B,cAAM,MAAM,MAAM,CAAC;AACnB,YAAI,CAAC,MAAM,EAAE,GAAG,GAAG,EAAE,GAAG,CAAC,GAAG;AACxB,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAAA,IACA,KAAK;AACD,aAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,YAAY,EAAE;AAAA,IAChD,KAAK;AAED,UAAI,MAAM;AACN,eAAO,MAAM;AAAA,IAErB,KAAK;AAAA,IACL,KAAK;AACD,aAAO,CAAC,MAAM,CAAC;AAAA,IACnB,KAAK;AAAA,IACL,KAAK;AACD,aAAO,KAAK,GAAG,CAAC;AAAA,IACpB,KAAK;AAAA,IACL,KAAK,gBAAgB;AACjB,UAAI,EAAE,SAAS,EAAE;AACb,eAAO;AACX,UAAI,mBAAmB,GAAG,CAAC;AACvB,eAAO;AACX,YAAM,YAAY,EAAE,QAAQ;AAC5B,YAAM,QAAQ,SAAS;AACvB,aAAO,MAAM;AACT,cAAM,OAAO,UAAU,KAAK;AAC5B,YAAI,KAAK;AACL;AAEJ,cAAM,CAAC,MAAM,MAAM,IAAI,KAAK;AAE5B,YAAI,CAAC,EAAE,IAAI,IAAI,GAAG;AACd,iBAAO;AAAA,QACX;AAGA,YAAI,SAAS,CAAC,MAAM,QAAQ,EAAE,IAAI,IAAI,CAAC,GAAG;AACtC,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAAA,IACA,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAGD,UAAI,IAAI,WAAW,CAAC;AACpB,UAAI,IAAI,WAAW,CAAC;AAAA,IAExB,KAAK,qBAAqB;AACtB,UAAI,MAAM,EAAE;AACZ,UAAI,QAAQ,EAAE,YAAY;AACtB,eAAO,SAAS,EAAE,GAAG,MAAM,EAAE,GAAG,GAAG;AAAA,QAEnC;AAAA,MACJ;AACA,aAAO,QAAQ;AAAA,IACnB;AAAA,IACA,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK,qBAAqB;AACtB,YAAM,QAAQ,QAAQ,KAAK,CAAC;AAC5B,UAAI,UAAU,QAAQ,KAAK,CAAC,GAAG;AAC3B,eAAO;AAAA,MACX;AAwBA,aAAO,CAAC,SAAS,OAAO,gBAAgB;AAAA,IAC5C;AAAA,EACJ;AAEA,SAAO;AACX;AACA,SAAS,YAAY,KAAK;AAGtB,SAAO,OAAO,KAAK,GAAG,EAAE,OAAO,cAAc,GAAG;AACpD;AACA,SAAS,aAAa,KAAK;AACvB,SAAO,KAAK,GAAG,MAAM;AACzB;AACA,IAAM,mBAAmB;AACzB,SAAS,SAAS,MAAM,QAAQ;AAC5B,QAAM,YAAY,KAAK,SAAS,OAAO;AACvC,SAAO,aAAa,KAChB,KAAK,QAAQ,QAAQ,SAAS,MAAM;AAC5C;AACA,SAAS,mBAAmB,GAAG,GAAG;AAS9B,MAAI,OAAO,oBAAoB,IAAI,CAAC;AACpC,MAAI,MAAM;AAGN,QAAI,KAAK,IAAI,CAAC;AACV,aAAO;AAAA,EACf,OACK;AACD,wBAAoB,IAAI,GAAG,OAAO,oBAAI,KAAG;AAAA,EAC7C;AACA,OAAK,IAAI,CAAC;AACV,SAAO;AACX;;;AC9LA,IAAMC,mBAAkB,MAAM,uBAAO,OAAO,IAAI;AAEhD,IAAM,EAAE,SAAAC,UAAS,OAAAC,OAAM,IAAI,MAAM;AACjC,IAAM,EAAE,gBAAAC,gBAAe,IAAI,OAAO;AAC3B,IAAMC,QAAN,MAAM,MAAK;AAAA,EACd,YAAY,WAAW,MAAM,WAAWJ,kBAAiB;AACrD,SAAK,WAAW;AAChB,SAAK,WAAW;AAAA,EACpB;AAAA,EACA,UAAU,OAAO;AACb,WAAO,KAAK,YAAY,KAAK;AAAA,EACjC;AAAA,EACA,YAAY,OAAO;AACf,QAAI,OAAO;AACX,IAAAC,SAAQ,KAAK,OAAO,SAAO,OAAO,KAAK,aAAa,GAAG,CAAC;AACxD,WAAOE,gBAAe,KAAK,MAAM,MAAM,IACjC,KAAK,OACL,KAAK,OAAO,KAAK,SAASD,OAAM,KAAK,KAAK,CAAC;AAAA,EACrD;AAAA,EACA,QAAQ,OAAO;AACX,WAAO,KAAK,UAAU,KAAK;AAAA,EAC/B;AAAA,EACA,UAAU,OAAO;AACb,QAAI,OAAO;AACX,aAAS,IAAI,GAAG,MAAM,MAAM,QAAQ,QAAQ,IAAI,KAAK,EAAE,GAAG;AACtD,YAAM,MAAM,KAAK,YAAYG,UAAS,MAAM,CAAC,CAAC,IAAI,KAAK,OAAO,KAAK;AACnE,aAAO,OAAO,IAAI,IAAI,MAAM,CAAC,CAAC;AAAA,IAClC;AACA,WAAO,QAAQ,KAAK;AAAA,EACxB;AAAA,EACA,aAAa,KAAK;AACd,UAAM,MAAM,KAAK,YAAYA,UAAS,GAAG,IACnC,KAAK,SAAS,KAAK,OAAO,oBAAI,QAAQ,KACtC,KAAK,WAAW,KAAK,SAAS,oBAAI,IAAI;AAC5C,QAAI,QAAQ,IAAI,IAAI,GAAG;AACvB,QAAI,CAAC;AACD,UAAI,IAAI,KAAK,QAAQ,IAAI,MAAK,KAAK,UAAU,KAAK,QAAQ,CAAC;AAC/D,WAAO;AAAA,EACX;AACJ;AACA,SAASA,UAAS,OAAO;AACrB,UAAQ,OAAO,OAAO;AAAA,IAClB,KAAK;AACD,UAAI,UAAU;AACV;AAAA,IAER,KAAK;AACD,aAAO;AAAA,EACf;AACA,SAAO;AACX;;;ACvDA,SAAS,iBAAiB;AAAE;AACrB,IAAM,cAAN,MAAkB;AAAA,EACrB,YAAY,MAAM,UAAU,UAAU,gBAAgB;AAClD,SAAK,MAAM;AACX,SAAK,UAAU;AACf,SAAK,MAAM,oBAAI,IAAI;AACnB,SAAK,SAAS;AACd,SAAK,SAAS;AAAA,EAClB;AAAA,EACA,IAAI,KAAK;AACL,WAAO,KAAK,IAAI,IAAI,GAAG;AAAA,EAC3B;AAAA,EACA,IAAI,KAAK;AACL,UAAM,OAAO,KAAK,QAAQ,GAAG;AAC7B,WAAO,QAAQ,KAAK;AAAA,EACxB;AAAA,EACA,IAAI,OAAO;AACP,WAAO,KAAK,IAAI;AAAA,EACpB;AAAA,EACA,QAAQ,KAAK;AACT,UAAM,OAAO,KAAK,IAAI,IAAI,GAAG;AAC7B,QAAI,QAAQ,SAAS,KAAK,QAAQ;AAC9B,YAAM,EAAE,OAAO,MAAM,IAAI;AACzB,UAAI,OAAO;AACP,cAAM,QAAQ;AAAA,MAClB;AACA,UAAI,OAAO;AACP,cAAM,QAAQ;AAAA,MAClB;AACA,WAAK,QAAQ,KAAK;AAClB,WAAK,MAAM,QAAQ;AACnB,WAAK,QAAQ;AACb,WAAK,SAAS;AACd,UAAI,SAAS,KAAK,QAAQ;AACtB,aAAK,SAAS;AAAA,MAClB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,IAAI,KAAK,OAAO;AACZ,QAAI,OAAO,KAAK,QAAQ,GAAG;AAC3B,QAAI,MAAM;AACN,aAAO,KAAK,QAAQ;AAAA,IACxB;AACA,WAAO;AAAA,MACH;AAAA,MACA;AAAA,MACA,OAAO;AAAA,MACP,OAAO,KAAK;AAAA,IAChB;AACA,QAAI,KAAK,QAAQ;AACb,WAAK,OAAO,QAAQ;AAAA,IACxB;AACA,SAAK,SAAS;AACd,SAAK,SAAS,KAAK,UAAU;AAC7B,SAAK,IAAI,IAAI,KAAK,IAAI;AACtB,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,QAAQ;AACJ,WAAO,KAAK,UAAU,KAAK,IAAI,OAAO,KAAK,KAAK;AAC5C,WAAK,OAAO,KAAK,OAAO,GAAG;AAAA,IAC/B;AAAA,EACJ;AAAA,EACA,OAAO,KAAK;AACR,UAAM,OAAO,KAAK,IAAI,IAAI,GAAG;AAC7B,QAAI,MAAM;AACN,UAAI,SAAS,KAAK,QAAQ;AACtB,aAAK,SAAS,KAAK;AAAA,MACvB;AACA,UAAI,SAAS,KAAK,QAAQ;AACtB,aAAK,SAAS,KAAK;AAAA,MACvB;AACA,UAAI,KAAK,OAAO;AACZ,aAAK,MAAM,QAAQ,KAAK;AAAA,MAC5B;AACA,UAAI,KAAK,OAAO;AACZ,aAAK,MAAM,QAAQ,KAAK;AAAA,MAC5B;AACA,WAAK,IAAI,OAAO,GAAG;AACnB,WAAK,QAAQ,KAAK,OAAO,GAAG;AAC5B,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AACJ;;;ACjFA,IAAI,iBAAiB;AAGrB,IAAM,gBAAgB,CAAC;AACvB,IAAI,YAAY;AAIhB,IAAM,gBAAgB,MAAM,MAAM,KAAK;AAAA,EACnC,cAAc;AAIV,SAAK,KAAK;AAAA,MACN;AAAA,MACA;AAAA,MACA,KAAK,IAAI;AAAA,MACT,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,CAAC;AAAA,IACtC,EAAE,KAAK,GAAG;AAAA,EACd;AAAA,EACA,WAAW;AACP,aAAS,UAAU,gBAAgB,SAAS,UAAU,QAAQ,QAAQ;AAGlE,UAAI,KAAK,MAAM,QAAQ,OAAO;AAC1B,cAAM,QAAQ,QAAQ,MAAM,KAAK,EAAE;AACnC,YAAI,UAAU;AACV;AACJ,YAAI,YAAY,gBAAgB;AAI5B,yBAAe,MAAM,KAAK,EAAE,IAAI;AAAA,QACpC;AACA,eAAO;AAAA,MACX;AAAA,IACJ;AACA,QAAI,gBAAgB;AAIhB,qBAAe,MAAM,KAAK,EAAE,IAAI;AAAA,IACpC;AACA,WAAO;AAAA,EACX;AAAA,EACA,WAAW;AACP,QAAI,KAAK,SAAS,GAAG;AACjB,aAAO,eAAe,MAAM,KAAK,EAAE;AAAA,IACvC;AAAA,EACJ;AAAA,EACA,UAAU,OAAO,UAGjB,MAAM,SAAS;AACX,UAAM,QAAQ;AAAA,MACV,WAAW;AAAA,MACX,CAAC,KAAK,EAAE,GAAG;AAAA,IACf;AACA,UAAM,SAAS;AACf,qBAAiB,EAAE,QAAQ,MAAM;AACjC,QAAI;AAGA,aAAO,SAAS,MAAM,SAAS,IAAI;AAAA,IACvC,UACA;AACI,uBAAiB;AAAA,IACrB;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,OAAO,KAAK,UAAU;AAClB,UAAM,UAAU;AAChB,WAAO,WAAY;AACf,YAAM,QAAQ;AACd,UAAI;AACA,yBAAiB;AACjB,eAAO,SAAS,MAAM,MAAM,SAAS;AAAA,MACzC,UACA;AACI,yBAAiB;AAAA,MACrB;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA,EAEA,OAAO,UAAU,UAGjB,MAAM,SAAS;AACX,QAAI,gBAAgB;AAChB,YAAM,QAAQ;AACd,UAAI;AACA,yBAAiB;AAGjB,eAAO,SAAS,MAAM,SAAS,IAAI;AAAA,MACvC,UACA;AACI,yBAAiB;AAAA,MACrB;AAAA,IACJ,OACK;AACD,aAAO,SAAS,MAAM,SAAS,IAAI;AAAA,IACvC;AAAA,EACJ;AACJ;AACA,SAASC,OAAM,IAAI;AACf,MAAI;AACA,WAAO,GAAG;AAAA,EACd,SACO,SAAS;AAAA,EAAE;AACtB;AASA,IAAM,YAAY;AAClB,IAAM;AAAA;AAAA;AAAA,EAGNA,OAAM,MAAM,UAAU;AAAA;AAAA;AAAA,EAIlBA,OAAM,MAAM,MAAM;AAAA;AAAA;AAAA,EAIlB,uBAAO,OAAO,IAAI;AAAA;AAGtB,IAAM,aAAa;AACZ,IAAM,OAAO,WAAW,SAAS;AAAA;AAGpC,MAAM,SAAS,KACd,SAAUC,OAAM;AACb,MAAI;AACA,WAAO,eAAe,YAAY,WAAW;AAAA,MACzC,OAAOA;AAAA,MACP,YAAY;AAAA,MACZ,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOV,cAAc;AAAA,IAClB,CAAC;AAAA,EACL,UACA;AACI,WAAOA;AAAA,EACX;AACJ,EAAG,cAAc,CAAC;;;AC/Jf,IAAM,EAAE,MAAM,UAAU,IAAI;;;ACD5B,IAAM,kBAAkB,IAAI,KAAK;;;ACDjC,IAAM,EAAE,gBAAAC,gBAAgB,IAAI,OAAO;AACnC,IAAM,eAAe,MAAM,QAC9B,SAAU,KAAK;AACX,QAAM,QAAQ,CAAC;AACf,MAAI,QAAQ,UAAQ,MAAM,KAAK,IAAI,CAAC;AACpC,SAAO;AACX;AACG,SAAS,iBAAiB,YAAY;AACzC,QAAM,EAAE,YAAY,IAAI;AACxB,MAAI,OAAO,gBAAgB,YAAY;AACnC,eAAW,cAAc;AACzB,gBAAY;AAAA,EAChB;AACJ;;;ACXA,IAAM,eAAe,CAAC;AACtB,IAAM,mBAAmB;AAGzB,SAAS,OAAO,WAAW,iBAAiB;AACxC,MAAI,CAAC,WAAW;AACZ,UAAM,IAAI,MAAM,mBAAmB,mBAAmB;AAAA,EAC1D;AACJ;AACA,SAAS,QAAQ,GAAG,GAAG;AACnB,QAAM,MAAM,EAAE;AACd;AAAA;AAAA,IAEA,MAAM;AAAA,IAEF,QAAQ,EAAE;AAAA,IAEV,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC;AAAA;AAChC;AACA,SAAS,SAAS,OAAO;AACrB,UAAQ,MAAM,QAAQ;AAAA,IAClB,KAAK;AAAG,YAAM,IAAI,MAAM,eAAe;AAAA,IACvC,KAAK;AAAG,aAAO,MAAM,CAAC;AAAA,IACtB,KAAK;AAAG,YAAM,MAAM,CAAC;AAAA,EACzB;AACJ;AACA,SAAS,UAAU,OAAO;AACtB,SAAO,MAAM,MAAM,CAAC;AACxB;AACO,IAAM,QAAN,MAAM,OAAM;AAAA,EACf,YAAY,IAAI;AACZ,SAAK,KAAK;AACV,SAAK,UAAU,oBAAI,IAAI;AACvB,SAAK,cAAc,oBAAI,IAAI;AAI3B,SAAK,gBAAgB;AACrB,SAAK,QAAQ;AACb,SAAK,cAAc;AACnB,SAAK,QAAQ,CAAC;AACd,SAAK,OAAO;AACZ,MAAE,OAAM;AAAA,EACZ;AAAA,EACA,OAAO;AACH,QAAI,KAAK,MAAM,WAAW,KAAK,CAAC,aAAa,IAAI,GAAG;AAChD,qBAAe,IAAI;AACnB,aAAO,KAAK,MAAM,CAAC;AAAA,IACvB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU,MAAM;AACZ,WAAO,CAAC,KAAK,aAAa,qBAAqB;AAC/C,mBAAe,IAAI;AACnB,WAAO,aAAa,IAAI,IAClB,gBAAgB,MAAM,IAAI,IAC1B,SAAS,KAAK,KAAK;AAAA,EAC7B;AAAA,EACA,WAAW;AACP,QAAI,KAAK;AACL;AACJ,SAAK,QAAQ;AACb,gBAAY,IAAI;AAIhB,qBAAiB,IAAI;AAAA,EACzB;AAAA,EACA,UAAU;AACN,SAAK,SAAS;AAId,mBAAe,IAAI;AAYnB,eAAW,MAAM,CAAC,QAAQ,UAAU;AAChC,aAAO,SAAS;AAChB,kBAAY,QAAQ,IAAI;AAAA,IAC5B,CAAC;AAAA,EACL;AAAA,EACA,SAAS;AAIL,SAAK,QAAQ;AAAA,EACjB;AAAA,EACA,SAASC,MAAK;AACV,IAAAA,KAAI,IAAI,IAAI;AACZ,QAAI,CAAC,KAAK,MAAM;AACZ,WAAK,OAAO,aAAa,IAAI,KAAK,oBAAI,IAAI;AAAA,IAC9C;AACA,SAAK,KAAK,IAAIA,IAAG;AAAA,EACrB;AAAA,EACA,aAAa;AACT,QAAI,KAAK,MAAM;AACX,mBAAa,KAAK,IAAI,EAAE,QAAQ,CAAAA,SAAOA,KAAI,OAAO,IAAI,CAAC;AACvD,WAAK,KAAK,MAAM;AAChB,mBAAa,KAAK,KAAK,IAAI;AAC3B,WAAK,OAAO;AAAA,IAChB;AAAA,EACJ;AACJ;AACA,MAAM,QAAQ;AACd,SAAS,eAAe,OAAO;AAC3B,QAAM,SAAS,gBAAgB,SAAS;AACxC,MAAI,QAAQ;AACR,UAAM,QAAQ,IAAI,MAAM;AACxB,QAAI,CAAC,OAAO,YAAY,IAAI,KAAK,GAAG;AAChC,aAAO,YAAY,IAAI,OAAO,CAAC,CAAC;AAAA,IACpC;AACA,QAAI,aAAa,KAAK,GAAG;AACrB,uBAAiB,QAAQ,KAAK;AAAA,IAClC,OACK;AACD,uBAAiB,QAAQ,KAAK;AAAA,IAClC;AACA,WAAO;AAAA,EACX;AACJ;AACA,SAAS,gBAAgB,OAAO,MAAM;AAClC,iBAAe,KAAK;AAEpB,kBAAgB,UAAU,OAAO,mBAAmB,CAAC,OAAO,IAAI,CAAC;AACjE,MAAI,eAAe,OAAO,IAAI,GAAG;AAG7B,aAAS,KAAK;AAAA,EAClB;AACA,SAAO,SAAS,MAAM,KAAK;AAC/B;AACA,SAAS,kBAAkB,OAAO,MAAM;AACpC,QAAM,cAAc;AACpB,QAAM,EAAE,gBAAgB,IAAI;AAC5B,MAAI;AACJ,MAAI,mBAAmB,MAAM,MAAM,WAAW,GAAG;AAC7C,mBAAe,UAAU,MAAM,KAAK;AAAA,EACxC;AAEA,QAAM,MAAM,SAAS;AACrB,MAAI;AAEA,UAAM,MAAM,CAAC,IAAI,MAAM,GAAG,MAAM,MAAM,IAAI;AAK1C,QAAI,mBAAmB,gBAAgB,CAAC,QAAQ,cAAc,MAAM,KAAK,GAAG;AACxE,UAAI;AACA,cAAM,MAAM,CAAC,IAAI,gBAAgB,MAAM,MAAM,CAAC,GAAG,aAAa,CAAC,CAAC;AAAA,MACpE,SACOC,KAAI;AAAA,MAGX;AAAA,IACJ;AAAA,EACJ,SACO,GAAG;AAEN,UAAM,MAAM,CAAC,IAAI;AAAA,EACrB;AAEA,QAAM,cAAc;AACxB;AACA,SAAS,aAAa,OAAO;AACzB,SAAO,MAAM,SAAS,CAAC,EAAE,MAAM,iBAAiB,MAAM,cAAc;AACxE;AACA,SAAS,SAAS,OAAO;AACrB,QAAM,QAAQ;AACd,MAAI,aAAa,KAAK,GAAG;AAGrB;AAAA,EACJ;AACA,cAAY,KAAK;AACrB;AACA,SAAS,YAAY,OAAO;AACxB,aAAW,OAAO,gBAAgB;AACtC;AACA,SAAS,YAAY,OAAO;AACxB,aAAW,OAAO,gBAAgB;AACtC;AACA,SAAS,WAAW,OAAO,UAAU;AACjC,QAAM,cAAc,MAAM,QAAQ;AAClC,MAAI,aAAa;AACb,UAAM,UAAU,aAAa,MAAM,OAAO;AAC1C,aAAS,IAAI,GAAG,IAAI,aAAa,EAAE,GAAG;AAClC,eAAS,QAAQ,CAAC,GAAG,KAAK;AAAA,IAC9B;AAAA,EACJ;AACJ;AAEA,SAAS,iBAAiB,QAAQ,OAAO;AAGrC,SAAO,OAAO,YAAY,IAAI,KAAK,CAAC;AACpC,SAAO,aAAa,KAAK,CAAC;AAC1B,QAAM,iBAAiB,CAAC,aAAa,MAAM;AAC3C,MAAI,CAAC,OAAO,eAAe;AACvB,WAAO,gBAAgB,aAAa,IAAI,KAAK,oBAAI;AAAA,EACrD,WACS,OAAO,cAAc,IAAI,KAAK,GAAG;AAItC;AAAA,EACJ;AACA,SAAO,cAAc,IAAI,KAAK;AAG9B,MAAI,gBAAgB;AAChB,gBAAY,MAAM;AAAA,EACtB;AACJ;AAEA,SAAS,iBAAiB,QAAQ,OAAO;AAGrC,SAAO,OAAO,YAAY,IAAI,KAAK,CAAC;AACpC,SAAO,CAAC,aAAa,KAAK,CAAC;AAC3B,QAAM,aAAa,OAAO,YAAY,IAAI,KAAK;AAC/C,MAAI,WAAW,WAAW,GAAG;AACzB,WAAO,YAAY,IAAI,OAAO,UAAU,MAAM,KAAK,CAAC;AAAA,EACxD,WACS,CAAC,QAAQ,YAAY,MAAM,KAAK,GAAG;AACxC,WAAO,SAAS;AAAA,EACpB;AACA,mBAAiB,QAAQ,KAAK;AAC9B,MAAI,aAAa,MAAM,GAAG;AACtB;AAAA,EACJ;AACA,cAAY,MAAM;AACtB;AACA,SAAS,iBAAiB,QAAQ,OAAO;AACrC,QAAM,KAAK,OAAO;AAClB,MAAI,IAAI;AACJ,OAAG,OAAO,KAAK;AACf,QAAI,GAAG,SAAS,GAAG;AACf,UAAI,aAAa,SAAS,kBAAkB;AACxC,qBAAa,KAAK,EAAE;AAAA,MACxB;AACA,aAAO,gBAAgB;AAAA,IAC3B;AAAA,EACJ;AACJ;AAGA,SAAS,eAAe,QAAQ;AAC5B,MAAI,OAAO,YAAY,OAAO,GAAG;AAC7B,WAAO,YAAY,QAAQ,CAAC,QAAQ,UAAU;AAC1C,kBAAY,QAAQ,KAAK;AAAA,IAC7B,CAAC;AAAA,EACL;AAGA,SAAO,WAAW;AAGlB,SAAO,OAAO,kBAAkB,IAAI;AACxC;AACA,SAAS,YAAY,QAAQ,OAAO;AAChC,QAAM,QAAQ,OAAO,MAAM;AAC3B,SAAO,YAAY,OAAO,KAAK;AAC/B,mBAAiB,QAAQ,KAAK;AAClC;AACA,SAAS,eAAe,OAAO,MAAM;AACjC,MAAI,OAAO,MAAM,cAAc,YAAY;AACvC,QAAI;AACA,uBAAiB,KAAK;AACtB,YAAM,cAAc,MAAM,UAAU,MAAM,MAAM,IAAI;AAAA,IACxD,SACO,GAAG;AAKN,YAAM,SAAS;AACf,aAAO;AAAA,IACX;AAAA,EACJ;AAGA,SAAO;AACX;;;ACzSA,IAAM,eAAe;AAAA,EACjB,UAAU;AAAA,EACV,SAAS;AAAA,EACT,QAAQ;AAAA;AACZ;AACO,SAAS,IAAI,SAAS;AACzB,QAAM,YAAY,oBAAI,IAAI;AAC1B,QAAM,YAAY,WAAW,QAAQ;AACrC,WAAS,OAAO,KAAK;AACjB,UAAM,SAAS,gBAAgB,SAAS;AACxC,QAAI,QAAQ;AACR,UAAIC,OAAM,UAAU,IAAI,GAAG;AAC3B,UAAI,CAACA,MAAK;AACN,kBAAU,IAAI,KAAKA,OAAM,oBAAI,KAAG;AAAA,MACpC;AACA,aAAO,SAASA,IAAG;AACnB,UAAI,OAAO,cAAc,YAAY;AACjC,yBAAiBA,IAAG;AACpB,QAAAA,KAAI,cAAc,UAAU,GAAG;AAAA,MACnC;AAAA,IACJ;AAAA,EACJ;AACA,SAAO,QAAQ,SAAS,MAAM,KAAK,iBAAiB;AAChD,UAAMA,OAAM,UAAU,IAAI,GAAG;AAC7B,QAAIA,MAAK;AACL,YAAM,IAAK,mBACPC,gBAAe,KAAK,cAAc,eAAe,IAAK,kBAAkB;AAI5E,mBAAaD,IAAG,EAAE,QAAQ,WAAS,MAAM,CAAC,EAAE,CAAC;AAC7C,gBAAU,OAAO,GAAG;AACpB,uBAAiBA,IAAG;AAAA,IACxB;AAAA,EACJ;AACA,SAAO;AACX;;;ACfA,IAAI;AACG,SAAS,uBAAuB,MAAM;AACzC,QAAM,OAAO,mBAAmB,iBAAiB,IAAIE,MAAK,OAAO,YAAY,UAAU;AACvF,SAAO,KAAK,YAAY,IAAI;AAChC;AAMA,IAAM,SAAS,oBAAI,IAAI;AAChB,SAASC,MAAK,kBAAkB,EAAE,MAAM,KAAK,IAAI,GAAG,EAAE,GAAG,SAAS,eAAe,qBAAqB,iBAAiB,WAAW,OAAO,cAAc,YAAa,IAAI,uBAAO,OAAO,IAAI,GAAG;AAChM,QAAM,QAAQ,OAAO,gBAAgB,aAC/B,IAAI,YAAY,KAAK,WAAS,MAAM,QAAQ,CAAC,IAC7C;AACN,QAAM,aAAa,WAAY;AAC3B,UAAM,MAAM,aAAa,MAAM,MAAM,UAAU,QAAQ,MAAM,MAAM,SAAS,IAAI,SAAS;AACzF,QAAI,QAAQ,QAAQ;AAChB,aAAO,iBAAiB,MAAM,MAAM,SAAS;AAAA,IACjD;AACA,QAAI,QAAQ,MAAM,IAAI,GAAG;AACzB,QAAI,CAAC,OAAO;AACR,YAAM,IAAI,KAAK,QAAQ,IAAI,MAAM,gBAAgB,CAAC;AAClD,YAAM,kBAAkB;AACxB,YAAM,YAAY;AAGlB,YAAM,SAAS,MAAM,MAAM,OAAO,GAAG;AAAA,IACzC;AACA,UAAM,QAAQ,MAAM,UAAU,MAAM,UAAU,MAAM,KAAK,SAAS,CAAC;AAGnE,UAAM,IAAI,KAAK,KAAK;AACpB,WAAO,IAAI,KAAK;AAIhB,QAAI,CAAC,gBAAgB,SAAS,GAAG;AAC7B,aAAO,QAAQ,CAAAC,WAASA,OAAM,MAAM,CAAC;AACrC,aAAO,MAAM;AAAA,IACjB;AACA,WAAO;AAAA,EACX;AACA,SAAO,eAAe,YAAY,QAAQ;AAAA,IACtC,KAAK,MAAM,MAAM;AAAA,IACjB,cAAc;AAAA,IACd,YAAY;AAAA,EAChB,CAAC;AACD,SAAO,OAAO,WAAW,UAAU;AAAA,IAC/B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ,CAAC;AACD,WAAS,SAAS,KAAK;AACnB,UAAM,QAAQ,OAAO,MAAM,IAAI,GAAG;AAClC,QAAI,OAAO;AACP,YAAM,SAAS;AAAA,IACnB;AAAA,EACJ;AACA,aAAW,WAAW;AACtB,aAAW,QAAQ,SAAS,QAAQ;AAChC,aAAS,aAAa,MAAM,MAAM,SAAS,CAAC;AAAA,EAChD;AACA,WAAS,QAAQ,KAAK;AAClB,UAAM,QAAQ,OAAO,MAAM,IAAI,GAAG;AAClC,QAAI,OAAO;AACP,aAAO,MAAM,KAAK;AAAA,IACtB;AAAA,EACJ;AACA,aAAW,UAAU;AACrB,aAAW,OAAO,SAAS,OAAO;AAC9B,WAAO,QAAQ,aAAa,MAAM,MAAM,SAAS,CAAC;AAAA,EACtD;AACA,WAAS,UAAU,KAAK;AACpB,WAAO,MAAM,MAAM,OAAO,GAAG,IAAI;AAAA,EACrC;AACA,aAAW,YAAY;AACvB,aAAW,SAAS,SAAS,SAAS;AAClC,WAAO,UAAU,aAAa,MAAM,MAAM,SAAS,CAAC;AAAA,EACxD;AACA,aAAW,eAAe;AAC1B,aAAW,SAAS,UAAU,SAAS,SAAS;AAC5C,WAAO,aAAa,MAAM,MAAM,QAAQ,MAAM,MAAM,SAAS,CAAC;AAAA,EAClE,IAAI;AACJ,SAAO,OAAO,OAAO,UAAU;AACnC;;;AC5GA,IAAI;AAAA;AAAA,EAA6B,WAAY;AACzC,aAASC,eAAc;AACnB,WAAK,yBAAyB;AAG9B,WAAK,iBAAiBC,MAAK,wBAAwB;AAAA,IACvD;AAOA,IAAAD,aAAY,UAAU,QAAQ,SAAU,SAAS;AAC7C,UAAI,QAAQ;AACZ,UAAI,eAAe,OAAO,QAAQ,eAAe,WAAW,QAAQ,aAC9D,QAAQ,eAAe,QAAQ,OAC3B;AACV,UAAI;AACJ,WAAK,mBAAmB,WAAY;AAAE,eAAQ,eAAe,QAAQ,OAAO,KAAK;AAAA,MAAI,GAAG,YAAY;AACpG,aAAO;AAAA,IACX;AACA,IAAAA,aAAY,UAAU,8BAA8B,SAAU,aAAa,cAAc;AACrF,WAAK,mBAAmB,aAAa,YAAY;AAAA,IACrD;AAIA,IAAAA,aAAY,UAAU,oBAAoB,SAAU,UAAU;AAC1D,aAAO;AAAA,IACX;AAGA,IAAAA,aAAY,UAAU,mBAAmB,SAAU,UAAU;AACzD,aAAO;AAAA,IACX;AACA,IAAAA,aAAY,UAAU,WAAW,SAAU,QAAQ;AAC/C;AAAA,IACJ;AACA,IAAAA,aAAY,UAAU,KAAK,WAAY;AACnC,aAAO,CAAC;AAAA,IACZ;AACA,IAAAA,aAAY,UAAU,SAAS,SAAU,SAAS;AAC9C,aAAO;AAAA,IACX;AAEA,IAAAA,aAAY,UAAU,YAAY,SAAU,SAAS,YAAY;AAC7D,UAAI,eAAe,QAAQ;AAAE,qBAAa,CAAC,CAAC,QAAQ;AAAA,MAAY;AAChE,aAAO,KAAK,KAAK,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,QAAQ,QAAQ,MAAM,cAAc,WAAuB,CAAC,CAAC;AAAA,IACpH;AACA,IAAAA,aAAY,UAAU,eAAe,SAAU,SAAS,YAAY;AAChE,UAAI,eAAe,QAAQ;AAAE,qBAAa,CAAC,CAAC,QAAQ;AAAA,MAAY;AAChE,aAAO,KAAK,KAAK,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,OAAO,KAAK,eAAe,QAAQ,UAAU,QAAQ,YAAY,GAAG,QAAQ,QAAQ,IAAI,WAAuB,CAAC,CAAC;AAAA,IACxK;AACA,IAAAA,aAAY,UAAU,aAAa,SAAUE,KAAI;AAC7C,UAAI,KAAKA,IAAG,IAAI,OAAOA,IAAG,MAAM,UAAU,OAAOA,KAAI,CAAC,MAAM,MAAM,CAAC;AACnE,aAAO,KAAK,MAAM,OAAO,OAAO,SAAS;AAAA,QACrC,QAAQ,MAAM;AAAA,QACd,QAAQ;AAAA,MACZ,CAAC,CAAC;AAAA,IACN;AACA,IAAAF,aAAY,UAAU,gBAAgB,SAAUE,KAAI;AAChD,UAAI,KAAKA,IAAG,IAAI,OAAOA,IAAG,MAAM,WAAWA,IAAG,UAAU,eAAeA,IAAG,cAAc,UAAU,OAAOA,KAAI,CAAC,MAAM,QAAQ,YAAY,cAAc,CAAC;AACvJ,aAAO,KAAK,MAAM,OAAO,OAAO,SAAS;AAAA,QACrC,OAAO,KAAK,eAAe,UAAU,YAAY;AAAA,QACjD,QAAQ;AAAA,QACR,QAAQ;AAAA,MACZ,CAAC,CAAC;AAAA,IACN;AACA,IAAAF,aAAY,UAAU,cAAc,SAAU,SAAS,QAAQ;AAC3D,aAAO,KAAK,MAAM;AAAA,QACd,QAAQ,SAAU,OAAO;AACrB,cAAI,QAAQ,MAAM,UAAU,OAAO;AACnC,cAAI,OAAO,OAAO,KAAK;AACvB,cAAI,SAAS,UAAU,SAAS;AAC5B,mBAAO;AACX,gBAAM,WAAW,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,KAAW,CAAC,CAAC;AAChE,iBAAO;AAAA,QACX;AAAA,MACJ,CAAC;AAAA,IACL;AACA,IAAAA,aAAY,UAAU,iBAAiB,SAAU,SAAS,QAAQ;AAC9D,aAAO,KAAK,MAAM;AAAA,QACd,QAAQ,SAAU,OAAO;AACrB,cAAI,QAAQ,MAAM,aAAa,OAAO;AACtC,cAAI,OAAO,OAAO,KAAK;AACvB,cAAI,SAAS,UAAU,SAAS;AAC5B,mBAAO;AACX,gBAAM,cAAc,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,KAAW,CAAC,CAAC;AACnE,iBAAO;AAAA,QACX;AAAA,MACJ,CAAC;AAAA,IACL;AACA,WAAOA;AAAA,EACX,EAAE;AAAA;;;ACjGK,IAAI;AACV,0BAAUG,QAAO;AAClB,GAAG,UAAU,QAAQ,CAAC,EAAE;;;ACDxB,IAAI;AAAA;AAAA,EAAmC,SAAU,QAAQ;AACrD,cAAUC,oBAAmB,MAAM;AACnC,aAASA,mBAAkB,SAAS,MAAM,OAAO,WAAW;AACxD,UAAIC;AAEJ,UAAI,QAAQ,OAAO,KAAK,MAAM,OAAO,KAAK;AAC1C,YAAM,UAAU;AAChB,YAAM,OAAO;AACb,YAAM,QAAQ;AACd,YAAM,YAAY;AAClB,UAAI,MAAM,QAAQ,MAAM,IAAI,GAAG;AAC3B,cAAM,UAAU,MAAM;AACtB,iBAAS,IAAI,MAAM,KAAK,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AAC7C,gBAAM,WAAWA,MAAK,CAAC,GAAGA,IAAG,MAAM,KAAK,CAAC,CAAC,IAAI,MAAM,SAASA;AAAA,QACjE;AAAA,MACJ,OACK;AACD,cAAM,UAAU,MAAM;AAAA,MAC1B;AAGA,YAAM,YAAYD,mBAAkB;AACpC,aAAO;AAAA,IACX;AACA,WAAOA;AAAA,EACX,EAAE,KAAK;AAAA;;;ACzBA,IAAI,SAAS,OAAO,UAAU;AAC9B,SAAS,UAAU,OAAO;AAC7B,SAAO,UAAU,QAAQ,UAAU;AACvC;AAEO,SAAS,wBAAwBE,KAAI,SAAS;AACjD,MAAI,aAAaA,IAAG,YAAY,KAAKA,IAAG,IAAI,MAAMA,IAAG;AACrD,MAAI,OAAO,eAAe,UAAU;AAChC,QAAI,SAAS;AACT,cAAQ,YACJ,CAAC,UAAU,EAAE,IAAI,EAAE,GAAO,IACpB,CAAC,UAAU,GAAG,IAAI,EAAE,IAAS,IACzB;AAAA,IAClB;AAEA,QAAI,UAAU,EAAE,KAAK,CAAC,UAAU,GAAG,GAAG;AAClC,WAAK;AAAA,IACT;AACA,QAAI,CAAC,UAAU,EAAE,GAAG;AAChB,aAAO,GAAG,OAAO,YAAY,GAAG,EAAE,OAAO,OAAO,OAAO,YAAY,OAAO,OAAO,WAC7E,KACE,KAAK,UAAU,EAAE,CAAC;AAAA,IAC5B;AAAA,EACJ;AACJ;AACA,IAAI,gBAAgB;AAAA,EAChB,kBAAkB;AAAA,EAClB,aAAa;AAAA,EACb,eAAe;AAAA;AAAA;AAAA,EAGf,iBAAiB;AACrB;AACO,SAAS,gBAAgB,QAAQ;AACpC,SAAO,QAAQ,eAAe,MAAM;AACxC;AACO,SAAS,sBAAsB,QAAQ;AAC1C,MAAI,QAAQ,OAAO;AACnB,SAAO,UAAU,SAAS,cAAc,kBAAkB;AAC9D;AACO,SAAS,2BAA2B,OAAO,mBAAmB;AACjE,SAAO,YAAY,iBAAiB,IAChC,MAAM,IAAI,kBAAkB,OAAO,YAAY,IAC7C,qBAAqB,kBAAkB;AACjD;AACO,IAAI,wBAAwB;AAC5B,SAAS,uBAAuB,gBAAgB;AACnD,MAAI,QAAQ,eAAe,MAAM,qBAAqB;AACtD,SAAO,QAAQ,MAAM,CAAC,IAAI;AAC9B;AACO,SAAS,0BAA0B,cAAcC,SAAQ,WAAW;AACvE,MAAI,gBAAgBA,OAAM,GAAG;AACzB,WAAO,QAAQA,OAAM,IACjBA,QAAO,MAAM,SAAU,MAAM;AACzB,aAAO,0BAA0B,cAAc,MAAM,SAAS;AAAA,IAClE,CAAC,IACC,aAAa,WAAW,MAAM,SAAU,OAAO;AAC7C,UAAI,QAAQ,KAAK,KAAK,cAAc,OAAO,SAAS,GAAG;AACnD,YAAI,MAAM,uBAAuB,KAAK;AACtC,eAAQ,OAAO,KAAKA,SAAQ,GAAG,MAC1B,CAAC,MAAM,gBACJ,0BAA0B,MAAM,cAAcA,QAAO,GAAG,GAAG,SAAS;AAAA,MAChF;AAMA,aAAO;AAAA,IACX,CAAC;AAAA,EACT;AACA,SAAO;AACX;AACO,SAAS,wBAAwB,OAAO;AAC3C,SAAO,gBAAgB,KAAK,KAAK,CAAC,YAAY,KAAK,KAAK,CAAC,QAAQ,KAAK;AAC1E;AACO,SAAS,4BAA4B;AACxC,SAAO,IAAI,WAAW;AAC1B;AACO,SAAS,uBAAuB,UAAU,WAAW;AAGxD,MAAI,cAAc,kBAAkB,uBAAuB,QAAQ,CAAC;AACpE,SAAO;AAAA,IACH;AAAA,IACA,gBAAgB,SAAU,MAAM;AAC5B,UAAI,MAAM,YAAY,IAAI;AAC1B,UAAI,CAAC,OAAO,WAAW;AACnB,cAAM,UAAU,OAAO,IAAI;AAAA,MAC/B;AACA,aAAO,OAAO;AAAA,IAClB;AAAA,EACJ;AACJ;;;ACvFA,IAAI,SAAS,uBAAO,OAAO,IAAI;AAC/B,IAAI,cAAc,WAAY;AAAE,SAAO;AAAQ;AAC/C,IAAI,aAAa,uBAAO,OAAO,IAAI;AACnC,IAAI;AAAA;AAAA,EAA6B,WAAY;AACzC,aAASC,aAAY,UAAU,OAAO;AAClC,UAAI,QAAQ;AACZ,WAAK,WAAW;AAChB,WAAK,QAAQ;AACb,WAAK,OAAO,uBAAO,OAAO,IAAI;AAI9B,WAAK,UAAU,uBAAO,OAAO,IAAI;AAEjC,WAAK,OAAO,uBAAO,OAAO,IAAI;AAG9B,WAAK,gBAAgB,SAAU,mBAAmB,gBAAgB;AAC9D,eAAO,gBAAgB,YAAY,iBAAiB,IAChD,MAAM,IAAI,kBAAkB,OAAO,cAAc,IAC/C,qBAAqB,kBAAkB,cAAc,CAAC;AAAA,MAChE;AAIA,WAAK,UAAU,SAAU,UAAU;AAC/B,eAAO,YAAY,QAAQ,IACvB,MAAM,IAAI,SAAS,KAAK,IACtB,OAAO,aAAa;AAAA,MAC9B;AAKA,WAAK,cAAc,SAAU,cAAc,gBAAgB;AACvD,YAAI,OAAO,iBAAiB,UAAU;AAClC,iBAAO,cAAc,YAAY;AAAA,QACrC;AACA,YAAI,YAAY,YAAY,GAAG;AAC3B,iBAAO;AAAA,QACX;AACA,YAAI,KAAK,MAAM,SAAS,SAAS,YAAY,EAAE,CAAC;AAChD,YAAI,IAAI;AACJ,cAAI,MAAM,cAAc,EAAE;AAC1B,cAAI,gBAAgB;AAChB,kBAAM,MAAM,IAAI,YAAY;AAAA,UAChC;AACA,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AAIA,IAAAA,aAAY,UAAU,WAAW,WAAY;AACzC,aAAO,SAAS,CAAC,GAAG,KAAK,IAAI;AAAA,IACjC;AACA,IAAAA,aAAY,UAAU,MAAM,SAAU,QAAQ;AAC1C,aAAO,KAAK,OAAO,QAAQ,IAAI,MAAM;AAAA,IACzC;AACA,IAAAA,aAAY,UAAU,MAAM,SAAU,QAAQ,WAAW;AACrD,WAAK,MAAM,OAAO,QAAQ,SAAS;AACnC,UAAI,OAAO,KAAK,KAAK,MAAM,MAAM,GAAG;AAChC,YAAI,cAAc,KAAK,KAAK,MAAM;AAClC,YAAI,eAAe,OAAO,KAAK,aAAa,SAAS,GAAG;AACpD,iBAAO,YAAY,SAAS;AAAA,QAChC;AAAA,MACJ;AACA,UAAI,cAAc,gBACd,OAAO,KAAK,KAAK,SAAS,mBAAmB,MAAM,GAAG;AACtD,eAAO,KAAK,SAAS,kBAAkB,MAAM;AAAA,MACjD;AACA,UAAI,gBAAgB,OAAO;AACvB,eAAO,KAAK,OAAO,IAAI,QAAQ,SAAS;AAAA,MAC5C;AAAA,IACJ;AACA,IAAAA,aAAY,UAAU,SAAS,SAAU,QAAQ,mBAAmB;AAMhE,UAAI;AACA,aAAK,MAAM,OAAO,QAAQ,UAAU;AACxC,UAAI,OAAO,KAAK,KAAK,MAAM,MAAM,GAAG;AAChC,eAAO,KAAK,KAAK,MAAM;AAAA,MAC3B;AACA,UAAI,gBAAgB,OAAO;AACvB,eAAO,KAAK,OAAO,OAAO,QAAQ,iBAAiB;AAAA,MACvD;AACA,UAAI,KAAK,SAAS,kBAAkB,MAAM,GAAG;AACzC,eAAO,uBAAO,OAAO,IAAI;AAAA,MAC7B;AAAA,IACJ;AACA,IAAAA,aAAY,UAAU,QAAQ,SAAU,OAAO,OAAO;AAClD,UAAI,QAAQ;AACZ,UAAI;AAEJ,UAAI,YAAY,KAAK;AACjB,gBAAQ,MAAM;AAClB,UAAI,YAAY,KAAK;AACjB,gBAAQ,MAAM;AAClB,UAAI,WAAW,OAAO,UAAU,WAAW,KAAK,OAAQ,SAAS,KAAM,IAAI;AAC3E,UAAI,WAAW,OAAO,UAAU,WAAW,KAAK,OAAQ,SAAS,KAAM,IAAI;AAG3E,UAAI,CAAC;AACD;AACJ,MAAAC,WAAU,OAAO,WAAW,UAAU,CAAC;AACvC,UAAI,SAAS,IAAI,WAAW,qBAAqB,EAAE,MAAM,UAAU,QAAQ;AAG3E,WAAK,KAAK,MAAM,IAAI;AACpB,UAAI,WAAW,UAAU;AACrB,eAAO,KAAK,KAAK,MAAM;AACvB,YAAI,KAAK,MAAM,SAAS;AACpB,cAAI,kBAAkB,uBAAO,OAAO,IAAI;AAIxC,cAAI,CAAC;AACD,4BAAgB,WAAW;AAG/B,iBAAO,KAAK,QAAQ,EAAE,QAAQ,SAAU,gBAAgB;AACpD,gBAAI,CAAC,YACD,SAAS,cAAc,MAAM,OAAO,cAAc,GAAG;AAGrD,8BAAgB,cAAc,IAAI;AAQlC,kBAAI,YAAY,uBAAuB,cAAc;AACrD,kBAAI,cAAc,kBACd,CAAC,MAAM,SAAS,WAAW,OAAO,YAAY,SAAS,GAAG;AAC1D,gCAAgB,SAAS,IAAI;AAAA,cACjC;AAIA,kBAAI,OAAO,cAAc,MAAM,UAAU,EAAE,iBAAiB,QAAQ;AAChE,uBAAO,OAAO,cAAc;AAAA,cAChC;AAAA,YACJ;AAAA,UACJ,CAAC;AACD,cAAI,gBAAgB,cAChB,EAAE,YAAY,SAAS;AAAA;AAAA;AAAA;AAAA,UAKvB,KAAK,SAAS,kBAAkB,MAAM,MAAM,OAAO,YAAY;AAC/D,mBAAO,gBAAgB;AAAA,UAC3B;AACA,iBAAO,KAAK,eAAe,EAAE,QAAQ,SAAU,WAAW;AACtD,mBAAO,MAAM,MAAM,MAAM,QAAQ,SAAS;AAAA,UAC9C,CAAC;AAAA,QACL;AAAA,MACJ;AAAA,IACJ;AACA,IAAAD,aAAY,UAAU,SAAS,SAAU,QAAQ,QAAQ;AACrD,UAAI,QAAQ;AACZ,UAAI,cAAc,KAAK,OAAO,MAAM;AACpC,UAAI,aAAa;AACb,YAAI,kBAAkB,uBAAO,OAAO,IAAI;AACxC,YAAI,gBAAgB;AACpB,YAAI,eAAe;AACnB,YAAI,kBAAkB;AAAA,UAClB;AAAA,UACA;AAAA,UACA;AAAA,UACA,aAAa,KAAK;AAAA,UAClB,SAAS,KAAK;AAAA,UACd,WAAW,SAAU,oBAAoBE,OAAM;AAC3C,mBAAO,MAAM,SAAS,UAAU,OAAO,uBAAuB,WAC1D;AAAA,cACI,WAAW;AAAA,cACX,MAAMA,SAAQ,cAAc,MAAM;AAAA,YACtC,IACE,oBAAoB,EAAE,OAAO,MAAM,CAAC;AAAA,UAC9C;AAAA,QACJ;AACA,eAAO,KAAK,WAAW,EAAE,QAAQ,SAAU,gBAAgB;AACvD,cAAI,YAAY,uBAAuB,cAAc;AACrD,cAAI,aAAa,YAAY,cAAc;AAC3C,cAAI,eAAe;AACf;AACJ,cAAI,SAAS,OAAO,WAAW,aAAa,SAAU,OAAO,cAAc,KAAK,OAAO,SAAS;AAChG,cAAI,QAAQ;AACR,gBAAI,WAAW,WAAW,cAAc,SAAU,OAAO,gBAAgB,UAAU,GAAG,SAAS,SAAS,CAAC,GAAG,eAAe,GAAG,EAAE,WAAsB,gBAAgC,SAAS,MAAM,WAAW,QAAQ,cAAc,EAAE,CAAC,CAAC;AAC1O,gBAAI,aAAa,YAAY;AACzB,oBAAM,MAAM,MAAM,QAAQ,cAAc;AAAA,YAC5C,OACK;AACD,kBAAI,aAAa;AACb,2BAAW;AACf,kBAAI,aAAa,YAAY;AACzB,gCAAgB,cAAc,IAAI;AAClC,gCAAgB;AAChB,6BAAa;AACb,oBAAI,WAAW,YAAY,OAAO;AAC9B,sBAAI,iBAAiB,SAAU,KAAK;AAChC,wBAAI,MAAM,OAAO,IAAI,KAAK,MAAM,QAAW;AACvC,iCAAW,YAAY,SAASD,WAAU,KAAK,GAAG,GAAG;AACrD,6BAAO;AAAA,oBACX;AAAA,kBACJ;AACA,sBAAI,YAAY,QAAQ,GAAG;AACvB,mCAAe,QAAQ;AAAA,kBAC3B,WACS,MAAM,QAAQ,QAAQ,GAAG;AAE9B,wBAAI,gBAAgB;AACpB,wBAAI,mBAAmB;AACvB,6BAAS,KAAK,GAAG,aAAa,UAAU,KAAK,WAAW,QAAQ,MAAM;AAClE,0BAAI,QAAQ,WAAW,EAAE;AACzB,0BAAI,YAAY,KAAK,GAAG;AACpB,wCAAgB;AAChB,4BAAI,eAAe,KAAK;AACpB;AAAA,sBACR,OACK;AAGD,4BAAI,OAAO,UAAU,YAAY,CAAC,CAAC,OAAO;AACtC,8BAAI,KAAK,MAAM,SAAS,SAAS,KAAK,EAAE,CAAC;AAEzC,8BAAI,IAAI;AACJ,+CAAmB;AAAA,0BACvB;AAAA,wBACJ;AAAA,sBACJ;AACA,0BAAI,iBAAiB,qBAAqB,QAAW;AACjD,mCAAW,YAAY,SAASA,WAAU,KAAK,GAAG,gBAAgB;AAClE;AAAA,sBACJ;AAAA,oBACJ;AAAA,kBACJ;AAAA,gBACJ;AAAA,cACJ;AAAA,YACJ;AAAA,UACJ;AACA,cAAI,eAAe,QAAQ;AACvB,2BAAe;AAAA,UACnB;AAAA,QACJ,CAAC;AACD,YAAI,eAAe;AACf,eAAK,MAAM,QAAQ,eAAe;AAClC,cAAI,cAAc;AACd,gBAAI,gBAAgB,OAAO;AACvB,mBAAK,KAAK,MAAM,IAAI;AAAA,YACxB,OACK;AACD,qBAAO,KAAK,KAAK,MAAM;AAAA,YAC3B;AACA,iBAAK,MAAM,MAAM,QAAQ,UAAU;AAAA,UACvC;AACA,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAOA,IAAAD,aAAY,UAAU,SAAS,SAAU,QAAQ,WAAW,MAAM;AAC9D,UAAIG;AACJ,UAAI,cAAc,KAAK,OAAO,MAAM;AACpC,UAAI,aAAa;AACb,YAAI,WAAW,KAAK,cAAc,aAAa,YAAY;AAC3D,YAAI,iBAAiB,aAAa,OAC9B,KAAK,SAAS,kBAAkB,EAAE,UAAoB,WAAsB,KAAW,CAAC,IACtF;AACN,eAAO,KAAK,OAAO,QAAQ,kBAAkBA,MAAK,CAAC,GAC/CA,IAAG,cAAc,IAAI,aACrBA,OAAM,WAAW;AAAA,MACzB;AACA,aAAO;AAAA,IACX;AACA,IAAAH,aAAY,UAAU,QAAQ,SAAU,SAAS,OAAO;AACpD,UAAI,UAAU;AACd,UAAI,QAAQ,IAAI;AACZ,YAAI,OAAO,KAAK,KAAK,MAAM,QAAQ,EAAE,GAAG;AACpC,oBAAU,KAAK,OAAO,QAAQ,IAAI,QAAQ,WAAW,QAAQ,IAAI;AAAA,QACrE;AACA,YAAI,gBAAgB,SAAS,SAAS,OAAO;AACzC,oBAAU,KAAK,OAAO,MAAM,SAAS,KAAK,KAAK;AAAA,QACnD;AAKA,YAAI,QAAQ,aAAa,SAAS;AAC9B,eAAK,MAAM,MAAM,QAAQ,IAAI,QAAQ,aAAa,UAAU;AAAA,QAChE;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACA,IAAAA,aAAY,UAAU,QAAQ,WAAY;AACtC,WAAK,QAAQ,IAAI;AAAA,IACrB;AACA,IAAAA,aAAY,UAAU,UAAU,WAAY;AACxC,UAAI,QAAQ;AACZ,UAAI,MAAM,KAAK,SAAS;AACxB,UAAI,eAAe,CAAC;AACpB,WAAK,aAAa,EAAE,QAAQ,SAAU,IAAI;AACtC,YAAI,CAAC,OAAO,KAAK,MAAM,SAAS,mBAAmB,EAAE,GAAG;AACpD,uBAAa,KAAK,EAAE;AAAA,QACxB;AAAA,MACJ,CAAC;AACD,UAAI,aAAa,QAAQ;AACrB,YAAI,SAAS,EAAE,cAAc,aAAa,KAAK,EAAE;AAAA,MACrD;AACA,aAAO;AAAA,IACX;AACA,IAAAA,aAAY,UAAU,UAAU,SAAU,SAAS;AAC/C,UAAI,QAAQ;AACZ,aAAO,KAAK,KAAK,IAAI,EAAE,QAAQ,SAAU,QAAQ;AAC7C,YAAI,EAAE,WAAW,OAAO,KAAK,SAAS,MAAM,IAAI;AAC5C,gBAAM,OAAO,MAAM;AAAA,QACvB;AAAA,MACJ,CAAC;AACD,UAAI,SAAS;AACT,YAAI,SAAS,QAAQ,QAAQ,SAAS,OAAO,SAAS,CAAC,QAAQ,CAAC;AAChE,eAAO,KAAK,MAAM,EAAE,QAAQ,SAAU,QAAQ;AAC1C,gBAAM,MAAM,QAAQ,OAAO,MAAM,CAAC;AAAA,QACtC,CAAC;AACD,YAAI,QAAQ;AACR,iBAAO,aAAa,QAAQ,KAAK,QAAQ,IAAI;AAAA,QACjD;AAAA,MACJ;AAAA,IACJ;AACA,IAAAA,aAAY,UAAU,SAAS,SAAU,QAAQ;AAC7C,aAAQ,KAAK,QAAQ,MAAM,KAAK,KAAK,QAAQ,MAAM,KAAK,KAAK;AAAA,IACjE;AACA,IAAAA,aAAY,UAAU,UAAU,SAAU,QAAQ;AAC9C,UAAI,KAAK,QAAQ,MAAM,IAAI,GAAG;AAC1B,YAAI,QAAQ,EAAE,KAAK,QAAQ,MAAM;AACjC,YAAI,CAAC;AACD,iBAAO,KAAK,QAAQ,MAAM;AAC9B,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX;AAGA,IAAAA,aAAY,UAAU,eAAe,SAAU,KAAK;AAChD,UAAI,QAAQ,QAAQ;AAAE,cAAM,oBAAI,IAAI;AAAA,MAAG;AACvC,aAAO,KAAK,KAAK,OAAO,EAAE,QAAQ,IAAI,KAAK,GAAG;AAC9C,UAAI,gBAAgB,OAAO;AACvB,aAAK,OAAO,aAAa,GAAG;AAAA,MAChC,OACK;AAID,eAAO,KAAK,KAAK,SAAS,iBAAiB,EAAE,QAAQ,IAAI,KAAK,GAAG;AAAA,MACrE;AACA,aAAO;AAAA,IACX;AAKA,IAAAA,aAAY,UAAU,KAAK,WAAY;AACnC,UAAI,QAAQ;AACZ,UAAI,MAAM,KAAK,aAAa;AAC5B,UAAI,WAAW,KAAK,SAAS;AAC7B,UAAI,QAAQ,SAAU,IAAI;AACtB,YAAI,OAAO,KAAK,UAAU,EAAE,GAAG;AAI3B,iBAAO,KAAK,MAAM,gBAAgB,EAAE,CAAC,EAAE,QAAQ,IAAI,KAAK,GAAG;AAG3D,iBAAO,SAAS,EAAE;AAAA,QACtB;AAAA,MACJ,CAAC;AACD,UAAI,cAAc,OAAO,KAAK,QAAQ;AACtC,UAAI,YAAY,QAAQ;AACpB,YAAI,SAAS;AACb,eAAO,kBAAkB;AACrB,mBAAS,OAAO;AACpB,oBAAY,QAAQ,SAAU,IAAI;AAAE,iBAAO,OAAO,OAAO,EAAE;AAAA,QAAG,CAAC;AAAA,MACnE;AACA,aAAO;AAAA,IACX;AACA,IAAAA,aAAY,UAAU,kBAAkB,SAAU,QAAQ;AACtD,UAAI,CAAC,OAAO,KAAK,KAAK,MAAM,MAAM,GAAG;AACjC,YAAI,UAAW,KAAK,KAAK,MAAM,IAAI,uBAAO,OAAO,IAAI;AACrD,YAAII,QAAO,KAAK,KAAK,MAAM;AAC3B,YAAI,CAACA;AACD,iBAAO;AACX,YAAI,YAAY,oBAAI,IAAI,CAACA,KAAI,CAAC;AAG9B,kBAAU,QAAQ,SAAU,KAAK;AAC7B,cAAI,YAAY,GAAG,GAAG;AAClB,oBAAQ,IAAI,KAAK,IAAI;AAAA,UAQzB;AACA,cAAI,gBAAgB,GAAG,GAAG;AACtB,mBAAO,KAAK,GAAG,EAAE,QAAQ,SAAU,KAAK;AACpC,kBAAI,QAAQ,IAAI,GAAG;AAGnB,kBAAI,gBAAgB,KAAK,GAAG;AACxB,0BAAU,IAAI,KAAK;AAAA,cACvB;AAAA,YACJ,CAAC;AAAA,UACL;AAAA,QACJ,CAAC;AAAA,MACL;AACA,aAAO,KAAK,KAAK,MAAM;AAAA,IAC3B;AACA,IAAAJ,aAAY,UAAU,eAAe,WAAY;AAC7C,aAAO,KAAK,MAAM,SAAS,YAAY,SAAS;AAAA,IACpD;AACA,WAAOA;AAAA,EACX,EAAE;AAAA;AAeF,IAAI;AAAA;AAAA,EAA4B,WAAY;AACxC,aAASK,YAAW,SAAS,QAAQ;AACjC,UAAI,WAAW,QAAQ;AAAE,iBAAS;AAAA,MAAM;AACxC,WAAK,UAAU;AACf,WAAK,SAAS;AACd,WAAK,IAAI;AACT,WAAK,aAAa;AAAA,IACtB;AACA,IAAAA,YAAW,UAAU,eAAe,WAAY;AAC5C,WAAK,IAAI,KAAK,UAAU,IAAI,IAAI;AAChC,WAAK,WAAW,IAAI,KAAK,aAAa;AAAA,IAC1C;AACA,IAAAA,YAAW,UAAU,SAAS,SAAU,QAAQ,gBAAgB;AAC5D,UAAI,KAAK,GAAG;AACR,aAAK,EAAE,WAAW,QAAQ,cAAc,CAAC;AACzC,YAAI,YAAY,uBAAuB,cAAc;AACrD,YAAI,cAAc,gBAAgB;AAM9B,eAAK,EAAE,WAAW,QAAQ,SAAS,CAAC;AAAA,QACxC;AACA,YAAI,KAAK,QAAQ;AACb,eAAK,OAAO,OAAO,QAAQ,cAAc;AAAA,QAC7C;AAAA,MACJ;AAAA,IACJ;AACA,IAAAA,YAAW,UAAU,QAAQ,SAAU,QAAQ,gBAAgB;AAC3D,UAAI,KAAK,GAAG;AACR,aAAK,EAAE;AAAA,UAAM,WAAW,QAAQ,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAQ9C,mBAAmB,aAAa,WAAW;AAAA,QAAU;AAAA,MACzD;AAAA,IACJ;AACA,WAAOA;AAAA,EACX,EAAE;AAAA;AACF,SAAS,WAAW,QAAQ,gBAAgB;AAIxC,SAAO,iBAAiB,MAAM;AAClC;AACO,SAAS,+BAA+B,OAAO,UAAU;AAC5D,MAAI,sBAAsB,KAAK,GAAG;AAS9B,UAAM,MAAM,OAAO,UAAU,UAAU;AAAA,EAC3C;AACJ;AAAA,CACC,SAAUC,cAAa;AAEpB,MAAI;AAAA;AAAA,IAAsB,SAAU,QAAQ;AACxC,gBAAUC,OAAM,MAAM;AACtB,eAASA,MAAKC,KAAI;AACd,YAAI,WAAWA,IAAG,UAAU,KAAKA,IAAG,eAAe,gBAAgB,OAAO,SAAS,OAAO,IAAI,OAAOA,IAAG;AACxG,YAAI,QAAQ,OAAO,KAAK,MAAM,UAAU,IAAI,WAAW,aAAa,CAAC,KAAK;AAC1E,cAAM,QAAQ,IAAI,MAAM,KAAK;AAC7B,cAAM,cAAc,IAAI,KAAK,aAAa;AAC1C,YAAI;AACA,gBAAM,QAAQ,IAAI;AACtB,eAAO;AAAA,MACX;AACA,MAAAD,MAAK,UAAU,WAAW,SAAU,SAAS,QAAQ;AAIjD,eAAO,KAAK,MAAM,SAAS,SAAS,MAAM;AAAA,MAC9C;AACA,MAAAA,MAAK,UAAU,cAAc,WAAY;AAErC,eAAO;AAAA,MACX;AACA,MAAAA,MAAK,UAAU,aAAa,WAAY;AACpC,eAAO,KAAK,YAAY,YAAY,SAAS;AAAA,MACjD;AACA,aAAOA;AAAA,IACX,EAAED,YAAW;AAAA;AACb,EAAAA,aAAY,OAAO;AACvB,GAAG,gBAAgB,cAAc,CAAC,EAAE;AAGpC,IAAI;AAAA;AAAA,EAAuB,SAAU,QAAQ;AACzC,cAAUG,QAAO,MAAM;AACvB,aAASA,OAAM,IAAI,QAAQ,QAAQ,OAAO;AACtC,UAAI,QAAQ,OAAO,KAAK,MAAM,OAAO,UAAU,KAAK,KAAK;AACzD,YAAM,KAAK;AACX,YAAM,SAAS;AACf,YAAM,SAAS;AACf,YAAM,QAAQ;AACd,aAAO,KAAK;AACZ,aAAO;AAAA,IACX;AACA,IAAAA,OAAM,UAAU,WAAW,SAAU,SAAS,QAAQ;AAClD,aAAO,IAAIA,OAAM,SAAS,MAAM,QAAQ,KAAK,KAAK;AAAA,IACtD;AACA,IAAAA,OAAM,UAAU,cAAc,SAAU,SAAS;AAC7C,UAAI,QAAQ;AAEZ,UAAI,SAAS,KAAK,OAAO,YAAY,OAAO;AAC5C,UAAI,YAAY,KAAK,IAAI;AACrB,YAAI,KAAK,MAAM,SAAS;AAKpB,iBAAO,KAAK,KAAK,IAAI,EAAE,QAAQ,SAAU,QAAQ;AAC7C,gBAAI,iBAAiB,MAAM,KAAK,MAAM;AACtC,gBAAI,oBAAoB,OAAO,QAAQ,EAAE,MAAM;AAC/C,gBAAI,CAAC,mBAAmB;AAMpB,oBAAM,OAAO,MAAM;AAAA,YACvB,WACS,CAAC,gBAAgB;AAKtB,oBAAM,MAAM,MAAM,QAAQ,UAAU;AACpC,qBAAO,KAAK,iBAAiB,EAAE,QAAQ,SAAU,gBAAgB;AAC7D,sBAAM,MAAM,MAAM,QAAQ,cAAc;AAAA,cAC5C,CAAC;AAAA,YACL,WACS,mBAAmB,mBAAmB;AAI3C,qBAAO,KAAK,cAAc,EAAE,QAAQ,SAAU,gBAAgB;AAC1D,oBAAI,CAAC,MAAM,eAAe,cAAc,GAAG,kBAAkB,cAAc,CAAC,GAAG;AAC3E,wBAAM,MAAM,MAAM,QAAQ,cAAc;AAAA,gBAC5C;AAAA,cACJ,CAAC;AAAA,YACL;AAAA,UACJ,CAAC;AAAA,QACL;AACA,eAAO;AAAA,MACX;AAEA,UAAI,WAAW,KAAK;AAChB,eAAO;AAEX,aAAO,OAAO,SAAS,KAAK,IAAI,KAAK,MAAM;AAAA,IAC/C;AACA,IAAAA,OAAM,UAAU,WAAW,WAAY;AACnC,aAAO,SAAS,SAAS,CAAC,GAAG,KAAK,OAAO,SAAS,CAAC,GAAG,KAAK,IAAI;AAAA,IACnE;AACA,IAAAA,OAAM,UAAU,kBAAkB,SAAU,QAAQ;AAChD,UAAI,aAAa,KAAK,OAAO,gBAAgB,MAAM;AACnD,aAAO,OAAO,KAAK,KAAK,MAAM,MAAM,IAAI,SAAS,SAAS,CAAC,GAAG,UAAU,GAAG,OAAO,UAAU,gBAAgB,KAAK,MAAM,MAAM,CAAC,IAAI;AAAA,IACtI;AACA,IAAAA,OAAM,UAAU,aAAa,WAAY;AACrC,UAAI,IAAI,KAAK;AACb,aAAO,EAAE;AACL,YAAI,EAAE;AACV,aAAO,EAAE,WAAW;AAAA,QAAM;AAAA;AAAA,QAE1B;AAAA,MAAS;AAAA,IACb;AACA,WAAOA;AAAA,EACX,EAAE,WAAW;AAAA;AAKb,IAAI;AAAA;AAAA,EAAuB,SAAU,QAAQ;AACzC,cAAUC,QAAO,MAAM;AACvB,aAASA,OAAMC,OAAM;AACjB,aAAO,OAAO,KAAK,MAAM,qBAAqBA,OAAM,WAAY;AAAA,MAAE,GAAG,IAAI,WAAWA,MAAK,MAAM,SAASA,MAAK,KAAK,CAAC,KAAK;AAAA,IAC5H;AACA,IAAAD,OAAM,UAAU,cAAc,WAAY;AAEtC,aAAO;AAAA,IACX;AACA,IAAAA,OAAM,UAAU,QAAQ,SAAU,OAAO,OAAO;AAM5C,aAAO,KAAK,OAAO,MAAM,OAAO,KAAK;AAAA,IACzC;AACA,WAAOA;AAAA,EACX,EAAE,KAAK;AAAA;AACP,SAAS,sBAAsB,gBAAgB,gBAAgB,UAAU;AACrE,MAAI,gBAAgB,eAAe,QAAQ;AAC3C,MAAI,gBAAgB,eAAe,QAAQ;AAM3C,SAAO,MAAM,eAAe,aAAa,IAAI,gBAAgB;AACjE;AACO,SAAS,sBAAsB,OAAO;AAEzC,SAAO,CAAC,EAAE,iBAAiB,eAAe,MAAM,MAAM;AAC1D;;;ACzpBA,SAAS,YAAY,OAAO;AACxB,MAAI,gBAAgB,KAAK,GAAG;AACxB,WAAO,QAAQ,KAAK,IAChB,MAAM,MAAM,CAAC,IACX,SAAS,EAAE,WAAW,OAAO,eAAe,KAAK,EAAE,GAAG,KAAK;AAAA,EACrE;AACA,SAAO;AACX;AAwDA,IAAI;AAAA;AAAA,EAA6B,WAAY;AACzC,aAASE,eAAc;AAGnB,WAAK,QAAQ,KAAK,gBAAgB,UAAU,KAAK;AAEjD,WAAK,OAAO,IAAI,KAAK,aAAa;AAGlC,WAAK,SAAS,oBAAI,QAAQ;AAG1B,WAAK,aAAa,oBAAI,IAAI;AAE1B,WAAK,QAAQ,KAAK,MAAM,CAAC,CAAC;AAAA,IAC9B;AACA,IAAAA,aAAY,UAAU,UAAU,SAAU,OAAO;AAC7C,aAAO,gBAAgB,KAAK,KAAK,KAAK,MAAM,IAAI,KAAK;AAAA,IACzD;AACA,IAAAA,aAAY,UAAU,OAAO,SAAU,OAAO;AAC1C,UAAI,gBAAgB,KAAK,GAAG;AACxB,YAAI,OAAO,YAAY,KAAK;AAC5B,aAAK,OAAO,IAAI,MAAM,KAAK;AAC3B,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX;AACA,IAAAA,aAAY,UAAU,QAAQ,SAAU,OAAO;AAC3C,UAAI,QAAQ;AACZ,UAAI,gBAAgB,KAAK,GAAG;AACxB,YAAI,WAAW,KAAK,OAAO,IAAI,KAAK;AACpC,YAAI;AACA,iBAAO;AACX,YAAI,QAAQ,OAAO,eAAe,KAAK;AACvC,gBAAQ,OAAO;AAAA,UACX,KAAK,MAAM,WAAW;AAClB,gBAAI,KAAK,MAAM,IAAI,KAAK;AACpB,qBAAO;AACX,gBAAI,QAAQ,MAAM,IAAI,KAAK,OAAO,IAAI;AAItC,gBAAI,OAAO,KAAK,KAAK,YAAY,KAAK;AACtC,gBAAI,CAAC,KAAK,OAAO;AACb,mBAAK,MAAM,IAAK,KAAK,QAAQ,KAAM;AAInC,kBAAI,WAAW,YAAY,OAAO;AAC9B,uBAAO,OAAO,KAAK;AAAA,cACvB;AAAA,YACJ;AACA,mBAAO,KAAK;AAAA,UAChB;AAAA,UACA,KAAK;AAAA,UACL,KAAK,OAAO,WAAW;AACnB,gBAAI,KAAK,MAAM,IAAI,KAAK;AACpB,qBAAO;AACX,gBAAI,UAAU,OAAO,eAAe,KAAK;AACzC,gBAAI,UAAU,CAAC,OAAO;AACtB,gBAAI,OAAO,KAAK,WAAW,KAAK;AAChC,oBAAQ,KAAK,KAAK,IAAI;AACtB,gBAAI,oBAAoB,QAAQ;AAChC,iBAAK,OAAO,QAAQ,SAAU,KAAK;AAC/B,sBAAQ,KAAK,MAAM,MAAM,MAAM,GAAG,CAAC,CAAC;AAAA,YACxC,CAAC;AASD,gBAAI,OAAO,KAAK,KAAK,YAAY,OAAO;AACxC,gBAAI,CAAC,KAAK,QAAQ;AACd,kBAAI,QAAS,KAAK,SAAS,OAAO,OAAO,OAAO;AAChD,mBAAK,MAAM,IAAI,KAAK;AACpB,mBAAK,OAAO,QAAQ,SAAU,KAAK,GAAG;AAClC,sBAAM,GAAG,IAAI,QAAQ,oBAAoB,CAAC;AAAA,cAC9C,CAAC;AAID,kBAAI,WAAW,YAAY,OAAO;AAC9B,uBAAO,OAAO,KAAK;AAAA,cACvB;AAAA,YACJ;AACA,mBAAO,KAAK;AAAA,UAChB;AAAA,QACJ;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAKA,IAAAA,aAAY,UAAU,aAAa,SAAU,KAAK;AAC9C,UAAI,OAAO,OAAO,KAAK,GAAG;AAC1B,UAAI,OAAO,KAAK,KAAK,YAAY,IAAI;AACrC,UAAI,CAAC,KAAK,MAAM;AACZ,aAAK,KAAK;AACV,YAAI,OAAO,KAAK,UAAU,IAAI;AAC9B,YAAI,EAAE,KAAK,OAAO,KAAK,WAAW,IAAI,IAAI,IAAI;AAC1C,eAAK,WAAW,IAAI,MAAO,KAAK,OAAO,EAAE,QAAQ,MAAM,KAAW,CAAE;AAAA,QACxE;AAAA,MACJ;AACA,aAAO,KAAK;AAAA,IAChB;AACA,WAAOA;AAAA,EACX,EAAE;AAAA;AAKK,IAAI,qBAAqB,OAAO,OAAO,SAAU,OAAO;AAC3D,MAAI,gBAAgB,KAAK,GAAG;AACxB,QAAI,mBAAmB,QAAQ;AAC3B,8BAAwB;AAAA,IAC5B;AACA,QAAI,YAAY,eAAe,MAAM,KAAK;AAC1C,QAAI,OAAO,eAAe,IAAI,SAAS;AACvC,QAAI,SAAS,QAAQ;AACjB,qBAAe,IAAI,WAAY,OAAO,KAAK,UAAU,SAAS,CAAE;AAAA,IACpE;AACA,WAAO;AAAA,EACX;AACA,SAAO,KAAK,UAAU,KAAK;AAC/B,GAAG;AAAA,EACC,OAAO;AACX,CAAC;AAED,IAAI;AACJ,IAAI;AACJ,SAAS,0BAA0B;AAC/B,mBAAiB,IAAI,YAAY;AACjC,mBAAiB,KAAK,gBAAgB,UAAU,KAAK;AACzD;;;ACpMA,SAAS,wBAAwB,SAAS;AACtC,SAAO;AAAA,IACH,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,QAAQ;AAAA;AAAA;AAAA,IAGR,QAAQ,QAAQ;AAAA,EACpB;AACJ;AACA,IAAI;AAAA;AAAA,EAA6B,WAAY;AACzC,aAASC,aAAY,QAAQ;AACzB,UAAI,QAAQ;AACZ,WAAK,eAAe,KAAK,gBAAgB,UAAU,KAAK;AACxD,WAAK,SAAS,QAAQ,QAAQ;AAAA,QAC1B,aAAa,OAAO,gBAAgB;AAAA,QACpC,iBAAiB,sBAAsB,MAAM;AAAA,MACjD,CAAC;AACD,WAAK,QAAQ,OAAO,SAAS,IAAI,YAAY;AAC7C,WAAK,sBAAsBC,MAAK,SAAU,SAAS;AAC/C,YAAIC;AACJ,YAAI,kBAAkB,QAAQ,QAAQ;AACtC,YAAI,WAAW,wBAAwB,OAAO;AAG9C,iBAAS,CAAC,IAAI,CAAC;AACf,YAAI,SAASA,MAAK,MAAM,qBAAqB,KAAK,MAAMA,KAAI,QAAQ;AACpE,YAAI,OAAO;AACP,cAAI,iBAAiB;AACjB,mBAAO,SAAS,SAAS,CAAC,GAAG,KAAK,GAAG;AAAA;AAAA;AAAA,cAGjC,QAAQ,MAAM,MAAM,MAAM,MAAM,MAAM;AAAA,YAAE,CAAC;AAAA,UACjD;AAGA,iBAAO;AAAA,QACX;AACA,uCAA+B,QAAQ,QAAQ,OAAO,QAAQ,aAAa,KAAK;AAGhF,eAAO,MAAM,qBAAqB,OAAO;AAAA,MAC7C,GAAG;AAAA,QACC,KAAK,KAAK,OAAO;AAAA,QACjB,SAAS;AAAA;AAAA;AAAA,QAGT,cAAc,SAAU,cAAc,QAAQ,SAAS,iBAAiB;AACpE,cAAI,sBAAsB,QAAQ,KAAK,GAAG;AACtC,mBAAO,QAAQ,MAAM,aAAa,cAAc,YAAY,MAAM,IAAI,OAAO,QAAQ,QAAQ,QAAQ,WAAW,eAAe;AAAA,UACnI;AAAA,QACJ;AAAA,MACJ,CAAC;AACD,WAAK,0BAA0BD,MAAK,SAAU,SAAS;AACnD,uCAA+B,QAAQ,QAAQ,OAAO,QAAQ,aAAa,KAAK;AAChF,eAAO,MAAM,yBAAyB,OAAO;AAAA,MACjD,GAAG;AAAA,QACC,KAAK,KAAK,OAAO;AAAA,QACjB,cAAc,SAAUC,KAAI;AACxB,cAAI,QAAQA,IAAG,OAAO,QAAQA,IAAG,OAAO,UAAUA,IAAG;AACrD,cAAI,sBAAsB,QAAQ,KAAK,GAAG;AACtC,mBAAO,QAAQ,MAAM,aAAa,OAAO,OAAO,QAAQ,SAAS;AAAA,UACrE;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACL;AACA,IAAAF,aAAY,UAAU,aAAa,WAAY;AAC3C,WAAK,QAAQ,IAAI,YAAY;AAAA,IACjC;AAKA,IAAAA,aAAY,UAAU,wBAAwB,SAAUE,KAAI;AACxD,UAAI,QAAQA,IAAG,OAAO,QAAQA,IAAG,OAAO,KAAKA,IAAG,QAAQ,SAAS,OAAO,SAAS,eAAe,IAAI,YAAYA,IAAG,WAAW,KAAKA,IAAG,mBAAmB,oBAAoB,OAAO,SAAS,OAAO,IAAI,KAAKA,IAAG,iBAAiB,kBAAkB,OAAO,SAAS,KAAK,OAAO,kBAAkB;AACjS,UAAI,WAAW,KAAK,OAAO,MAAM;AACjC,kBAAY,SAAS,SAAS,CAAC,GAAG,iBAAiB,mBAAmB,KAAK,CAAC,CAAC,GAAG,SAAS;AACzF,UAAI,UAAU,cAAc,MAAM;AAClC,UAAI,aAAa,KAAK,oBAAoB;AAAA,QACtC,cAAc,kBAAkB,KAAK,EAAE;AAAA,QACvC,mBAAmB;AAAA,QACnB,cAAc;AAAA,QACd,SAAS,SAAS,EAAE,OAAc,OAAc,UAAoB,WAAsB,WAAW,mBAAmB,SAAS,GAAG,gBAAiC,GAAG,uBAAuB,OAAO,KAAK,OAAO,SAAS,CAAC;AAAA,MAChO,CAAC;AACD,UAAI;AACJ,UAAI,WAAW,SAAS;AAKpB,kBAAU;AAAA,UACN,IAAI,kBAAkB,aAAa,WAAW,OAAO,GAAG,WAAW,SAAS,OAAO,SAAS;AAAA,QAChG;AACA,YAAI,CAAC,mBAAmB;AACpB,gBAAM,QAAQ,CAAC;AAAA,QACnB;AAAA,MACJ;AACA,aAAO;AAAA,QACH,QAAQ,WAAW;AAAA,QACnB,UAAU,CAAC;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AACA,IAAAF,aAAY,UAAU,UAAU,SAAUG,SAAQ,QAAQ,cAAc,SAAS;AAC7E,UAAI,sBAAsB,QAAQ,KAAK,KACnC,KAAK,aAAa,IAAIA,OAAM,MAAM,cAAc;AAChD,YAAI,SAAS,KAAK,oBAAoB;AAAA,UAAK;AAAA,UAAc;AAAA,UAAQ;AAAA;AAAA;AAAA;AAAA,UAIjE,KAAK,MAAM,QAAQA,OAAM;AAAA,QAAC;AAC1B,YAAI,UAAUA,YAAW,OAAO,QAAQ;AACpC,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAEA,IAAAH,aAAY,UAAU,uBAAuB,SAAUE,KAAI;AACvD,UAAI,QAAQ;AACZ,UAAI,eAAeA,IAAG,cAAc,oBAAoBA,IAAG,mBAAmB,eAAeA,IAAG,cAAc,UAAUA,IAAG;AAC3H,UAAI,YAAY,iBAAiB,KAC7B,CAAC,QAAQ,SAAS,kBAAkB,kBAAkB,KAAK,KAC3D,CAAC,QAAQ,MAAM,IAAI,kBAAkB,KAAK,GAAG;AAC7C,eAAO;AAAA,UACH,QAAQ,KAAK,MAAM;AAAA,UACnB,SAAS,iCAAiC,OAAO,kBAAkB,OAAO,SAAS;AAAA,QACvF;AAAA,MACJ;AACA,UAAI,YAAY,QAAQ,WAAW,WAAW,QAAQ,UAAU,QAAQ,QAAQ;AAChF,UAAI,WAAW,MAAM,cAAc,mBAAmB,YAAY;AAClE,UAAI,iBAAiB,CAAC;AACtB,UAAI;AACJ,UAAI,gBAAgB,IAAI,WAAW;AACnC,UAAI,KAAK,OAAO,eACZ,OAAO,aAAa,YACpB,CAAC,SAAS,kBAAkB,QAAQ,GAAG;AAIvC,uBAAe,KAAK,EAAE,YAAY,SAAS,CAAC;AAAA,MAChD;AACA,eAAS,cAAcC,SAAQ,YAAY;AACvC,YAAID;AACJ,YAAIC,QAAO,SAAS;AAChB,oBAAU,cAAc,MAAM,UAAUD,MAAK,CAAC,GAC1CA,IAAG,UAAU,IAAIC,QAAO,SACxBD,IAAG;AAAA,QACX;AACA,eAAOC,QAAO;AAAA,MAClB;AACA,UAAI,UAAU,IAAI,IAAI,aAAa,UAAU;AAC7C,cAAQ,QAAQ,SAAU,WAAW;AACjC,YAAID,KAAI;AAGR,YAAI,CAAC,cAAc,WAAW,SAAS;AACnC;AACJ,YAAI,QAAQ,SAAS,GAAG;AACpB,cAAI,aAAa,SAAS,UAAU;AAAA,YAChC,WAAW,UAAU,KAAK;AAAA,YAC1B,OAAO;AAAA,YACP,WAAW,QAAQ;AAAA,YACnB,MAAM;AAAA,UACV,GAAG,OAAO;AACV,cAAI,aAAa,uBAAuB,SAAS;AACjD,cAAI,eAAe,QAAQ;AACvB,gBAAI,CAAC,sBAAsB,MAAM,SAAS,GAAG;AACzC,wBAAU,cAAc,MAAM,UAAUA,MAAK,CAAC,GAC1CA,IAAG,UAAU,IAAI,qBAAqB,OAAO,UAAU,KAAK,OAAO,OAAO,EAAE,OAAO,YAAY,iBAAiB,IAC5G,kBAAkB,QAAQ,YACxB,YAAY,KAAK,UAAU,mBAAmB,MAAM,CAAC,CAAC,GAC5DA,IAAG;AAAA,YACX;AAAA,UACJ,WACS,QAAQ,UAAU,GAAG;AAC1B,yBAAa,cAAc,MAAM,wBAAwB;AAAA,cACrD,OAAO;AAAA,cACP,OAAO;AAAA,cACP;AAAA,cACA;AAAA,YACJ,CAAC,GAAG,UAAU;AAAA,UAClB,WACS,CAAC,UAAU,cAAc;AAK9B,gBAAI,QAAQ,iBAAiB;AACzB,2BAAa,MAAM,MAAM,KAAK,UAAU;AAAA,YAC5C;AAAA,UACJ,WACS,cAAc,MAAM;AAIzB,yBAAa,cAAc,MAAM,oBAAoB;AAAA,cACjD,cAAc,UAAU;AAAA,cACxB,mBAAmB;AAAA,cACnB,cAAc,YAAY,UAAU,IAAI,aAAa;AAAA,cACrD;AAAA,YACJ,CAAC,GAAG,UAAU;AAAA,UAClB;AACA,cAAI,eAAe,QAAQ;AACvB,2BAAe,MAAM,KAAK,CAAC,GAAG,GAAG,UAAU,IAAI,YAAY,GAAG;AAAA,UAClE;AAAA,QACJ,OACK;AACD,cAAI,WAAW,yBAAyB,WAAW,QAAQ,cAAc;AACzE,cAAI,CAAC,YAAY,UAAU,SAAS,KAAK,iBAAiB;AACtD,kBAAM,kBAAkB,GAAG,UAAU,KAAK,KAAK;AAAA,UACnD;AACA,cAAI,YAAY,SAAS,gBAAgB,UAAU,QAAQ,GAAG;AAC1D,qBAAS,aAAa,WAAW,QAAQ,QAAQ,KAAK,OAAO;AAAA,UACjE;AAAA,QACJ;AAAA,MACJ,CAAC;AACD,UAAIC,UAAS,eAAe,cAAc;AAC1C,UAAI,cAAc,EAAE,QAAQA,SAAQ,QAAiB;AACrD,UAAI,SAAS,QAAQ,kBACjB,KAAK,MAAM,MAAM,WAAW,IAG1B,gBAAgB,WAAW;AAGjC,UAAI,OAAO,QAAQ;AACf,aAAK,aAAa,IAAI,OAAO,QAAQ,YAAY;AAAA,MACrD;AACA,aAAO;AAAA,IACX;AAEA,IAAAH,aAAY,UAAU,2BAA2B,SAAUE,KAAI;AAC3D,UAAI,QAAQ;AACZ,UAAI,QAAQA,IAAG,OAAO,QAAQA,IAAG,OAAO,eAAeA,IAAG,cAAc,UAAUA,IAAG;AACrF,UAAI;AACJ,UAAI,gBAAgB,IAAI,WAAW;AACnC,eAAS,cAAc,aAAa,GAAG;AACnC,YAAIA;AACJ,YAAI,YAAY,SAAS;AACrB,oBAAU,cAAc,MAAM,UAAUA,MAAK,CAAC,GAAGA,IAAG,CAAC,IAAI,YAAY,SAASA,IAAG;AAAA,QACrF;AACA,eAAO,YAAY;AAAA,MACvB;AACA,UAAI,MAAM,cAAc;AACpB,gBAAQ,MAAM,OAAO,QAAQ,MAAM,OAAO;AAAA,MAC9C;AACA,cAAQ,MAAM,IAAI,SAAU,MAAM,GAAG;AAEjC,YAAI,SAAS,MAAM;AACf,iBAAO;AAAA,QACX;AAEA,YAAI,QAAQ,IAAI,GAAG;AACf,iBAAO,cAAc,MAAM,wBAAwB;AAAA,YAC/C;AAAA,YACA,OAAO;AAAA,YACP;AAAA,YACA;AAAA,UACJ,CAAC,GAAG,CAAC;AAAA,QACT;AAEA,YAAI,MAAM,cAAc;AACpB,iBAAO,cAAc,MAAM,oBAAoB;AAAA,YAC3C,cAAc,MAAM;AAAA,YACpB,mBAAmB;AAAA,YACnB,cAAc,YAAY,IAAI,IAAI,OAAO;AAAA,YACzC;AAAA,UACJ,CAAC,GAAG,CAAC;AAAA,QACT;AACA,YAAI,WAAW,YAAY,OAAO;AAC9B,uCAA6B,QAAQ,OAAO,OAAO,IAAI;AAAA,QAC3D;AACA,eAAO;AAAA,MACX,CAAC;AACD,aAAO;AAAA,QACH,QAAQ,QAAQ,kBAAkB,KAAK,MAAM,MAAM,KAAK,IAAI;AAAA,QAC5D;AAAA,MACJ;AAAA,IACJ;AACA,WAAOF;AAAA,EACX,EAAE;AAAA;AAEF,SAAS,aAAa,MAAM;AACxB,MAAI;AACA,SAAK,UAAU,MAAM,SAAU,GAAG,OAAO;AACrC,UAAI,OAAO,UAAU;AACjB,cAAM;AACV,aAAO;AAAA,IACX,CAAC;AAAA,EACL,SACOI,SAAQ;AACX,WAAOA;AAAA,EACX;AACJ;AACA,SAAS,6BAA6B,OAAO,OAAO,YAAY;AAC5D,MAAI,CAAC,MAAM,cAAc;AACrB,QAAI,YAAY,oBAAI,IAAI,CAAC,UAAU,CAAC;AACpC,cAAU,QAAQ,SAAU,OAAO;AAC/B,UAAI,gBAAgB,KAAK,GAAG;AACxB,QAAAC;AAAA,UACI,CAAC,YAAY,KAAK;AAAA,UAClB;AAAA,UACA,2BAA2B,OAAO,KAAK;AAAA,UACvC,MAAM,KAAK;AAAA,QACf;AACA,eAAO,OAAO,KAAK,EAAE,QAAQ,UAAU,KAAK,SAAS;AAAA,MACzD;AAAA,IACJ,CAAC;AAAA,EACL;AACJ;;;AC5TO,IAAI,YAAY,IAAI,KAAK;AAChC,IAAI,eAAe,oBAAI,QAAQ;AAC/B,SAAS,aAAa,OAAO;AACzB,MAAI,OAAO,aAAa,IAAI,KAAK;AACjC,MAAI,CAAC,MAAM;AACP,iBAAa,IAAI,OAAQ,OAAO;AAAA,MAC5B,MAAM,oBAAI,IAAI;AAAA,MACd,KAAK,IAAI;AAAA,IACb,CAAE;AAAA,EACN;AACA,SAAO;AACX;AACO,SAAS,YAAY,OAAO;AAC/B,eAAa,KAAK,EAAE,KAAK,QAAQ,SAAU,IAAI;AAAE,WAAO,GAAG,YAAY,KAAK;AAAA,EAAG,CAAC;AACpF;AASO,SAAS,YAAY,OAAO;AAC/B,eAAa,KAAK,EAAE,KAAK,QAAQ,SAAU,IAAI;AAAE,WAAO,GAAG,YAAY,KAAK;AAAA,EAAG,CAAC;AACpF;AACO,SAAS,QAAQ,OAAO;AAC3B,MAAIC,UAAS,oBAAI,IAAI;AACrB,MAAI,YAAY,oBAAI,IAAI;AACxB,MAAI,KAAK,SAAU,UAAU;AACzB,QAAI,UAAU,SAAS,GAAG;AACtB,UAAI,UAAU,UAAU;AACpB,gBAAQ;AACR,QAAAA,QAAO,QAAQ,SAAUC,QAAO;AAI5B,uBAAaA,MAAK,EAAE,IAAI,MAAM,EAAE;AAGhC,oBAAUA,MAAK;AAAA,QACnB,CAAC;AAED,YAAI,eAAe,MAAM,KAAK,SAAS;AACvC,kBAAU,MAAM;AAChB,qBAAa,QAAQ,SAAU,UAAU;AAAE,iBAAO,SAAS,KAAK;AAAA,QAAG,CAAC;AAAA,MACxE;AAAA,IACJ,OACK;AAID,UAAI,QAAQ,UAAU,SAAS;AAC/B,UAAI,OAAO;AACP,eAAO,KAAK;AACZ,qBAAa,KAAK,EAAE,IAAI,EAAE;AAAA,MAC9B;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACA,KAAG,eAAe,SAAU,UAAU;AAClC,cAAU,IAAI,QAAQ;AACtB,WAAO,WAAY;AACf,gBAAU,OAAO,QAAQ;AAAA,IAC7B;AAAA,EACJ;AACA,MAAI,SAAU,GAAG,cAAc,SAAU,OAAO;AAC5C,IAAAD,QAAO,IAAI,KAAK;AAChB,iBAAa,KAAK,EAAE,KAAK,IAAI,EAAE;AAC/B,WAAO;AAAA,EACX;AACA,KAAG,cAAc,SAAU,OAAO;AAAE,WAAOA,QAAO,OAAO,KAAK;AAAA,EAAG;AACjE,SAAO;AACX;AACA,SAAS,UAAU,OAAO;AACtB,MAAI,MAAM,kBAAkB;AACxB,UAAM,iBAAiB;AAAA,EAC3B;AACJ;;;AC7EA,IAAI,qBAAqB,uBAAO,OAAO,IAAI;AAC3C,SAAS,oBAAoB,MAAM;AAI/B,MAAI,WAAW,KAAK,UAAU,IAAI;AAClC,SAAQ,mBAAmB,QAAQ,MAC9B,mBAAmB,QAAQ,IAAI,uBAAO,OAAO,IAAI;AAC1D;AACO,SAAS,yBAAyB,WAAW;AAChD,MAAI,OAAO,oBAAoB,SAAS;AACxC,SAAQ,KAAK,gBAAgB,KAAK,cAAc,SAAU,QAAQ,SAAS;AACnE,QAAI,UAAU,SAAUE,OAAM,KAAK;AAC/B,aAAO,QAAQ,UAAU,KAAKA,KAAI;AAAA,IACtC;AACA,QAAI,YAAa,QAAQ,YAAY,sBAAsB,WAAW,SAAU,eAAe;AAC3F,UAAI,YAAY;AAAA,QAAe,QAAQ;AAAA,QAAa;AAAA;AAAA;AAAA;AAAA,QAIpD;AAAA,MAAO;AACP,UAAI,cAAc,UACd,WAAW,QAAQ,eACnB,OAAO,KAAK,QAAQ,cAAc,CAAC,CAAC,GAAG;AAUvC,oBAAY,eAAe,QAAQ,eAAe,UAAU;AAAA,MAChE;AACA,MAAAC,WAAU,cAAc,QAAQ,GAAG,cAAc,KAAK,GAAG,GAAG,MAAM;AAClE,aAAO;AAAA,IACX,CAAC;AACD,WAAO,GAAG,OAAO,QAAQ,UAAU,GAAG,EAAE,OAAO,KAAK,UAAU,SAAS,CAAC;AAAA,EAC5E;AACR;AAQO,SAAS,uBAAuB,WAAW;AAC9C,MAAI,OAAO,oBAAoB,SAAS;AACxC,SAAQ,KAAK,cACR,KAAK,YAAY,SAAU,MAAMC,KAAI;AAClC,QAAI,QAAQA,IAAG,OAAO,YAAYA,IAAG,WAAW,YAAYA,IAAG;AAC/D,QAAI,YAAY,sBAAsB,WAAW,SAAU,SAAS;AAChE,UAAI,WAAW,QAAQ,CAAC;AACxB,UAAI,YAAY,SAAS,OAAO,CAAC;AACjC,UAAI,cAAc,KAAK;AACnB,YAAI,SAAS,gBAAgB,MAAM,UAAU,GAAG;AAC5C,cAAI,kBAAkB,SAAS,MAAM,CAAC;AAItC,cAAI,IAAI,MAAM,WAAW,KAAK,SAAUC,IAAG;AAAE,mBAAOA,GAAE,KAAK,UAAU;AAAA,UAAiB,CAAC;AAEvF,cAAI,gBAAgB,KAAK,yBAAyB,GAAG,SAAS;AAQ9D,iBAAQ,iBACJ;AAAA,YAAe;AAAA;AAAA;AAAA;AAAA,YAIf,QAAQ,MAAM,CAAC;AAAA,UAAC;AAAA,QACxB;AAIA;AAAA,MACJ;AACA,UAAI,cAAc,KAAK;AACnB,YAAI,eAAe,SAAS,MAAM,CAAC;AACnC,YAAI,aAAa,OAAO,KAAK,WAAW,YAAY,GAAG;AACnD,cAAI,aAAa,QAAQ,MAAM,CAAC;AAChC,qBAAW,CAAC,IAAI;AAChB,iBAAO,eAAe,WAAW,UAAU;AAAA,QAC/C;AAIA;AAAA,MACJ;AACA,UAAI,MAAM;AACN,eAAO,eAAe,MAAM,OAAO;AAAA,MACvC;AAAA,IACJ,CAAC;AACD,QAAI,SAAS,KAAK,UAAU,SAAS;AAMrC,QAAI,QAAQ,WAAW,MAAM;AACzB,mBAAa,MAAM;AAAA,IACvB;AACA,WAAO;AAAA,EACX;AACR;AACO,SAAS,sBAAsB,WAAW,WAAW;AAGxD,MAAI,SAAS,IAAI,WAAW;AAC5B,SAAO,kBAAkB,SAAS,EAAE,OAAO,SAAU,WAAW,MAAM;AAClE,QAAID;AACJ,QAAI,UAAU,UAAU,IAAI;AAC5B,QAAI,YAAY,QAAQ;AAGpB,eAAS,IAAI,KAAK,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AACvC,mBAAWA,MAAK,CAAC,GAAGA,IAAG,KAAK,CAAC,CAAC,IAAI,SAASA;AAAA,MAC/C;AACA,kBAAY,OAAO,MAAM,WAAW,OAAO;AAAA,IAC/C;AACA,WAAO;AAAA,EACX,GAAG,uBAAO,OAAO,IAAI,CAAC;AAC1B;AACO,SAAS,kBAAkB,MAAM;AACpC,MAAI,OAAO,oBAAoB,IAAI;AACnC,MAAI,CAAC,KAAK,OAAO;AACb,QAAI,UAAW,KAAK,QAAQ,CAAC;AAC7B,QAAI,gBAAgB,CAAC;AACrB,SAAK,QAAQ,SAAU,GAAG,GAAG;AACzB,UAAI,QAAQ,CAAC,GAAG;AACZ,0BAAkB,CAAC,EAAE,QAAQ,SAAU,GAAG;AAAE,iBAAO,QAAQ,KAAK,cAAc,OAAO,CAAC,CAAC;AAAA,QAAG,CAAC;AAC3F,sBAAc,SAAS;AAAA,MAC3B,OACK;AACD,sBAAc,KAAK,CAAC;AACpB,YAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,CAAC,GAAG;AACvB,kBAAQ,KAAK,cAAc,MAAM,CAAC,CAAC;AACnC,wBAAc,SAAS;AAAA,QAC3B;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AACA,SAAO,KAAK;AAChB;AACA,SAAS,WAAW,QAAQ,KAAK;AAC7B,SAAO,OAAO,GAAG;AACrB;AACO,SAAS,eAAe,QAAQ,MAAM,SAAS;AAYlD,YAAU,WAAW;AACrB,SAAO,UAAU,KAAK,OAAO,SAAS,QAAQ,KAAK,KAAK;AACpD,WAAO,QAAQ,GAAG,IACd,IAAI,IAAI,SAAU,OAAO;AAAE,aAAO,QAAQ,OAAO,GAAG;AAAA,IAAG,CAAC,IACtD,OAAO,QAAQ,KAAK,GAAG;AAAA,EACjC,GAAG,MAAM,CAAC;AACd;AACA,SAAS,UAAU,OAAO;AAItB,MAAI,gBAAgB,KAAK,GAAG;AACxB,QAAI,QAAQ,KAAK,GAAG;AAChB,aAAO,MAAM,IAAI,SAAS;AAAA,IAC9B;AACA,WAAO,sBAAsB,OAAO,KAAK,KAAK,EAAE,KAAK,GAAG,SAAU,MAAM;AACpE,aAAO,eAAe,OAAO,IAAI;AAAA,IACrC,CAAC;AAAA,EACL;AACA,SAAO;AACX;;;ACpLA,gBAAgB,aAAa,kBAAkB;AAC/C,SAAS,uBAAuB,MAAM;AAClC,SAAQ,KAAK,SAAS,SAAS,KAAK,OAC9B,KAAK,QAAQ,yBAAyB,KAAK,OAAO,KAAK,SAAS,IAC5D;AACd;AACA,IAAI,kBAAkB,WAAY;AAAE,SAAO;AAAQ;AACnD,IAAI,kBAAkB,SAAU,OAAO,SAAS;AAAE,SAAO,QAAQ;AAAW;AAG5E,IAAI,cAAc,SAAU,UAAU,UAAUE,KAAI;AAChD,MAAI,eAAeA,IAAG;AACtB,SAAO,aAAa,UAAU,QAAQ;AAC1C;AACA,IAAI,eAAe,SAAU,GAAG,UAAU;AAAE,SAAO;AAAU;AAC7D,IAAI;AAAA;AAAA,EAA0B,WAAY;AACtC,aAASC,UAAS,QAAQ;AACtB,WAAK,SAAS;AACd,WAAK,eAAe,uBAAO,OAAO,IAAI;AACtC,WAAK,YAAY,uBAAO,OAAO,IAAI;AAKnC,WAAK,eAAe,oBAAI,IAAI;AAK5B,WAAK,gBAAgB,oBAAI,IAAI;AAC7B,WAAK,oBAAoB,uBAAO,OAAO,IAAI;AAC3C,WAAK,oBAAoB,uBAAO,OAAO,IAAI;AAC3C,WAAK,qBAAqB;AAC1B,WAAK,SAAS,SAAS,EAAE,kBAAkB,wBAAwB,GAAG,MAAM;AAC5E,WAAK,QAAQ,KAAK,OAAO;AACzB,WAAK,gBAAgB,OAAO;AAC5B,WAAK,gBAAgB,UAAU;AAC/B,WAAK,gBAAgB,cAAc;AACnC,UAAI,OAAO,eAAe;AACtB,aAAK,iBAAiB,OAAO,aAAa;AAAA,MAC9C;AACA,UAAI,OAAO,cAAc;AACrB,aAAK,gBAAgB,OAAO,YAAY;AAAA,MAC5C;AAAA,IACJ;AACA,IAAAA,UAAS,UAAU,WAAW,SAAU,QAAQ,gBAAgB;AAC5D,UAAID;AACJ,UAAI,WAAW;AACf,UAAI,WAAY,mBACX,eAAe,cAAcA,MAAK,eAAe,iBAAiB,QAAQA,QAAO,SAAS,SAASA,IAAG,gBACvG,OAAO;AAMX,UAAI,aAAa,KAAK,kBAAkB,YAAY;AAChD,eAAO,CAAC,YAAY;AAAA,MACxB;AAEA,UAAI,cAAe,kBAAkB,eAAe,eAAgB;AACpE,UAAI,UAAU,SAAS,SAAS,CAAC,GAAG,cAAc,GAAG,EAAE,UAAoB,aAA0B,WAAY,kBAAkB,eAAe,aAC1I,WAAY;AACR,YAAI,UAAU,0BAA0B,WAAW,WAAW;AAC9D,eAAO,SAAS,UAAU,SAAS;AAAA,UAC/B,OAAO,SAAS,MAAM,MAAM;AAAA,UAC5B,WAAW,QAAQ;AAAA,QACvB,CAAC;AAAA,MACL,EAAE,CAAC;AACX,UAAI;AACJ,UAAI,SAAS,YAAY,KAAK,cAAc,QAAQ;AACpD,UAAI,QAAS,UAAU,OAAO,SAAU,KAAK,OAAO;AACpD,aAAO,OAAO;AACV,YAAI,gBAAgB,MAAM,SAAS,SAAS,CAAC,GAAG,MAAM,GAAG,WAAW,GAAG,OAAO;AAC9E,YAAI,QAAQ,aAAa,GAAG;AACxB,kBAAQ,yBAAyB,aAAa;AAAA,QAClD,OACK;AACD,eAAK;AACL;AAAA,QACJ;AAAA,MACJ;AACA,WAAK,KAAK,OAAO,EAAE,IAAI;AACvB,aAAO,QAAQ,YAAY,CAAC,IAAI,QAAQ,SAAS,IAAI,CAAC,EAAE;AAAA,IAC5D;AACA,IAAAC,UAAS,UAAU,kBAAkB,SAAU,cAAc;AACzD,UAAI,QAAQ;AACZ,aAAO,KAAK,YAAY,EAAE,QAAQ,SAAU,UAAU;AAClD,YAAID,MAAK,aAAa,QAAQ,GAAG,YAAYA,IAAG,WAAW,eAAeA,IAAG,cAAc,mBAAmBA,IAAG,kBAAkB,WAAW,OAAOA,KAAI,CAAC,aAAa,gBAAgB,kBAAkB,CAAC;AAe1M,YAAI;AACA,gBAAM,gBAAgB,SAAS,QAAQ;AAC3C,YAAI;AACA,gBAAM,gBAAgB,YAAY,QAAQ;AAC9C,YAAI;AACA,gBAAM,gBAAgB,gBAAgB,QAAQ;AAClD,YAAI,OAAO,KAAK,MAAM,WAAW,QAAQ,GAAG;AACxC,gBAAM,UAAU,QAAQ,EAAE,KAAK,QAAQ;AAAA,QAC3C,OACK;AACD,gBAAM,UAAU,QAAQ,IAAI,CAAC,QAAQ;AAAA,QACzC;AAAA,MACJ,CAAC;AAAA,IACL;AACA,IAAAC,UAAS,UAAU,mBAAmB,SAAU,UAAU,UAAU;AAChE,UAAI,QAAQ;AACZ,UAAI,WAAW,KAAK,cAAc,QAAQ;AAC1C,UAAI,YAAY,SAAS,WAAW,SAAS,SAAS;AACtD,eAAS,SAASC,WAAU,OAAO;AAC/B,QAAAA,UAAS,QACL,OAAO,UAAU,aAAa,QAGxB,UAAU,OAAO,cAGb,UAAU,QAAQ,eACdA,UAAS;AAAA,MAC/B;AAGA,eAAS,UAAU,SAAS,KAAK;AACjC,eAAS;AAAA,MAEL,cAAc,QAAQ,kBAGhB,QAAQ,SAAS,IAAI,yBAAyB,SAAS,IAEnD,OAAO,cAAc,aAAa,YAE9B,SAAS;AAC3B,UAAI,QAAQ;AACR,eAAO,KAAK,MAAM,EAAE,QAAQ,SAAU,WAAW;AAC7C,cAAIA,YAAW,MAAM,eAAe,UAAU,WAAW,IAAI;AAC7D,cAAIC,YAAW,OAAO,SAAS;AAC/B,cAAI,OAAOA,cAAa,YAAY;AAChC,YAAAD,UAAS,OAAOC;AAAA,UACpB,OACK;AACD,gBAAI,UAAUA,UAAS,SAAS,OAAOA,UAAS,MAAM,QAAQA,UAAS;AACvE,YAAAD,UAAS;AAAA;AAAA,YAGL,YAAY,QAAQ,kBAGd,QAAQ,OAAO,IAAI,uBAAuB,OAAO,IAE7C,OAAO,YAAY,aAAa,UAE5BA,UAAS;AAC3B,gBAAI,OAAO,SAAS,YAAY;AAC5B,cAAAA,UAAS,OAAO;AAAA,YACpB;AACA,qBAASA,WAAU,KAAK;AAAA,UAC5B;AACA,cAAIA,UAAS,QAAQA,UAAS,OAAO;AAMjC,YAAAA,UAAS,QAAQA,UAAS,SAAS;AAAA,UACvC;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ;AACA,IAAAD,UAAS,UAAU,kBAAkB,SAAU,OAAO,UAAU;AAC5D,UAAI,aAAa,QAAQ;AAAE,mBAAW;AAAA,MAAO;AAC7C,UAAI,SAAS,UAAU,MAAM,YAAY;AACzC,UAAI,MAAM,KAAK,kBAAkB,MAAM;AACvC,UAAI,aAAa,KAAK;AAClB,QAAAG,WAAU,CAAC,OAAO,QAAQ,OAAO,GAAG,KAAK;AAGzC,YAAI;AACA,iBAAO,KAAK,kBAAkB,GAAG;AAErC,aAAK,kBAAkB,QAAQ,IAAI;AAEnC,aAAK,kBAAkB,MAAM,IAAI;AAAA,MACrC;AAAA,IACJ;AACA,IAAAH,UAAS,UAAU,mBAAmB,SAAU,eAAe;AAC3D,UAAI,QAAQ;AACZ,WAAK,qBAAqB;AAC1B,aAAO,KAAK,aAAa,EAAE,QAAQ,SAAU,WAAW;AAIpD,cAAM,gBAAgB,WAAW,IAAI;AACrC,sBAAc,SAAS,EAAE,QAAQ,SAAU,SAAS;AAChD,gBAAM,gBAAgB,SAAS,IAAI,EAAE,IAAI,SAAS;AAClD,cAAI,QAAQ,QAAQ,MAAM,qBAAqB;AAC/C,cAAI,CAAC,SAAS,MAAM,CAAC,MAAM,SAAS;AAEhC,kBAAM,cAAc,IAAI,SAAS,IAAI,OAAO,OAAO,CAAC;AAAA,UACxD;AAAA,QACJ,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AACA,IAAAA,UAAS,UAAU,gBAAgB,SAAU,UAAU;AACnD,UAAI,QAAQ;AACZ,UAAI,CAAC,OAAO,KAAK,KAAK,cAAc,QAAQ,GAAG;AAC3C,YAAI,WAAY,KAAK,aAAa,QAAQ,IAAI,uBAAO,OAAO,IAAI;AAChE,iBAAS,SAAS,uBAAO,OAAO,IAAI;AAsBpC,YAAI,eAAe,KAAK,aAAa,IAAI,QAAQ;AACjD,YAAI,CAAC,gBAAgB,KAAK,cAAc,MAAM;AAI1C,yBAAe,KAAK,gBAAgB,UAAU,IAAI;AAMlD,eAAK,cAAc,QAAQ,SAAU,QAAQ,OAAO;AAChD,gBAAI,OAAO,KAAK,QAAQ,GAAG;AAIvB,kBAAI,kBAAkB,MAAM,aAAa,IAAI,KAAK;AAClD,kBAAI,iBAAiB;AACjB,gCAAgB,QAAQ,SAAU,WAAW;AACzC,yBAAO,aAAa,IAAI,SAAS;AAAA,gBACrC,CAAC;AAAA,cACL;AAAA,YACJ;AAAA,UACJ,CAAC;AAAA,QACL;AACA,YAAI,gBAAgB,aAAa,MAAM;AACnC,uBAAa,QAAQ,SAAU,WAAW;AACtC,gBAAID,MAAK,MAAM,cAAc,SAAS,GAAG,SAASA,IAAG,QAAQ,OAAO,OAAOA,KAAI,CAAC,QAAQ,CAAC;AACzF,mBAAO,OAAO,UAAU,IAAI;AAC5B,mBAAO,OAAO,SAAS,QAAQ,MAAM;AAAA,UACzC,CAAC;AAAA,QACL;AAAA,MACJ;AACA,UAAI,QAAQ,KAAK,UAAU,QAAQ;AACnC,UAAI,SAAS,MAAM,QAAQ;AAGvB,cAAM,OAAO,CAAC,EAAE,QAAQ,SAAU,QAAQ;AACtC,gBAAM,iBAAiB,UAAU,MAAM;AAAA,QAC3C,CAAC;AAAA,MACL;AACA,aAAO,KAAK,aAAa,QAAQ;AAAA,IACrC;AACA,IAAAC,UAAS,UAAU,iBAAiB,SAAU,UAAU,WAAW,iBAAiB;AAChF,UAAI,UAAU;AACV,YAAI,gBAAgB,KAAK,cAAc,QAAQ,EAAE;AACjD,eAAQ,cAAc,SAAS,KAC1B,oBAAoB,cAAc,SAAS,IAAI,uBAAO,OAAO,IAAI;AAAA,MAC1E;AAAA,IACJ;AACA,IAAAA,UAAS,UAAU,kBAAkB,SAAU,SAAS,iBAAiB;AACrE,UAAI,eAAe,KAAK,aAAa,IAAI,OAAO;AAChD,UAAI,CAAC,gBAAgB,iBAAiB;AAClC,aAAK,aAAa,IAAI,SAAU,eAAe,oBAAI,IAAI,CAAE;AAAA,MAC7D;AACA,aAAO;AAAA,IACX;AACA,IAAAA,UAAS,UAAU,kBAAkB,SAAU,UAAU,UAAUI,SAAQ,WAAW;AAClF,UAAI,QAAQ;AACZ,UAAI,CAAC,SAAS;AACV,eAAO;AAGX,UAAI,CAAC;AACD,eAAO;AACX,UAAI,YAAY,SAAS,cAAc,KAAK;AAE5C,UAAI,aAAa;AACb,eAAO;AACX,UAAI,KAAK,sBAAsB,KAAK,aAAa,IAAI,SAAS,GAAG;AAC7D,YAAI,uBAAuB,KAAK,gBAAgB,UAAU,IAAI;AAC9D,YAAI,cAAc,CAAC,oBAAoB;AACvC,YAAI,iBAAiB,SAAU,SAAS;AACpC,cAAIC,gBAAe,MAAM,gBAAgB,SAAS,KAAK;AACvD,cAAIA,iBACAA,cAAa,QACb,YAAY,QAAQA,aAAY,IAAI,GAAG;AACvC,wBAAY,KAAKA,aAAY;AAAA,UACjC;AAAA,QACJ;AAOA,YAAI,2BAA2B,CAAC,EAAED,WAAU,KAAK,cAAc;AAC/D,YAAI,wBAAwB;AAG5B,iBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,EAAE,GAAG;AACzC,cAAI,eAAe,YAAY,CAAC;AAChC,cAAI,aAAa,IAAI,SAAS,GAAG;AAC7B,gBAAI,CAAC,qBAAqB,IAAI,SAAS,GAAG;AACtC,kBAAI,uBAAuB;AACvB,2BAAW,YAAY,SAASD,WAAU,KAAK,GAAG,UAAU,SAAS;AAAA,cACzE;AAKA,mCAAqB,IAAI,SAAS;AAAA,YACtC;AACA,mBAAO;AAAA,UACX;AACA,uBAAa,QAAQ,cAAc;AACnC,cAAI;AAAA;AAAA,UAGA,MAAM,YAAY,SAAS;AAAA;AAAA;AAAA;AAAA,UAK3B,0BAA0B,SAAS,cAAcC,SAAQ,SAAS,GAAG;AAIrE,uCAA2B;AAC3B,oCAAwB;AAKxB,iBAAK,cAAc,QAAQ,SAAU,QAAQ,aAAa;AACtD,kBAAI,QAAQ,SAAS,MAAM,MAAM;AACjC,kBAAI,SAAS,MAAM,CAAC,MAAM,UAAU;AAChC,+BAAe,WAAW;AAAA,cAC9B;AAAA,YACJ,CAAC;AAAA,UACL;AAAA,QACJ;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACA,IAAAJ,UAAS,UAAU,aAAa,SAAU,UAAU,WAAW;AAC3D,UAAI,SAAS,KAAK,eAAe,UAAU,WAAW,KAAK;AAC3D,aAAO,CAAC,EAAE,UAAU,OAAO;AAAA,IAC/B;AACA,IAAAA,UAAS,UAAU,oBAAoB,SAAU,WAAW;AACxD,UAAI,WAAW,UAAU,UAAU,YAAY,UAAU;AACzD,UAAI,SAAS,KAAK,eAAe,UAAU,WAAW,KAAK;AAC3D,UAAI;AACJ,UAAI,QAAQ,UAAU,OAAO;AAC7B,UAAI,SAAS,UAAU;AACnB,YAAI,UAAU;AAAA,UACV;AAAA,UACA;AAAA,UACA,OAAO,UAAU,SAAS;AAAA,UAC1B,WAAW,UAAU;AAAA,QACzB;AACA,YAAI,OAAO,uBAAuB,SAAS;AAC3C,eAAO,OAAO;AACV,cAAI,oBAAoB,MAAM,MAAM,OAAO;AAC3C,cAAI,QAAQ,iBAAiB,GAAG;AAC5B,oBAAQ,uBAAuB,iBAAiB;AAAA,UACpD,OACK;AAGD,6BAAiB,qBAAqB;AACtC;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,mBAAmB,QAAQ;AAC3B,yBACI,UAAU,QACN,sBAAsB,UAAU,OAAO,UAAU,SAAS,IACxD,gBAAgB,WAAW,uBAAuB,SAAS,CAAC;AAAA,MAC1E;AAGA,UAAI,mBAAmB,OAAO;AAC1B,eAAO;AAAA,MACX;AAIA,aAAO,cAAc,uBAAuB,cAAc,IAAI,iBACxD,YAAY,MAAM;AAAA,IAC5B;AACA,IAAAA,UAAS,UAAU,YAAY,SAAU,SAAS,SAAS;AACvD,UAAI,oBAAoB,QAAQ;AAChC,UAAI,CAAC;AACD;AACJ,UAAI,cAAc,QAAQ,SAAS,QAAQ;AAC3C,UAAI,CAAC;AACD;AACJ,UAAI,QAAQ,aAAa,QAAQ;AAC7B,YAAI,WAAW,QAAQ,MAAM,cAAc,mBAAmB,YAAY;AAC1E,YAAI;AACA,kBAAQ,WAAW;AAAA,MAC3B;AACA,UAAI,iBAAiB,KAAK,kBAAkB,OAAO;AACnD,UAAI,YAAY,uBAAuB,cAAc;AACrD,UAAI,WAAW,QAAQ,MAAM,cAAc,mBAAmB,cAAc;AAC5E,UAAI,SAAS,KAAK,eAAe,QAAQ,UAAU,WAAW,KAAK;AACnE,UAAI,OAAO,UAAU,OAAO;AAC5B,UAAI,MAAM;AACN,YAAI,cAAc,yBAAyB,MAAM,mBAAmB,SAAS,SAAS,QAAQ,MAAM,WAAW,YAAY,iBAAiB,IACxI,kBAAkB,QAChB,mBAAmB,cAAc,CAAC;AAExC,eAAO,UAAU,UAAU,KAAK,OAAO,MAAM;AAAA,UACzC;AAAA,UACA;AAAA,QACJ,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AACA,IAAAA,UAAS,UAAU,kBAAkB,SAAU,UAAU,WAAW;AAChE,UAAI,SAAS,KAAK,eAAe,UAAU,WAAW,KAAK;AAC3D,aAAO,UAAU,OAAO;AAAA,IAC5B;AACA,IAAAA,UAAS,UAAU,mBAAmB,SAAU,gBAAgB,WAAW,eAAe;AACtF,UAAI,SAAS,KAAK,eAAe,gBAAgB,WAAW,KAAK;AACjE,UAAI,QAAQ,UAAU,OAAO;AAC7B,UAAI,CAAC,SAAS,eAAe;AACzB,iBAAS,KAAK,cAAc,aAAa;AACzC,gBAAQ,UAAU,OAAO;AAAA,MAC7B;AACA,aAAO;AAAA,IACX;AACA,IAAAA,UAAS,UAAU,mBAAmB,SAAU,UAAU,UAAUD,KAAI,SAAS,SAAS;AACtF,UAAI,QAAQA,IAAG,OAAO,WAAWA,IAAG,UAAU,QAAQA,IAAG;AACzD,UAAI,UAAU,aAAa;AAIvB,eAAO,yBAAyB,QAAQ,KAAK,EAAE,UAAU,QAAQ;AAAA,MACrE;AACA,UAAI,UAAU,cAAc;AAExB,eAAO;AAAA,MACX;AAKA,UAAI,QAAQ,WAAW;AACnB,mBAAW;AAAA,MACf;AACA,aAAO,MAAM,UAAU,UAAU;AAAA,QAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAY1D;AAAA,QAAQ;AAAA,UACJ;AAAA,UACA,WAAW,MAAM,KAAK;AAAA,UACtB;AAAA,UACA,WAAW,QAAQ;AAAA,QACvB;AAAA,QAAG;AAAA,QAAS,WAAW,uBAAO,OAAO,IAAI;AAAA,MAAC,CAAC;AAAA,IAC/C;AACA,WAAOC;AAAA,EACX,EAAE;AAAA;AAEF,SAAS,yBAAyB,UAAU,mBAAmB,WAAW,SAAS,SAAS;AACxF,MAAI,iBAAiB,SAAS,kBAAkB,SAAS;AACzD,MAAI,YAAY,uBAAuB,cAAc;AACrD,MAAI,YAAY,UAAU,aAAa,QAAQ;AAC/C,MAAIM,MAAK,QAAQ,OAAO,cAAcA,IAAG,aAAa,UAAUA,IAAG;AACnE,SAAO;AAAA,IACH,MAAM,uBAAuB,SAAS;AAAA,IACtC,OAAO,UAAU,SAAS;AAAA,IAC1B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO,SAAS;AAAA,IAChB;AAAA,IACA,WAAW,WAAY;AACnB,aAAO,SAAS,UAAU,0BAA0B,WAAW,mBAAmB,SAAS,GAAG,OAAO;AAAA,IACzG;AAAA,IACA,cAAc,yBAAyB,QAAQ,KAAK;AAAA,EACxD;AACJ;AACO,SAAS,0BAA0B,eAAe,mBAAmB,WAAW;AACnF,MAAI,qBAAqB,cAAc,CAAC,GAAGC,QAAO,cAAc,CAAC,GAAG,OAAO,cAAc;AACzF,MAAI;AACJ,MAAI,OAAO,uBAAuB,UAAU;AACxC,cAAU;AAAA,MACN,WAAW;AAAA;AAAA;AAAA;AAAA,MAIX,MAAM,OAAO,IAAIA,QAAO;AAAA,IAC5B;AAAA,EACJ,OACK;AACD,cAAU,SAAS,CAAC,GAAG,kBAAkB;AAGzC,QAAI,CAAC,OAAO,KAAK,SAAS,MAAM,GAAG;AAC/B,cAAQ,OAAO;AAAA,IACnB;AAAA,EACJ;AACA,MAAI,WAAW,YAAY,SAAS,QAAQ,SAAS,QAAQ;AACzD,eAAW,YAAY,SAASC,WAAU,KAAK,GAAG,oBAAoB,MAAM,KAAK,aAAa,CAAC,CAAC;AAAA,EACpG;AACA,MAAI,WAAW,QAAQ,WAAW;AAC9B,YAAQ,YAAY;AAAA,EACxB;AACA,SAAO;AACX;AACA,SAAS,yBAAyB,OAAO;AACrC,SAAO,SAAS,aAAa,UAAU,UAAU;AAC7C,QAAI,QAAQ,QAAQ,KAAK,QAAQ,QAAQ,GAAG;AACxC,YAAM,kBAAkB,CAAC;AAAA,IAC7B;AAKA,QAAI,gBAAgB,QAAQ,KAAK,gBAAgB,QAAQ,GAAG;AACxD,UAAI,QAAQ,MAAM,cAAc,UAAU,YAAY;AACtD,UAAI,QAAQ,MAAM,cAAc,UAAU,YAAY;AACtD,UAAI,cAAc,SAAS,SAAS,UAAU;AAC9C,UAAI,aAAa;AACb,eAAO;AAAA,MACX;AACA,UAAI,YAAY,QAAQ,KAAK,wBAAwB,QAAQ,GAAG;AAI5D,cAAM,MAAM,SAAS,OAAO,QAAQ;AACpC,eAAO;AAAA,MACX;AACA,UAAI,wBAAwB,QAAQ,KAAK,YAAY,QAAQ,GAAG;AAK5D,cAAM,MAAM,UAAU,SAAS,KAAK;AACpC,eAAO;AAAA,MACX;AACA,UAAI,wBAAwB,QAAQ,KAChC,wBAAwB,QAAQ,GAAG;AACnC,eAAO,SAAS,SAAS,CAAC,GAAG,QAAQ,GAAG,QAAQ;AAAA,MACpD;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACJ;;;AC9kBA,SAAS,iBAAiB,SAAS,YAAY,UAAU;AACrD,MAAI,MAAM,GAAG,OAAO,UAAU,EAAE,OAAO,QAAQ;AAC/C,MAAI,WAAW,QAAQ,QAAQ,IAAI,GAAG;AACtC,MAAI,CAAC,UAAU;AACX,YAAQ,QAAQ,IAAI,KAAM,WACtB,QAAQ,eAAe,cAAc,QAAQ,aAAa,WACtD,UACE,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,YAAwB,SAAmB,CAAC,CAAE;AAAA,EAC9F;AACA,SAAO;AACX;AACA,IAAI;AAAA;AAAA,EAA6B,WAAY;AACzC,aAASC,aAAY,OAAO,QAAQ,WAAW;AAC3C,WAAK,QAAQ;AACb,WAAK,SAAS;AACd,WAAK,YAAY;AAAA,IACrB;AACA,IAAAA,aAAY,UAAU,eAAe,SAAU,OAAOC,KAAI;AACtD,UAAI,QAAQ;AACZ,UAAI,QAAQA,IAAG,OAAOC,UAASD,IAAG,QAAQ,SAASA,IAAG,QAAQ,YAAYA,IAAG,WAAW,YAAYA,IAAG;AACvG,UAAI,sBAAsB,uBAAuB,KAAK;AACtD,UAAI,SAAS,0BAA0B;AACvC,kBAAY,SAAS,SAAS,CAAC,GAAG,iBAAiB,mBAAmB,CAAC,GAAG,SAAS;AACnF,UAAI,UAAU,SAAS,SAAS,EAAE,OAAc,SAAS,uBAAO,OAAO,IAAI,GAAG,OAAO,SAAU,UAAU,UAAU;AAC3G,eAAO,OAAO,MAAM,UAAU,QAAQ;AAAA,MAC1C,GAAG,WAAsB,WAAW,mBAAmB,SAAS,EAAE,GAAG,uBAAuB,OAAO,KAAK,SAAS,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC,WAAW,cAAc,oBAAI,IAAI,GAAG,YAAY,OAAO,UAAU,OAAO,SAAS,oBAAI,IAAI,EAAE,CAAC;AACpO,UAAI,MAAM,KAAK,oBAAoB;AAAA,QAC/B,QAAQC,WAAU,uBAAO,OAAO,IAAI;AAAA,QACpC;AAAA,QACA,cAAc,oBAAoB;AAAA,QAClC,WAAW,EAAE,KAAK,oBAAI,IAAI,EAAE;AAAA,QAC5B;AAAA,MACJ,CAAC;AACD,UAAI,CAAC,YAAY,GAAG,GAAG;AACnB,cAAM,kBAAkB,IAAIA,OAAM;AAAA,MACtC;AAGA,cAAQ,aAAa,QAAQ,SAAUD,KAAIE,SAAQ;AAC/C,YAAI,cAAcF,IAAG,aAAa,YAAYA,IAAG,WAAW,eAAeA,IAAG;AAC9E,YAAI,YAAY,cAAcE,OAAM;AACpC,YAAI,aAAa,UAAU,IAAI,MAAM;AACjC,cAAI,UAAU,MAAM,YAAY,WAAW,WAAW,aAAa,OAAO;AAC1E,cAAI,YAAY,OAAO,GAAG;AAItB;AAAA,UACJ;AAGA,wBAAc;AAAA,QAClB;AACA,YAAI,WAAW,YAAY,SAAS,CAAC,QAAQ,WAAW;AACpD,cAAI,4BAA4B,uBAAO,OAAO,IAAI;AAClD,uBAAa,QAAQ,SAAU,OAAO;AAClC,gBAAI,MAAM,cAAc;AACpB,wCAA0B,MAAM,KAAK,KAAK,IAAI;AAAA,YAClD;AAAA,UACJ,CAAC;AACD,cAAI,oBAAoB,SAAU,gBAAgB;AAC9C,mBAAO,0BAA0B,uBAAuB,cAAc,CAAC,MACnE;AAAA,UACR;AACA,cAAI,qBAAqB,SAAU,gBAAgB;AAC/C,gBAAI,YAAY,aAAa,UAAU,IAAI,IAAI,cAAc;AAC7D,mBAAO,QAAQ,aAAa,UAAU,QAAQ,UAAU,KAAK,KAAK;AAAA,UACtE;AACA,iBAAO,KAAK,WAAW,EAAE,QAAQ,SAAU,gBAAgB;AAKvD,gBAAI,kBAAkB,cAAc,KAChC,CAAC,mBAAmB,cAAc,GAAG;AACrC,gCAAkB,WAAW,aAAa,gBAAgB,QAAQ,KAAK;AAAA,YAC3E;AAAA,UACJ,CAAC;AAAA,QACL;AACA,cAAM,MAAMA,SAAQ,WAAW;AAAA,MACnC,CAAC;AAMD,YAAM,OAAO,IAAI,KAAK;AACtB,aAAO;AAAA,IACX;AACA,IAAAH,aAAY,UAAU,sBAAsB,SAAUC,KAAI;AACtD,UAAI,QAAQ;AACZ,UAAI,SAASA,IAAG,QAAQC,UAASD,IAAG,QAAQ,eAAeA,IAAG,cAAc,UAAUA,IAAG,SAGzF,YAAYA,IAAG;AACf,UAAI,WAAW,KAAK,MAAM;AAG1B,UAAI,WAAW,uBAAO,OAAO,IAAI;AAIjC,UAAI,WAAY,UAAU,SAAS,kBAAkB,MAAM,KACvD,sBAAsBC,SAAQ,cAAc,QAAQ,WAAW,KAC9D,UAAU,QAAQ,MAAM,IAAI,QAAQ,YAAY;AACrD,UAAI,aAAa,OAAO,UAAU;AAC9B,iBAAS,aAAa;AAAA,MAC1B;AASA,UAAI,YAAY,WAAY;AACxB,YAAI,UAAU,0BAA0B,WAAW,UAAU,QAAQ,SAAS;AAC9E,YAAI,YAAY,QAAQ,IAAI,GAAG;AAC3B,cAAI,OAAO,QAAQ,aAAa,IAAI,QAAQ,KAAK,KAAK;AACtD,cAAI,MAAM;AACN,gBAAI,WAAW,SAAS,UAAU,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,MAAM,KAAK,YAAY,CAAC,GAAG,OAAO;AACtG,gBAAI,aAAa,QAAQ;AACrB,qBAAO;AAAA,YACX;AAAA,UACJ;AAAA,QACJ;AACA,eAAO,SAAS,UAAU,SAAS,OAAO;AAAA,MAC9C;AACA,UAAI,eAAe,oBAAI,IAAI;AAC3B,WAAK;AAAA,QAAc;AAAA,QAAcA;AAAA;AAAA;AAAA;AAAA,QAIjC;AAAA,QAAS;AAAA,MAAQ,EAAE,QAAQ,SAAUE,UAAS,OAAO;AACjD,YAAIH;AACJ,YAAI,iBAAiB,uBAAuB,KAAK;AACjD,YAAI,QAAQC,QAAO,cAAc;AACjC,qBAAa,IAAI,KAAK;AACtB,YAAI,UAAU,QAAQ;AAClB,cAAI,iBAAiB,SAAS,kBAAkB;AAAA,YAC5C;AAAA,YACA,WAAW,MAAM,KAAK;AAAA,YACtB;AAAA,YACA,WAAWE,SAAQ;AAAA,UACvB,CAAC;AACD,cAAI,YAAY,kBAAkB,WAAW,cAAc;AAC3D,cAAI,gBAAgB,MAAM;AAAA,YAAkB;AAAA,YAAO;AAAA;AAAA;AAAA,YAGnD,MAAM,eACF,iBAAiBA,UAAS,OAAO,KAAK,IACpCA;AAAA,YAAS;AAAA,UAAS;AAIxB,cAAI,gBAAgB;AAGpB,cAAI,MAAM,iBACL,YAAY,aAAa,KAAK,wBAAwB,aAAa,IAAI;AACxE,4BAAgB,UAAU,cAAc,aAAa;AAAA,UACzD;AACA,cAAI,QAAQ,SAAS,iBAAiB,UAAU,MAAM,KAAK,OAAO,aAAa;AAC/E,cAAI,OAAO;AACP,sBAAU,OAAO;AAAA;AAAA,cAEb;AAAA,cACA;AAAA,cACA;AAAA,YACJ;AAAA,UACJ,OACK;AACD,uCAA2B,WAAW,cAAc;AAAA,UACxD;AACA,qBAAWA,SAAQ,MAAM,WAAWH,MAAK,CAAC,GACtCA,IAAG,cAAc,IAAI,eACrBA,IAAG;AAAA,QACX,WACS,WAAW,YAAY,SAC5B,CAACG,SAAQ,cACT,CAACA,SAAQ,YACT,CAAC,sBAAsB,MAAM,KAAK;AAAA;AAAA;AAAA,QAIlC,CAAC,SAAS,gBAAgB,UAAU,MAAM,KAAK,KAAK,GAAG;AACvD,qBAAW,YAAY,SAASC,WAAU,MAAM,IAAI,uBAAuB,KAAK,GAAGH,OAAM;AAAA,QAC7F;AAAA,MACJ,CAAC;AAGD,UAAI;AACA,YAAI,KAAK,SAAS,SAASA,SAAQ;AAAA,UAC/B;AAAA,UACA;AAAA,UACA,aAAa,QAAQ;AAAA,UACrB,aAAa;AAAA,UACb;AAAA,QACJ,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG,YAAY,GAAG,CAAC;AAGhC,iBAAS,UAAU;AAGnB,YAAI,WAAW;AAEX,qBAAW,QAAQ,MAAM,UAAU,SAAS;AAAA,QAChD;AAAA,MACJ,SACO,GAAG;AAEN,YAAI,CAAC;AACD,gBAAM;AAAA,MACd;AACA,UAAI,aAAa,OAAO,QAAQ;AAC5B,YAAI,UAAU,cAAc,MAAM;AAMlC,YAAI,OAAO,QAAQ,QAAQ,MAAM,MAAM,QAAQ,QAAQ,MAAM,IAAI,CAAC;AAClE,YAAI,KAAK,QAAQ,YAAY,KAAK;AAC9B,iBAAO;AACX,aAAK,KAAK,YAAY;AAMtB,YAAI,KAAK,UACL,KAAK,OAAO,QAAQA,SAAQ,SAAS,cAAc,OAAO,GAAG;AAC7D,iBAAO;AAAA,QACX;AACA,YAAI,aAAa,QAAQ,aAAa,IAAI,MAAM;AAChD,YAAI,YAAY;AACZ,qBAAW,cAAc,QAAQ,MAAM,WAAW,aAAa,QAAQ;AACvE,qBAAW,YAAY,gBAAgB,WAAW,WAAW,SAAS;AACtE,uBAAa,QAAQ,SAAU,OAAO;AAAE,mBAAO,WAAW,aAAa,IAAI,KAAK;AAAA,UAAG,CAAC;AAAA,QACxF,OACK;AACD,kBAAQ,aAAa,IAAI,QAAQ;AAAA,YAC7B,aAAa;AAAA;AAAA;AAAA;AAAA,YAIb,WAAW,iBAAiB,SAAS,IAAI,SAAS;AAAA,YAClD;AAAA,UACJ,CAAC;AAAA,QACL;AACA,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX;AACA,IAAAF,aAAY,UAAU,oBAAoB,SAAU,OAAO,OAAO,SAAS,WAAW;AAClF,UAAI,QAAQ;AACZ,UAAI,CAAC,MAAM,gBAAgB,UAAU,MAAM;AAIvC,eAAO,WAAW,YAAY,QAAQ,UAAU,KAAK,IAAI;AAAA,MAC7D;AACA,UAAI,QAAQ,KAAK,GAAG;AAChB,eAAO,MAAM,IAAI,SAAU,MAAM,GAAG;AAChC,cAAIM,SAAQ,MAAM,kBAAkB,MAAM,OAAO,SAAS,kBAAkB,WAAW,CAAC,CAAC;AACzF,qCAA2B,WAAW,CAAC;AACvC,iBAAOA;AAAA,QACX,CAAC;AAAA,MACL;AACA,aAAO,KAAK,oBAAoB;AAAA,QAC5B,QAAQ;AAAA,QACR,cAAc,MAAM;AAAA,QACpB;AAAA,QACA;AAAA,MACJ,CAAC;AAAA,IACL;AAGA,IAAAN,aAAY,UAAU,gBAAgB,SAAU,cAAcE,SAAQ,SAAS,UAAU;AACrF,UAAI,aAAa,QAAQ;AAAE,mBAAW,sBAAsBA,SAAQ,cAAc,QAAQ,WAAW;AAAA,MAAG;AACxG,UAAI,WAAW,oBAAI,IAAI;AACvB,UAAI,WAAW,KAAK,MAAM;AAC1B,UAAI,eAAe,IAAI,KAAK,KAAK;AACjC,OAAC,SAAS,QAAQK,eAAc,kBAAkB;AAC9C,YAAI,cAAc,aAAa;AAAA,UAAOA;AAAA;AAAA;AAAA;AAAA;AAAA,UAKtC,iBAAiB;AAAA,UAAY,iBAAiB;AAAA,QAAQ;AACtD,YAAI,YAAY;AACZ;AACJ,oBAAY,UAAU;AACtB,QAAAA,cAAa,WAAW,QAAQ,SAAU,WAAW;AACjD,cAAI,CAAC,cAAc,WAAW,QAAQ,SAAS;AAC3C;AACJ,cAAI,aAAa,iBAAiB,YAAY,WAAW,iBAAiB;AAC1E;AAAA;AAAA;AAAA;AAAA,YAIA,EAAE,cAAc,aACZ,gBAAgB,UAAU,UAAU;AAAA,YAAG;AACvC,sBAAU,WAAW,QAAQ,SAAU,KAAK;AACxC,kBAAI,OAAO,IAAI,KAAK;AACpB,kBAAI,SAAS;AACT,6BAAa;AACjB,kBAAI,SAAS,SAAS;AAClB,oBAAI,OAAO,yBAAyB,KAAK,QAAQ,SAAS;AAK1D,oBAAI,CAAC,QAAQ,KAAK,OAAO,OAAO;AAC5B,6BAAW;AAAA,gBACf;AAAA,cAGJ;AAAA,YACJ,CAAC;AAAA,UACL;AACA,cAAI,QAAQ,SAAS,GAAG;AACpB,gBAAI,WAAW,SAAS,IAAI,SAAS;AACrC,gBAAI,UAAU;AAIV,2BAAa,cAAc,SAAS;AACpC,yBAAW,YAAY,SAAS;AAAA,YACpC;AACA,qBAAS,IAAI,WAAW,iBAAiB,SAAS,YAAY,QAAQ,CAAC;AAAA,UAC3E,OACK;AACD,gBAAI,WAAW,yBAAyB,WAAW,QAAQ,cAAc;AACzE,gBAAI,CAAC,YAAY,UAAU,SAAS,KAAK,iBAAiB;AACtD,oBAAM,kBAAkB,IAAI,UAAU,KAAK,KAAK;AAAA,YACpD;AACA,gBAAI,YACA,SAAS,gBAAgB,UAAU,UAAUL,SAAQ,QAAQ,SAAS,GAAG;AACzE,sBAAQ,SAAS,cAAc,iBAAiB,SAAS,YAAY,QAAQ,CAAC;AAAA,YAClF;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL,GAAG,cAAc,OAAO;AACxB,aAAO;AAAA,IACX;AACA,IAAAF,aAAY,UAAU,cAAc,SAAU,WAAW,UAAU,UAAU,SAAS,gBAAgB;AAClG,UAAIC;AACJ,UAAI,QAAQ;AACZ,UAAI,UAAU,IAAI,QAAQ,CAAC,YAAY,QAAQ,GAAG;AAC9C,YAAI;AAAA;AAAA;AAAA;AAAA,UAIH,CAAC,QAAQ,QAAQ;AAAA;AAAA;AAAA,WAIb,YAAY,QAAQ,KAAK,wBAAwB,QAAQ,KAC1D,WACE;AAAA;AAIN,YAAI,MAAM;AAKV,YAAI,OAAO,CAAC,gBAAgB;AACxB,2BAAiB,CAAC,YAAY,GAAG,IAAI,IAAI,QAAQ,GAAG;AAAA,QACxD;AAMA,YAAI;AACJ,YAAI,aAAa,SAAUO,OAAM,MAAM;AACnC,iBAAQ,QAAQA,KAAI,IAChB,OAAO,SAAS,WACZA,MAAK,IAAI,IACP,SACJ,QAAQ,MAAM,cAAcA,OAAM,OAAO,IAAI,CAAC;AAAA,QACxD;AACA,kBAAU,IAAI,QAAQ,SAAU,WAAW,gBAAgB;AACvD,cAAI,OAAO,WAAW,KAAK,cAAc;AACzC,cAAI,OAAO,WAAW,KAAK,cAAc;AAEzC,cAAI,WAAW;AACX;AACJ,cAAI,gBAAgB;AAChB,2BAAe,KAAK,cAAc;AAAA,UACtC;AACA,cAAI,OAAO,MAAM,YAAY,WAAW,MAAM,MAAM,SAAS,cAAc;AAC3E,cAAI,SAAS,MAAM;AACf,8BAAkB,mBAAmB,oBAAI,IAAI;AAC7C,4BAAgB,IAAI,gBAAgB,IAAI;AAAA,UAC5C;AACA,cAAI,gBAAgB;AAChB,YAAAH,WAAU,eAAe,IAAI,MAAM,cAAc;AAAA,UACrD;AAAA,QACJ,CAAC;AACD,YAAI,iBAAiB;AAEjB,qBAAY,QAAQ,GAAG,IAAI,IAAI,MAAM,CAAC,IAAI,SAAS,CAAC,GAAG,GAAG;AAC1D,0BAAgB,QAAQ,SAAU,OAAO,MAAM;AAC3C,qBAAS,IAAI,IAAI;AAAA,UACrB,CAAC;AAAA,QACL;AAAA,MACJ;AACA,UAAI,UAAU,MAAM;AAChB,eAAO,KAAK,MAAM,SAAS,iBAAiB,UAAU,UAAU,UAAU,MAAM,SAAS,mBAAmBJ,MAAK,QAAQ,OAAO,WAAW,MAAMA,KAAI,cAAc,CAAC;AAAA,MACxK;AACA,aAAO;AAAA,IACX;AACA,WAAOD;AAAA,EACX,EAAE;AAAA;AAEF,IAAI,qBAAqB,CAAC;AAC1B,SAAS,kBAAkBS,KAAI,MAAM;AACjC,MAAI,MAAMA,IAAG;AACb,MAAI,CAAC,IAAI,IAAI,IAAI,GAAG;AAChB,QAAI,IAAI,MAAM,mBAAmB,IAAI,KAAK,EAAE,KAAK,oBAAI,IAAI,EAAE,CAAC;AAAA,EAChE;AACA,SAAO,IAAI,IAAI,IAAI;AACvB;AACA,SAAS,gBAAgB,MAAM,OAAO;AAClC,MAAI,SAAS,SAAS,CAAC,SAAS,iBAAiB,KAAK;AAClD,WAAO;AACX,MAAI,CAAC,QAAQ,iBAAiB,IAAI;AAC9B,WAAO;AACX,MAAI,OAAO,KAAK,QAAQ,MAAM,OAAO,SAAS,SAAS,CAAC,GAAG,KAAK,IAAI,GAAG,MAAM,IAAI,IAAI,KAAK,QAAQ,MAAM;AACxG,MAAI,kBAAkB,KAAK,IAAI,QAAQ,MAAM,IAAI;AACjD,MAAI,MAAM,kBAAkB,oBAAI,IAAI,IAC9B,KAAK,IAAI,OAAO,KAAK,MACjB,MAAM;AAChB,MAAI,SAAS,EAAE,MAAY,IAAS;AACpC,MAAI,iBAAiB;AACjB,QAAI,uBAAuB,IAAI,IAAI,MAAM,IAAI,KAAK,CAAC;AACnD,SAAK,IAAI,QAAQ,SAAU,UAAU,KAAK;AACtC,aAAO,IAAI,IAAI,KAAK,gBAAgB,UAAU,MAAM,IAAI,IAAI,GAAG,CAAC,CAAC;AACjE,2BAAqB,OAAO,GAAG;AAAA,IACnC,CAAC;AACD,yBAAqB,QAAQ,SAAU,KAAK;AACxC,aAAO,IAAI,IAAI,KAAK,gBAAgB,MAAM,IAAI,IAAI,GAAG,GAAG,KAAK,IAAI,IAAI,GAAG,CAAC,CAAC;AAAA,IAC9E,CAAC;AAAA,EACL;AACA,SAAO;AACX;AACA,SAAS,iBAAiB,MAAM;AAC5B,SAAO,CAAC,QAAQ,EAAE,KAAK,QAAQ,KAAK,IAAI;AAC5C;AACA,SAAS,2BAA2BA,KAAI,MAAM;AAC1C,MAAI,MAAMA,IAAG;AACb,MAAI,YAAY,IAAI,IAAI,IAAI;AAC5B,MAAI,aAAa,iBAAiB,SAAS,GAAG;AAC1C,uBAAmB,KAAK,SAAS;AACjC,QAAI,OAAO,IAAI;AAAA,EACnB;AACJ;AACA,IAAI,WAAW,oBAAI,IAAI;AAGvB,SAAS,kBAAkB,aAAa,aAAa,gBAAgB,OAAO;AACxE,MAAI,WAAW,SAAU,UAAU;AAC/B,QAAI,QAAQ,MAAM,cAAc,UAAU,cAAc;AACxD,WAAO,OAAO,UAAU,YAAY;AAAA,EACxC;AACA,MAAI,WAAW,SAAS,WAAW;AACnC,MAAI,CAAC;AACD;AACJ,MAAI,WAAW,SAAS,WAAW;AACnC,MAAI,CAAC;AACD;AAGJ,MAAI,YAAY,QAAQ;AACpB;AAGJ,MAAI,MAAM,UAAU,QAAQ;AACxB;AAIJ,MAAI,OAAO,KAAK,QAAQ,EAAE,MAAM,SAAU,KAAK;AAAE,WAAO,MAAM,cAAc,UAAU,GAAG,MAAM;AAAA,EAAQ,CAAC,GAAG;AACvG;AAAA,EACJ;AACA,MAAI,aAAa,MAAM,cAAc,aAAa,YAAY,KAC1D,MAAM,cAAc,aAAa,YAAY;AACjD,MAAI,YAAY,uBAAuB,cAAc;AACrD,MAAI,cAAc,GAAG,OAAO,YAAY,GAAG,EAAE,OAAO,SAAS;AAE7D,MAAI,SAAS,IAAI,WAAW;AACxB;AACJ,WAAS,IAAI,WAAW;AACxB,MAAI,iBAAiB,CAAC;AAGtB,MAAI,CAAC,QAAQ,QAAQ,KAAK,CAAC,QAAQ,QAAQ,GAAG;AAC1C,KAAC,UAAU,QAAQ,EAAE,QAAQ,SAAU,OAAO;AAC1C,UAAI,WAAW,MAAM,cAAc,OAAO,YAAY;AACtD,UAAI,OAAO,aAAa,YAAY,CAAC,eAAe,SAAS,QAAQ,GAAG;AACpE,uBAAe,KAAK,QAAQ;AAAA,MAChC;AAAA,IACJ,CAAC;AAAA,EACL;AACA,aAAW,YAAY,SAASC,WAAU,KAAK,IAAI,WAAW,YAAY,eAAe,SACrF,uCACI,eAAe,KAAK,OAAO,IAC3B,gDACF,IAAI,aAAa,UAAU,QAAQ;AAC7C;;;AChgBA,IAAI;AAAA;AAAA,EAA+B,SAAU,QAAQ;AACjD,cAAUC,gBAAe,MAAM;AAC/B,aAASA,eAAc,QAAQ;AAC3B,UAAI,WAAW,QAAQ;AAAE,iBAAS,CAAC;AAAA,MAAG;AACtC,UAAI,QAAQ,OAAO,KAAK,IAAI,KAAK;AACjC,YAAM,UAAU,oBAAI,IAAI;AACxB,YAAM,uBAAuB,IAAI,kBAAkB,qBAAqB;AAGxE,YAAM,yBAAyB;AAC/B,YAAM,UAAU;AAChB,YAAM,UAAU;AAChB,YAAM,SAAS,gBAAgB,MAAM;AACrC,YAAM,cAAc,CAAC,CAAC,MAAM,OAAO;AACnC,YAAM,WAAW,IAAI,SAAS;AAAA,QAC1B,OAAO;AAAA,QACP,kBAAkB,MAAM,OAAO;AAAA,QAC/B,eAAe,MAAM,OAAO;AAAA,QAC5B,cAAc,MAAM,OAAO;AAAA,MAC/B,CAAC;AACD,YAAM,KAAK;AACX,aAAO;AAAA,IACX;AACA,IAAAA,eAAc,UAAU,OAAO,WAAY;AAIvC,UAAI,YAAa,KAAK,OAAO,IAAI,YAAY,KAAK;AAAA,QAC9C,UAAU,KAAK;AAAA,QACf,eAAe,KAAK,OAAO;AAAA,MAC/B,CAAC;AAMD,WAAK,iBAAiB,UAAU;AAChC,WAAK,iBAAiB;AAAA,IAC1B;AACA,IAAAA,eAAc,UAAU,mBAAmB,SAAU,uBAAuB;AACxE,UAAI,QAAQ;AACZ,UAAI,iBAAiB,KAAK;AAC1B,UAAI,YAAY,KAAK,OAAO;AAI5B,WAAK,cAAc,IAAI,YAAY,MAAO,KAAK,cAAc,IAAI,YAAY;AAAA,QACzE,OAAO;AAAA,QACP,aAAa,KAAK;AAAA,QAClB,oBAAoB,KAAK,OAAO;AAAA,QAChC,iBAAiB,sBAAsB,KAAK,MAAM;AAAA,QAClD,OAAO,wBAAwB,SAAU,kBAAkB,eAAe;AAAA,QAC1E;AAAA,MACJ,CAAC,GAAI,SAAS;AACd,WAAK,sBAAsBC,MAAK,SAAU,GAAG,SAAS;AAClD,eAAO,MAAM,eAAe,GAAG,OAAO;AAAA,MAC1C,GAAG;AAAA,QACC,KAAK,KAAK,OAAO;AAAA,QACjB,cAAc,SAAU,GAAG;AAGvB,cAAI,QAAQ,EAAE,aAAa,MAAM,iBAAiB,MAAM;AACxD,cAAI,sBAAsB,KAAK,GAAG;AAC9B,gBAAI,aAAa,EAAE,YAAY,KAAK,EAAE,IAAI,YAAY,EAAE;AACxD,mBAAO,MAAM;AAAA,cAAa,EAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAO5B,EAAE;AAAA,cAAU,mBAAmB,EAAE,YAAwB,IAAQ,UAAqB,CAAC;AAAA,YAAC;AAAA,UAC5F;AAAA,QACJ;AAAA,MACJ,CAAC;AAID,2BAAI,IAAI,CAAC,KAAK,KAAK,OAAO,KAAK,eAAe,KAAK,CAAC,GAAE,QAAQ,SAAU,OAAO;AAC3E,eAAO,MAAM,aAAa;AAAA,MAC9B,CAAC;AAAA,IACL;AACA,IAAAD,eAAc,UAAU,UAAU,SAAU,MAAM;AAC9C,WAAK,KAAK;AAIV,UAAI;AACA,aAAK,KAAK,QAAQ,IAAI;AAC1B,aAAO;AAAA,IACX;AACA,IAAAA,eAAc,UAAU,UAAU,SAAU,YAAY;AACpD,UAAI,eAAe,QAAQ;AAAE,qBAAa;AAAA,MAAO;AACjD,cAAQ,aAAa,KAAK,iBAAiB,KAAK,MAAM,QAAQ;AAAA,IAClE;AACA,IAAAA,eAAc,UAAU,OAAO,SAAU,SAAS;AAC9C,UAQAE,MAAK,QAAQ,mBAQb,oBAAoBA,QAAO,SAAS,QAAQA;AAC5C,UAAI;AACA,eAAQ,KAAK,YAAY,sBAAsB,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,OAAO,QAAQ,aAAa,KAAK,iBAAiB,KAAK,MAAM,QAAQ,KAAK,QAAQ,kBAAqC,CAAC,CAAC,EAAE,UAAU;AAAA,MAC1N,SACO,GAAG;AACN,YAAI,aAAa,mBAAmB;AAMhC,iBAAO;AAAA,QACX;AACA,cAAM;AAAA,MACV;AAAA,IACJ;AACA,IAAAF,eAAc,UAAU,QAAQ,SAAU,SAAS;AAC/C,UAAI;AACA,UAAE,KAAK;AACP,eAAO,KAAK,YAAY,aAAa,KAAK,MAAM,OAAO;AAAA,MAC3D,UACA;AACI,YAAI,CAAC,EAAE,KAAK,WAAW,QAAQ,cAAc,OAAO;AAChD,eAAK,iBAAiB;AAAA,QAC1B;AAAA,MACJ;AAAA,IACJ;AACA,IAAAA,eAAc,UAAU,SAAS,SAAU,SAAS;AAChD,UAAI,OAAO,KAAK,SAAS,IAAI,KAAK,CAAC,QAAQ,IAAI;AAU3C,eAAO;AAAA,MACX;AACA,UAAI,QAAU,QAAQ,aAElB,KAAK,iBACH,KAAK;AACX,UAAI;AACA,UAAE,KAAK;AACP,eAAO,MAAM,OAAO,QAAQ,MAAM,cAAc,QAAQ,MAAM;AAAA,MAClE,UACA;AACI,YAAI,CAAC,EAAE,KAAK,WAAW,QAAQ,cAAc,OAAO;AAChD,eAAK,iBAAiB;AAAA,QAC1B;AAAA,MACJ;AAAA,IACJ;AACA,IAAAA,eAAc,UAAU,OAAO,SAAU,SAAS;AAC9C,aAAO,KAAK,YAAY,sBAAsB,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,OAAO,QAAQ,aAAa,KAAK,iBAAiB,KAAK,MAAM,QAAQ,QAAQ,MAAM,cAAc,QAAQ,KAAK,OAAO,CAAC,CAAC;AAAA,IAC3M;AACA,IAAAA,eAAc,UAAU,QAAQ,SAAU,OAAO;AAC7C,UAAI,QAAQ;AACZ,UAAI,CAAC,KAAK,QAAQ,MAAM;AAWpB,oBAAY,IAAI;AAAA,MACpB;AACA,WAAK,QAAQ,IAAI,KAAK;AACtB,UAAI,MAAM,WAAW;AACjB,aAAK,oBAAoB,KAAK;AAAA,MAClC;AACA,aAAO,WAAY;AAIf,YAAI,MAAM,QAAQ,OAAO,KAAK,KAAK,CAAC,MAAM,QAAQ,MAAM;AACpD,sBAAY,KAAK;AAAA,QACrB;AAIA,cAAM,oBAAoB,OAAO,KAAK;AAAA,MAC1C;AAAA,IACJ;AACA,IAAAA,eAAc,UAAU,KAAK,SAAU,SAAS;AAC5C,yBAAmB,MAAM;AACzB,UAAI,MAAM,KAAK,eAAe,GAAG;AACjC,UAAI,WAAW,CAAC,KAAK,SAAS;AAC1B,YAAI,QAAQ,kBAAkB;AAC1B,eAAK,iBAAiB,QAAQ,qBAAqB;AAAA,QACvD,WACS,QAAQ,uBAAuB;AACpC,eAAK,YAAY,WAAW;AAAA,QAChC;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAQA,IAAAA,eAAc,UAAU,SAAS,SAAU,QAAQ,YAAY;AAC3D,cAAQ,aAAa,KAAK,iBAAiB,KAAK,MAAM,OAAO,MAAM;AAAA,IACvE;AAMA,IAAAA,eAAc,UAAU,UAAU,SAAU,QAAQ,YAAY;AAC5D,cAAQ,aAAa,KAAK,iBAAiB,KAAK,MAAM,QAAQ,MAAM;AAAA,IACxE;AAOA,IAAAA,eAAc,UAAU,WAAW,SAAU,QAAQ;AACjD,UAAI,YAAY,MAAM;AAClB,eAAO,OAAO;AAClB,UAAI;AACA,eAAO,KAAK,SAAS,SAAS,MAAM,EAAE,CAAC;AAAA,MAC3C,SACO,GAAG;AACN,mBAAW,YAAY,SAASG,WAAU,KAAK,CAAC;AAAA,MACpD;AAAA,IACJ;AACA,IAAAH,eAAc,UAAU,QAAQ,SAAU,SAAS;AAC/C,UAAI,CAAC,QAAQ,IAAI;AACb,YAAI,OAAO,KAAK,SAAS,IAAI,GAAG;AAG5B,iBAAO;AAAA,QACX;AACA,kBAAU,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,IAAI,aAAa,CAAC;AAAA,MAClE;AACA,UAAI;AAKA,UAAE,KAAK;AAIP,eAAO,KAAK,eAAe,MAAM,SAAS,KAAK,IAAI;AAAA,MACvD,UACA;AACI,YAAI,CAAC,EAAE,KAAK,WAAW,QAAQ,cAAc,OAAO;AAChD,eAAK,iBAAiB;AAAA,QAC1B;AAAA,MACJ;AAAA,IACJ;AACA,IAAAA,eAAc,UAAU,QAAQ,SAAU,SAAS;AAC/C,UAAI,QAAQ;AACZ,WAAK,KAAK;AACV,yBAAmB,MAAM;AACzB,UAAI,WAAW,QAAQ,gBAAgB;AAGnC,aAAK,QAAQ,QAAQ,SAAU,OAAO;AAAE,iBAAO,MAAM,oBAAoB,OAAO,KAAK;AAAA,QAAG,CAAC;AACzF,aAAK,QAAQ,MAAM;AACnB,oBAAY,IAAI;AAAA,MACpB,OACK;AAOD,aAAK,iBAAiB;AAAA,MAC1B;AACA,aAAO,QAAQ,QAAQ;AAAA,IAC3B;AACA,IAAAA,eAAc,UAAU,mBAAmB,SAAU,YAAY;AAC7D,UAAI,oBAAoB,KAAK,eAAe,YAAY,UAAU;AAClE,UAAI,sBAAsB,KAAK,gBAAgB;AAC3C,aAAK,iBAAiB;AACtB,aAAK,iBAAiB;AAAA,MAC1B;AAAA,IACJ;AACA,IAAAA,eAAc,UAAU,QAAQ,SAAU,SAAS;AAC/C,UAAI,QAAQ;AACZ,UAAI,SAAS,QAAQ,QAAQE,MAAK,QAAQ,YAAY,aAAaA,QAAO,SAAS,OAAOA,KAAI,mBAAmB,QAAQ,kBAAkB,iBAAiB,QAAQ;AACpK,UAAI;AACJ,UAAI,UAAU,SAAU,OAAO;AAC3B,YAAIA,MAAK,OAAO,OAAOA,IAAG,MAAM,iBAAiBA,IAAG;AACpD,UAAE,MAAM;AACR,YAAI,OAAO;AACP,gBAAM,OAAO,MAAM,iBAAiB;AAAA,QACxC;AACA,YAAI;AACA,iBAAQ,eAAe,OAAO,KAAK;AAAA,QACvC,UACA;AACI,YAAE,MAAM;AACR,gBAAM,OAAO;AACb,gBAAM,iBAAiB;AAAA,QAC3B;AAAA,MACJ;AACA,UAAI,eAAe,oBAAI,IAAI;AAC3B,UAAI,kBAAkB,CAAC,KAAK,SAAS;AAUjC,aAAK,iBAAiB,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,gBAAgB,SAAU,OAAO;AACjF,uBAAa,IAAI,KAAK;AACtB,iBAAO;AAAA,QACX,EAAE,CAAC,CAAC;AAAA,MACZ;AACA,UAAI,OAAO,eAAe,UAAU;AAIhC,aAAK,iBAAiB,KAAK,eAAe,SAAS,YAAY,OAAO;AAAA,MAC1E,WACS,eAAe,OAAO;AAM3B,gBAAQ,KAAK,IAAI;AAAA,MACrB,OACK;AAGD,gBAAQ;AAAA,MACZ;AACA,UAAI,OAAO,qBAAqB,UAAU;AACtC,aAAK,iBAAiB,KAAK,eAAe,YAAY,gBAAgB;AAAA,MAC1E;AAIA,UAAI,kBAAkB,aAAa,MAAM;AACrC,aAAK,iBAAiB,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,gBAAgB,SAAU,OAAO,MAAM;AACvF,cAAIE,UAAS,eAAe,KAAK,MAAM,OAAO,IAAI;AAClD,cAAIA,YAAW,OAAO;AAIlB,yBAAa,OAAO,KAAK;AAAA,UAC7B;AACA,iBAAOA;AAAA,QACX,EAAE,CAAC,CAAC;AAGR,YAAI,aAAa,MAAM;AACnB,uBAAa,QAAQ,SAAU,OAAO;AAAE,mBAAO,MAAM,oBAAoB,MAAM,KAAK;AAAA,UAAG,CAAC;AAAA,QAC5F;AAAA,MACJ,OACK;AAID,aAAK,iBAAiB,OAAO;AAAA,MACjC;AACA,aAAO;AAAA,IACX;AACA,IAAAJ,eAAc,UAAU,qBAAqB,SAAU,QAAQ,cAAc;AACzE,aAAO,KAAK,MAAM;AAAA,QACd;AAAA,QACA,YAAY,gBAAgB,iBAAiB;AAAA,MACjD,CAAC;AAAA,IACL;AACA,IAAAA,eAAc,UAAU,oBAAoB,SAAU,UAAU;AAC5D,aAAO,KAAK,sBAAsB,KAAK,uBAAuB,QAAQ,CAAC;AAAA,IAC3E;AACA,IAAAA,eAAc,UAAU,mBAAmB,SAAU,SAAS;AAC1D,UAAI,QAAQ;AACZ,UAAI,CAAC,KAAK,SAAS;AACf,aAAK,QAAQ,QAAQ,SAAU,GAAG;AAAE,iBAAO,MAAM,oBAAoB,GAAG,OAAO;AAAA,QAAG,CAAC;AAAA,MACvF;AAAA,IACJ;AACA,IAAAA,eAAc,UAAU,yBAAyB,SAAU,UAAU;AACjE,UAAI,YAAY,KAAK,OAAO;AAC5B,aAAO,YAAY,UAAU,UAAU,QAAQ,IAAI;AAAA,IACvD;AACA,IAAAA,eAAc,UAAU,wBAAwB,SAAU,UAAU;AAChE,UAAI,KAAK,aAAa;AAClB,eAAO,KAAK,qBAAqB,kBAAkB,QAAQ;AAAA,MAC/D;AACA,aAAO;AAAA,IACX;AAOA,IAAAA,eAAc,UAAU,iBAAiB,SAAU,GAAG,SAAS;AAC3D,UAAI,WAAW,EAAE;AAOjB,UAAI,OAAO,KAAK,KAAK,CAAC;AACtB,UAAI,SAAS;AACT,YAAI,EAAE,cAAc,OAAO,QAAQ,eAAe,UAAU;AACxD,eAAK,4BAA4B;AAAA,QACrC;AACA,YAAI,QAAQ,kBACR,QAAQ,eAAe,KAAK,MAAM,GAAG,MAAM,QAAQ,MAAM,OAAO;AAGhE;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,CAAC,YAAY,CAAC,MAAM,SAAS,QAAQ,KAAK,MAAM,GAAG;AACnD,UAAE,SAAU,EAAE,WAAW,MAAO,QAAQ;AAAA,MAC5C;AAAA,IACJ;AACA,WAAOA;AAAA,EACX,EAAE,WAAW;AAAA;;;AC3bb,IAAI;AAAA;AAAA,EAAkC,WAAY;AAI9C,aAASK,oBAAmB;AACxB,UAAI,YAAY,CAAC;AACjB,eAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,kBAAU,EAAE,IAAI,UAAU,EAAE;AAAA,MAChC;AACA,WAAK,WAAW,uBAAO,OAAO,IAAI;AAClC,WAAK,YAAY;AACjB,UAAI,UAAU,QAAQ;AAClB,aAAK,SAAS,MAAM,MAAM,SAAS;AAAA,MACvC;AAAA,IACJ;AACA,IAAAA,kBAAiB,UAAU,WAAW,WAAY;AAC9C,UAAI,QAAQ;AACZ,UAAI,YAAY,CAAC;AACjB,eAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,kBAAU,EAAE,IAAI,UAAU,EAAE;AAAA,MAChC;AACA,UAAI,cAAc,oBAAI,IAAI;AAC1B,gBAAU,QAAQ,SAAU,KAAK;AAC7B,+BAAuB,GAAG,EAAE,QAAQ,SAAU,MAAM;AAChD,sBAAY,IAAI,KAAK,KAAK,OAAO,IAAI;AAAA,QACzC,CAAC;AAAA,MACL,CAAC;AACD,kBAAY,QAAQ,SAAU,MAAM,MAAM;AACtC,YAAI,SAAS,MAAM,SAAS,IAAI,GAAG;AAC/B,gBAAM,SAAS,IAAI,IAAI;AACvB,gBAAM,WAAW,IAAI;AAAA,QACzB;AAAA,MACJ,CAAC;AACD,aAAO;AAAA,IACX;AAEA,IAAAA,kBAAiB,UAAU,aAAa,SAAU,MAAM;AAAA,IAAE;AAC1D,IAAAA,kBAAiB,UAAU,cAAc,WAAY;AACjD,WAAK,cAAc,KAAK,SAAS,KAAK,iBAAiB,KAAK,MAAM,GAAG;AACrE,WAAK,YAAY,KAAK,iBAAiB,KAAK,SAAS;AACrD,WAAK,sBAAsB,KAAK,iBAAiB,KAAK,mBAAmB;AAAA,IAC7E;AACA,IAAAA,kBAAiB,UAAU,mBAAmB,SAAU,gBAAgB;AACpE,aAAOC,MAAK,eAAe,KAAK,IAAI,GAAG;AAAA,QACnC,cAAc,SAAU,KAAK;AAAE,iBAAO;AAAA,QAAK;AAAA,MAC/C,CAAC;AAAA,IACL;AACA,IAAAD,kBAAiB,UAAU,SAAS,SAAU,cAAc;AACxD,aAAO,KAAK,SAAS,YAAY,KAAK;AAAA,IAC1C;AACA,IAAAA,kBAAiB,UAAU,YAAY,SAAU,UAAU;AACvD,UAAI,QAAQ;AACZ,UAAI,UAAU,oBAAI,IAAI;AACtB,6BAAuB,QAAQ,EAAE,QAAQ,SAAU,KAAK;AACpD,gBAAQ,IAAI,IAAI,KAAK,OAAO,GAAG;AAAA,MACnC,CAAC;AACD,UAAI,UAAU,oBAAI,IAAI;AACtB,UAAIE,WAAU,SAAU,YAAY;AAChC,YAAI,CAAC,QAAQ,IAAI,UAAU,GAAG;AAC1B,kBAAQ,IAAI,UAAU;AAAA,QAC1B;AAAA,MACJ;AACA,UAAI,sBAAsB,SAAU,MAAM;AACtC,eAAO,OAAO,KAAK,MAAM,oBAAoB,IAAI,CAAC,EAAE,QAAQA,QAAO;AAAA,MACvE;AACA,0BAAoB,QAAQ;AAC5B,UAAI,UAAU,CAAC;AACf,UAAI,MAAM,uBAAO,OAAO,IAAI;AAG5B,cAAQ,QAAQ,SAAU,cAAc;AACpC,YAAI,mBAAmB,QAAQ,IAAI,YAAY;AAC/C,YAAI,kBAAkB;AAClB,8BAAqB,IAAI,YAAY,IAAI,gBAAiB;AAAA,QAC9D,OACK;AACD,kBAAQ,KAAK,YAAY;AACzB,cAAI,MAAM,MAAM,OAAO,YAAY;AACnC,cAAI,KAAK;AACL,gCAAqB,IAAI,YAAY,IAAI,GAAI;AAAA,UACjD;AAAA,QACJ;AAAA,MACJ,CAAC;AACD,UAAI,QAAQ,QAAQ;AAChB,YAAI,iBAAiB,CAAC;AACtB,gBAAQ,QAAQ,SAAU,MAAM;AAC5B,cAAI,MAAM,IAAI,IAAI;AAClB,cAAI,KAAK;AACL,2BAAe,KAAK,GAAG;AAAA,UAC3B;AAAA,QACJ,CAAC;AACD,YAAI,eAAe,QAAQ;AACvB,qBAAW,SAAS,SAAS,CAAC,GAAG,QAAQ,GAAG,EAAE,aAAa,SAAS,YAAY,OAAO,cAAc,EAAE,CAAC;AAAA,QAC5G;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACA,IAAAF,kBAAiB,UAAU,sBAAsB,SAAUG,OAAM;AAC7D,UAAI,UAAU,uBAAO,OAAO,IAAI;AAChC,YAAMA,OAAM;AAAA,QACR,gBAAgB,SAAU,MAAM;AAC5B,kBAAQ,KAAK,KAAK,KAAK,IAAI;AAAA,QAC/B;AAAA,MACJ,CAAC;AACD,aAAO;AAAA,IACX;AACA,WAAOH;AAAA,EACX,EAAE;AAAA;;;ACzHK,IAAI;AAAA,CACV,SAAUI,gBAAe;AAMtB,EAAAA,eAAcA,eAAc,SAAS,IAAI,CAAC,IAAI;AAK9C,EAAAA,eAAcA,eAAc,cAAc,IAAI,CAAC,IAAI;AAKnD,EAAAA,eAAcA,eAAc,WAAW,IAAI,CAAC,IAAI;AAKhD,EAAAA,eAAcA,eAAc,SAAS,IAAI,CAAC,IAAI;AAM9C,EAAAA,eAAcA,eAAc,MAAM,IAAI,CAAC,IAAI;AAI3C,EAAAA,eAAcA,eAAc,OAAO,IAAI,CAAC,IAAI;AAI5C,EAAAA,eAAcA,eAAc,OAAO,IAAI,CAAC,IAAI;AAChD,GAAG,kBAAkB,gBAAgB,CAAC,EAAE;AAKjC,SAAS,yBAAyB,eAAe;AACpD,SAAO,gBAAgB,gBAAgB,IAAI;AAC/C;AAKO,SAAS,wBAAwB,eAAe;AACnD,SAAO,kBAAkB,KAAK,kBAAkB;AACpD;;;ACjDO,SAAS,aAAa,OAAOC,KAAI,IAAI,WAAW;AACnD,MAAI,QAAQA,IAAG,MAAM,QAAQ,OAAOA,KAAI,CAAC,MAAM,CAAC;AAChD,MAAI,QAAQ,GAAG,MAAM,QAAQ,OAAO,IAAI,CAAC,MAAM,CAAC;AAChD,SAAQ,YAAM,OAAO,KAAK,KACtB,oBAAoB,kBAAkB,KAAK,EAAE,cAAc,OAAO,OAAO;AAAA,IACrE,aAAa,kBAAkB,uBAAuB,KAAK,CAAC;AAAA,IAC5D;AAAA,EACJ,CAAC;AACT;AACA,SAAS,oBAAoB,cAAc,SAAS,SAAS,SAAS;AAClE,MAAI,YAAY,SAAS;AACrB,WAAO;AAAA,EACX;AACA,MAAI,iBAAiB,oBAAI,IAAI;AAI7B,SAAO,aAAa,WAAW,MAAM,SAAU,WAAW;AAGtD,QAAI,eAAe,IAAI,SAAS;AAC5B,aAAO;AACX,mBAAe,IAAI,SAAS;AAE5B,QAAI,CAAC,cAAc,WAAW,QAAQ,SAAS;AAC3C,aAAO;AAGX,QAAI,iCAAiC,SAAS;AAC1C,aAAO;AACX,QAAI,QAAQ,SAAS,GAAG;AACpB,UAAI,YAAY,uBAAuB,SAAS;AAChD,UAAI,eAAe,WAAW,QAAQ,SAAS;AAC/C,UAAI,eAAe,WAAW,QAAQ,SAAS;AAC/C,UAAI,oBAAoB,UAAU;AAClC,UAAI,CAAC,mBAAmB;AAGpB,eAAO,YAAM,cAAc,YAAY;AAAA,MAC3C;AACA,UAAI,gBAAgB,MAAM,QAAQ,YAAY;AAC9C,UAAI,gBAAgB,MAAM,QAAQ,YAAY;AAC9C,UAAI,kBAAkB;AAClB,eAAO;AACX,UAAI,iBAAiB,eAAe;AAChC,YAAI,WAAW,aAAa;AAC5B,YAAI,aAAa,WAAW,UAAU;AAClC,iBAAO;AAAA,QACX;AACA,iBAAS,IAAI,GAAG,IAAI,UAAU,EAAE,GAAG;AAC/B,cAAI,CAAC,oBAAoB,mBAAmB,aAAa,CAAC,GAAG,aAAa,CAAC,GAAG,OAAO,GAAG;AACpF,mBAAO;AAAA,UACX;AAAA,QACJ;AACA,eAAO;AAAA,MACX;AACA,aAAO,oBAAoB,mBAAmB,cAAc,cAAc,OAAO;AAAA,IACrF,OACK;AACD,UAAI,WAAW,yBAAyB,WAAW,QAAQ,WAAW;AACtE,UAAI,UAAU;AAGV,YAAI,iCAAiC,QAAQ;AACzC,iBAAO;AACX,eAAO;AAAA,UAAoB,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA,UAKpC;AAAA,UAAS;AAAA,UAAS;AAAA,QAAO;AAAA,MAC7B;AAAA,IACJ;AAAA,EACJ,CAAC;AACL;AACA,SAAS,iCAAiC,WAAW;AACjD,SAAQ,CAAC,CAAC,UAAU,cAAc,UAAU,WAAW,KAAK,sBAAsB;AACtF;AACA,SAAS,uBAAuB,KAAK;AACjC,SAAO,IAAI,KAAK,UAAU;AAC9B;;;AC/EA,IAAI,SAAS,OAAO;AAApB,IAA4BC,kBAAiB,OAAO;AACpD,IAAI;AAAA;AAAA,EAAiC,SAAU,QAAQ;AACnD,cAAUC,kBAAiB,MAAM;AACjC,aAASA,iBAAgBC,KAAI;AACzB,UAAI,eAAeA,IAAG,cAAc,YAAYA,IAAG,WAAW,UAAUA,IAAG;AAC3E,UAAI,QAAQ,OAAO,KAAK,MAAM,SAAU,UAAU;AAG9C,YAAI;AACA,cAAI,cAAc,SAAS,cAAc;AACzC,cAAI,eAAe,CAAC,YAAY,OAAO;AACnC,wBAAY,QAAQ;AAAA,UACxB;AAAA,QACJ,SACOA,KAAI;AAAA,QAAE;AACb,YAAI,QAAQ,CAAC,MAAM,UAAU;AAC7B,cAAM,UAAU,IAAI,QAAQ;AAE5B,YAAI,OAAO,MAAM;AACjB,YAAI,QAAQ,KAAK,OAAO;AACpB,mBAAS,SAAS,SAAS,MAAM,KAAK,KAAK;AAAA,QAC/C,WACS,QAAQ,KAAK,QAAQ;AAC1B,mBAAS,QAAQ,SAAS,KAAK,KAAK,MAAM;AAAA,QAC9C;AAGA,YAAI,OAAO;AAKP,gBAAM,UAAU,EAAE,MAAM,WAAY;AAAA,UAAE,CAAC;AAAA,QAC3C;AACA,eAAO,WAAY;AACf,cAAI,MAAM,UAAU,OAAO,QAAQ,KAAK,CAAC,MAAM,UAAU,MAAM;AAC3D,kBAAM,cAAc;AAAA,UACxB;AAAA,QACJ;AAAA,MACJ,CAAC,KAAK;AACN,YAAM,YAAY,oBAAI,IAAI;AAC1B,YAAM,gBAAgB,oBAAI,IAAI;AAE9B,YAAM,YAAY;AAClB,YAAM,eAAe;AAErB,YAAM,mBAAmB,iBAAiB,QAAQ,WAAW;AAC7D,YAAM,aAAa;AACnB,UAAI,KAAK,aAAa,eAAe,YAAY,KAAK,OAAO,SAAS,CAAC,IAAI,IAAI,KAAK,GAAG,aAAa,qBAAqB,OAAO,SAAS,gBAAgB;AACzJ,UAAI,KAAK,QAAQ,aAAa,cAAc,OAAO,SAAS,qBAAqB,IAEjF,KAAK,QAAQ,oBAEb,qBAAqB,OAAO,SAAS,gBAAgB,YAAY,qBAAsB,cAAe;AACtG,YAAM,UAAU,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG;AAAA;AAAA;AAAA;AAAA,QAI5C;AAAA;AAAA;AAAA,QAGA;AAAA,MAAyB,CAAC;AAC9B,YAAM,UAAU,UAAU,WAAW,aAAa,gBAAgB;AAClE,UAAI,QAAQ,uBAAuB,MAAM,KAAK;AAC9C,YAAM,YAAY,SAAS,MAAM,QAAQ,MAAM,KAAK;AACpD,aAAO;AAAA,IACX;AACA,WAAO,eAAeD,iBAAgB,WAAW,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA,MAKtD,KAAK,WAAY;AACb,eAAO,KAAK,aAAa,KAAK,QAAQ;AAAA,MAC1C;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,IAClB,CAAC;AACD,WAAO,eAAeA,iBAAgB,WAAW,aAAa;AAAA;AAAA;AAAA,MAG1D,KAAK,WAAY;AACb,eAAO,KAAK,QAAQ;AAAA,MACxB;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,IAClB,CAAC;AACD,IAAAA,iBAAgB,UAAU,SAAS,WAAY;AAC3C,UAAI,QAAQ;AACZ,aAAO,IAAI,QAAQ,SAAU,SAAS,QAAQ;AAI1C,YAAI,WAAW;AAAA,UACX,MAAM,SAAUE,SAAQ;AACpB,oBAAQA,OAAM;AAWd,kBAAM,UAAU,OAAO,QAAQ;AAC/B,gBAAI,CAAC,MAAM,UAAU,MAAM;AACvB,oBAAM,aAAa,YAAY,MAAM,OAAO;AAAA,YAChD;AACA,uBAAW,WAAY;AACnB,2BAAa,YAAY;AAAA,YAC7B,GAAG,CAAC;AAAA,UACR;AAAA,UACA,OAAO;AAAA,QACX;AACA,YAAI,eAAe,MAAM,UAAU,QAAQ;AAAA,MAC/C,CAAC;AAAA,IACL;AACA,IAAAF,iBAAgB,UAAU,mBAAmB,SAAU,kBAAkB;AACrE,UAAI,qBAAqB,QAAQ;AAAE,2BAAmB;AAAA,MAAM;AAE5D,UAAI,aAAa,KAAK,cAAc,IAAI;AACxC,UAAI,gBAAgB,KAAK,UAAU,iBAC9B,cAAc,WAAW,iBAC1B,cAAc;AAClB,UAAIE,UAAS,SAAS,SAAS,CAAC,GAAG,UAAU,GAAG,EAAE,SAAS,yBAAyB,aAAa,GAAG,cAA6B,CAAC;AAClI,UAAID,MAAK,KAAK,QAAQ,aAAa,cAAcA,QAAO,SAAS,gBAAgBA;AACjF;AAAA;AAAA;AAAA,QAGA,iBAAiB,WAAW;AAAA;AAAA;AAAA;AAAA,QAKxB,KAAK,aAAa,gBAAgB,KAAK,KAAK,EAAE;AAAA,QAAoB;AAAA,MAEtE,WACS,KAAK,kBAAkB;AAI5B,aAAK,UAAU,aAAa,EAAE;AAAA,MAClC,OACK;AACD,YAAI,OAAO,KAAK,UAAU,QAAQ;AAClC,YAAI,KAAK,YAAY,KAAK,QAAQ,mBAAmB;AACjD,UAAAC,QAAO,OAAO,KAAK;AAAA,QACvB;AACA,YAAI,MAAMA,QAAO,MAAM,CAAC,CAAC,GAAG;AACxB,UAAAA,QAAO,OAAO;AAAA,QAClB;AACA,YAAI,KAAK,UAAU;AAGf,iBAAOA,QAAO;AAId,cAAI,KAAK,YACLA,QAAO,kBAAkB,cAAc,YACtC,gBAAgB,iBAAiB,gBAAgB,eAAe;AACjE,YAAAA,QAAO,gBAAgB,cAAc;AACrC,YAAAA,QAAO,UAAU;AAAA,UACrB;AAAA,QACJ,OACK;AACD,UAAAA,QAAO,UAAU;AAAA,QACrB;AACA,YAAI,WAAW,YAAY,SACvB,CAAC,KAAK,YACN,CAAC,KAAK,QAAQ,kBACd,CAACA,QAAO,WACR,CAACA,QAAO,QACR,CAACA,QAAO,OAAO;AACf,gCAAsB,KAAK,OAAO;AAAA,QACtC;AAAA,MACJ;AACA,UAAI,kBAAkB;AAClB,aAAK,iBAAiBA,OAAM;AAAA,MAChC;AACA,aAAOA;AAAA,IACX;AAGA,IAAAF,iBAAgB,UAAU,4BAA4B,SAAU,WAAW,WAAW;AAClF,UAAI,CAAC,KAAK,MAAM;AACZ,eAAO;AAAA,MACX;AACA,UAAI,oBAAoB,KAAK,aAAa,gBAAgB,KAAK,KAAK,EAAE,0BAClE,CAAC,aAAa,KAAK,OAAO,KAAK,KAAK,QAAQ,WAAW,KAAK,SAAS,IACnE,CAAC,MAAM,KAAK,KAAK,QAAQ,SAAS;AACxC,aAAQ,qBAAsB,aAAa,CAAC,MAAM,KAAK,KAAK,WAAW,SAAS;AAAA,IACpF;AACA,IAAAA,iBAAgB,UAAU,UAAU,SAAU,KAAK,oBAAoB;AACnE,UAAI,OAAO,KAAK;AAChB,UAAI,QACA,KAAK,GAAG,MACP,CAAC,sBAAsB,MAAM,KAAK,WAAW,KAAK,SAAS,IAAI;AAChE,eAAO,KAAK,GAAG;AAAA,MACnB;AAAA,IACJ;AACA,IAAAA,iBAAgB,UAAU,gBAAgB,SAAU,oBAAoB;AACpE,aAAO,KAAK,QAAQ,UAAU,kBAAkB;AAAA,IACpD;AACA,IAAAA,iBAAgB,UAAU,eAAe,SAAU,oBAAoB;AACnE,aAAO,KAAK,QAAQ,SAAS,kBAAkB;AAAA,IACnD;AACA,IAAAA,iBAAgB,UAAU,mBAAmB,WAAY;AACrD,aAAO,KAAK;AACZ,WAAK,aAAa;AAAA,IACtB;AACA,IAAAA,iBAAgB,UAAU,wBAAwB,WAAY;AAC1D,WAAK,aAAa,YAAY,KAAK,OAAO;AAAA,IAC9C;AAQA,IAAAA,iBAAgB,UAAU,UAAU,SAAU,WAAW;AACrD,UAAIC;AACJ,UAAI,mBAAmB;AAAA;AAAA,QAEnB,cAAc;AAAA,MAClB;AAIA,UAAI,cAAc,KAAK,QAAQ;AAC/B,UAAI,gBAAgB,qBAAqB;AACrC,yBAAiB,cAAc;AAAA,MACnC,WACS,gBAAgB,YAAY;AACjC,yBAAiB,cAAc;AAAA,MACnC,OACK;AACD,yBAAiB,cAAc;AAAA,MACnC;AACA,UAAI,WAAW,YAAY,SAAS,aAAaF,gBAAe,KAAK,WAAW,WAAW,GAAG;AAC1F,YAAI,WAAW,mBAAmB,KAAK,KAAK;AAC5C,YAAI,OAAO,SAAS;AACpB,YAAI,CAAC,QAAQ,CAAC,KAAK,KAAK,SAAU,GAAG;AAAE,iBAAO,EAAE,SAAS,KAAK,UAAU;AAAA,QAAa,CAAC,GAAG;AACrF,qBAAW,YAAY,SAASI,WAAU;AAAA,YACtC;AAAA,YACA;AAAA,cACEF,MAAK,SAAS,UAAU,QAAQA,QAAO,SAAS,SAASA,IAAG,UAAU;AAAA,UAC5E;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,aAAa,CAAC,MAAM,KAAK,QAAQ,WAAW,SAAS,GAAG;AAExD,yBAAiB,YAAY,KAAK,QAAQ,YAAY,SAAS,SAAS,CAAC,GAAG,KAAK,QAAQ,SAAS,GAAG,SAAS;AAAA,MAClH;AACA,WAAK,UAAU,eAAe;AAC9B,aAAO,KAAK,UAAU,kBAAkB,cAAc,OAAO;AAAA,IACjE;AACA,IAAAD,iBAAgB,UAAU,YAAY,SAAU,kBAAkB;AAC9D,UAAI,QAAQ;AACZ,UAAI,kBAAkB,SAAS,SAAS,CAAC,GAAI,iBAAiB,QAAQ,mBAAoB,SAAS,SAAS,SAAS,SAAS,CAAC,GAAG,KAAK,OAAO,GAAG,EAAE,OAAO,KAAK,QAAQ,MAAM,CAAC,GAAG,gBAAgB,GAAG,EAAE,WAAW,SAAS,SAAS,CAAC,GAAG,KAAK,QAAQ,SAAS,GAAG,iBAAiB,SAAS,EAAE,CAAC,CAAG,GAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAM/R,aAAa;AAAA,MAAW,CAAC;AAC7B,sBAAgB,QAAQ,KAAK,kBAAkB,gBAAgB,KAAK;AACpE,UAAI,MAAM,KAAK,aAAa,gBAAgB;AAM5C,WAAK,YACD,iBAAiB,QACb,KAAK,kBAAkB,KAAK,QAAQ,KAAK,IACvC,gBAAgB;AAG1B,UAAI,YAAY,KAAK;AACrB,UAAI,wBAAwB,UAAU;AACtC,gBAAU,gBAAgB,cAAc;AACxC,UAAI,gBAAgB,6BAA6B;AAC7C,aAAK,QAAQ;AAAA,MACjB;AACA,UAAI,kBAAkB,oBAAI,IAAI;AAC9B,aAAO,KAAK,aACP,WAAW,KAAK,iBAAiB,cAAc,SAAS,EACxD,KAAK,SAAU,iBAAiB;AACjC,cAAM,aAAa,YAAY,GAAG;AAClC,YAAI,UAAU,kBAAkB,cAAc,WAAW;AACrD,oBAAU,gBAAgB;AAAA,QAC9B;AAMA,cAAM,aAAa,MAAM,MAAM;AAAA,UAC3B,QAAQ,SAAU,OAAO;AACrB,gBAAI,cAAc,iBAAiB;AACnC,gBAAI,aAAa;AACb,oBAAM,YAAY;AAAA,gBACd,OAAO,MAAM;AAAA,gBACb,WAAW,MAAM;AAAA,gBACjB,mBAAmB;AAAA,gBACnB,YAAY;AAAA,cAChB,GAAG,SAAU,UAAU;AACnB,uBAAO,YAAY,UAAU;AAAA,kBACzB,iBAAiB,gBAAgB;AAAA,kBACjC,WAAW,gBAAgB;AAAA,gBAC/B,CAAC;AAAA,cACL,CAAC;AAAA,YACL,OACK;AAMD,oBAAM,WAAW;AAAA,gBACb,OAAO,gBAAgB;AAAA,gBACvB,WAAW,gBAAgB;AAAA,gBAC3B,MAAM,gBAAgB;AAAA,cAC1B,CAAC;AAAA,YACL;AAAA,UACJ;AAAA,UACA,gBAAgB,SAAU,OAAO;AAG7B,4BAAgB,IAAI,MAAM,KAAK;AAAA,UACnC;AAAA,QACJ,CAAC;AACD,eAAO;AAAA,MACX,CAAC,EACI,QAAQ,WAAY;AAMrB,YAAI,CAAC,gBAAgB,IAAI,MAAM,KAAK,GAAG;AACnC,8BAAoB,KAAK;AAAA,QAC7B;AAAA,MACJ,CAAC;AAAA,IACL;AAIA,IAAAA,iBAAgB,UAAU,kBAAkB,SAAU,SAAS;AAC3D,UAAI,QAAQ;AACZ,UAAI,eAAe,KAAK,aACnB,yBAAyB;AAAA,QAC1B,OAAO,QAAQ;AAAA,QACf,WAAW,QAAQ;AAAA,QACnB,SAAS,QAAQ;AAAA,MACrB,CAAC,EACI,UAAU;AAAA,QACX,MAAM,SAAU,kBAAkB;AAC9B,cAAI,cAAc,QAAQ;AAC1B,cAAI,aAAa;AACb,kBAAM,YAAY,SAAU,UAAUC,KAAI;AACtC,kBAAI,YAAYA,IAAG;AACnB,qBAAO,YAAY,UAAU;AAAA,gBACzB;AAAA,gBACA;AAAA,cACJ,CAAC;AAAA,YACL,CAAC;AAAA,UACL;AAAA,QACJ;AAAA,QACA,OAAO,SAAU,KAAK;AAClB,cAAI,QAAQ,SAAS;AACjB,oBAAQ,QAAQ,GAAG;AACnB;AAAA,UACJ;AACA,qBAAW,YAAY,SAASE,WAAU,MAAM,IAAI,GAAG;AAAA,QAC3D;AAAA,MACJ,CAAC;AACD,WAAK,cAAc,IAAI,YAAY;AACnC,aAAO,WAAY;AACf,YAAI,MAAM,cAAc,OAAO,YAAY,GAAG;AAC1C,uBAAa,YAAY;AAAA,QAC7B;AAAA,MACJ;AAAA,IACJ;AACA,IAAAH,iBAAgB,UAAU,aAAa,SAAU,YAAY;AACzD,aAAO,KAAK,UAAU,UAAU;AAAA,IACpC;AACA,IAAAA,iBAAgB,UAAU,mBAAmB,SAAU,YAAY;AAC/D,UAAI,gBAAgB,QAAQ,KAAK,SAAS,cAAc,CAAC,CAAC;AAC1D,aAAO,KAAK,SAAS,aAAa;AAAA,IACtC;AAmBA,IAAAA,iBAAgB,UAAU,eAAe,SAAU,WAAW;AAC1D,UAAI,MAAM,KAAK,WAAW,SAAS,GAAG;AAIlC,eAAO,KAAK,UAAU,OAAO,KAAK,OAAO,IAAI,QAAQ,QAAQ;AAAA,MACjE;AACA,WAAK,QAAQ,YAAY;AAEzB,UAAI,CAAC,KAAK,UAAU,MAAM;AACtB,eAAO,QAAQ,QAAQ;AAAA,MAC3B;AACA,aAAO,KAAK,UAAU;AAAA;AAAA,QAElB,aAAa,KAAK,QAAQ;AAAA,QAC1B;AAAA,MACJ,GAAG,cAAc,YAAY;AAAA,IACjC;AACA,IAAAA,iBAAgB,UAAU,cAAc,SAAU,OAAO;AACrD,UAAI,eAAe,KAAK;AACxB,UAAIE,UAAS,aAAa,MAAM,KAAK;AAAA,QACjC,OAAO,KAAK,QAAQ;AAAA,QACpB,WAAW,KAAK;AAAA,QAChB,mBAAmB;AAAA,QACnB,YAAY;AAAA,MAChB,CAAC,EAAE;AACH,UAAI,YAAY,MAAMA,SAAQ;AAAA,QAC1B,WAAW,KAAK;AAAA,MACpB,CAAC;AACD,UAAI,WAAW;AACX,qBAAa,MAAM,WAAW;AAAA,UAC1B,OAAO,KAAK,QAAQ;AAAA,UACpB,MAAM;AAAA,UACN,WAAW,KAAK;AAAA,QACpB,CAAC;AACD,qBAAa,iBAAiB;AAAA,MAClC;AAAA,IACJ;AACA,IAAAF,iBAAgB,UAAU,eAAe,SAAU,cAAc;AAC7D,WAAK,QAAQ,eAAe;AAC5B,WAAK,cAAc;AAAA,IACvB;AACA,IAAAA,iBAAgB,UAAU,cAAc,WAAY;AAChD,WAAK,QAAQ,eAAe;AAC5B,WAAK,cAAc;AAAA,IACvB;AAEA,IAAAA,iBAAgB,UAAU,uBAAuB,SAAU,QAK3D,SAAS;AACL,UAAI,QAAQ,iBAAiB;AACzB,YAAIC,MAAK,QAAQ,aAAa,cAAcA,QAAO,SAAS,gBAAgBA,KAAI,KAAK,QAAQ,oBAAoB,qBAAqB,OAAO,SAAS,cAAc;AACpK,YAAI,gBAAgB,WAAW;AAAA,QAE/B,WACS,OAAO,QAAQ,oBAAoB,YAAY;AAWpD,kBAAQ,cAAc,QAAQ,gBAAgB,aAAa;AAAA,YACvD;AAAA,YACA;AAAA,YACA,YAAY;AAAA,YACZ;AAAA,UACJ,CAAC;AAAA,QACL,WACS,WAAW,qBAAqB;AACrC,kBAAQ,cAAc;AAAA,QAC1B,OACK;AACD,kBAAQ,cAAc,QAAQ;AAAA,QAClC;AAAA,MACJ;AACA,aAAO,QAAQ;AAAA,IACnB;AACA,IAAAD,iBAAgB,UAAU,QAAQ,SAAU,SAAS,kBAAkB,OAAO;AAG1E,WAAK,aAAa,mBAAmB,IAAI;AACzC,aAAO,KAAK,aAAa,sBAAsB,EAAE,KAAK,SAAS,SAAS,kBAAkB,KAAK;AAAA,IACnG;AAEA,IAAAA,iBAAgB,UAAU,gBAAgB,WAAY;AAClD,UAAI,QAAQ;AAEZ,UAAI,KAAK,aAAa,SAAS;AAC3B;AAAA,MACJ;AACA,UAAIC,MAAK,MAAM,cAAcA,IAAG,aAAa,eAAeA,IAAG,QAAQ;AACvE,UAAI,CAAC,cAAc;AACf,YAAI,aAAa;AACb,uBAAa,YAAY,OAAO;AAChC,iBAAO,KAAK;AAAA,QAChB;AACA;AAAA,MACJ;AACA,UAAI,eAAe,YAAY,aAAa,cAAc;AACtD;AAAA,MACJ;AACA,MAAAE,WAAU,cAAc,EAAE;AAC1B,UAAI,OAAO,gBAAgB,KAAK,cAAc,CAAC;AAC/C,WAAK,WAAW;AAChB,UAAI,aAAa,WAAY;AACzB,YAAI,MAAM,aAAa;AACnB,cAAI,CAAC,yBAAyB,MAAM,UAAU,aAAa,GAAG;AAC1D,kBAAM,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA,cAKZ,aAAa,MAAM,QAAQ,uBAAuB,aAC9C,aACE;AAAA,YACV,GAAG,cAAc,IAAI,EAAE,KAAK,MAAM,IAAI;AAAA,UAC1C,OACK;AACD,iBAAK;AAAA,UACT;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,OAAO,WAAY;AACnB,YAAIC,QAAO,MAAM;AACjB,YAAIA,OAAM;AACN,uBAAaA,MAAK,OAAO;AACzB,UAAAA,MAAK,UAAU,WAAW,YAAYA,MAAK,QAAQ;AAAA,QACvD;AAAA,MACJ;AACA,WAAK;AAAA,IACT;AACA,IAAAJ,iBAAgB,UAAU,mBAAmB,SAAU,WAAW,WAAW;AACzE,UAAI,cAAc,QAAQ;AAAE,oBAAY,KAAK;AAAA,MAAW;AACxD,UAAI,QAAQ,KAAK,aAAa;AAE9B,UAAI,SAAS,KAAK,QAAQ,CAAC,MAAM,WAAW,KAAK,KAAK,SAAS,GAAG;AAC9D,gBAAQ;AAAA,MACZ;AACA,aAAQ,KAAK,OAAO,SAAS,EAAE,QAAQ,KAAK,aAAa,yBACjD,YACE,UAAU,SAAS,GAAG,UAAqB,GAAI,QAAQ,EAAE,MAAa,IAAI,IAAK;AAAA,IAC7F;AACA,IAAAA,iBAAgB,UAAU,qBAAqB,SAAU,YAAY,kBAAkB;AACnF,UAAI,QAAQ;AACZ,WAAK,aAAa;AAClB,UAAI;AAAA;AAAA;AAAA;AAAA,QAIJ,qBAAqB,cAAc;AAAA;AAAA,QAG/B,qBAAqB,cAAc;AAAA;AAAA,QAGnC,qBAAqB,cAAc;AAAA;AAEvC,UAAI,eAAe,KAAK,QAAQ;AAChC,UAAI,iBAAiB,KAAK,QAAQ;AAClC,UAAI,gBAAgB,QAAQ,KAAK,SAAS,cAAc,CAAC,CAAC;AAC1D,UAAI,UAAU;AAAA;AAAA;AAAA,QAGV;AAAA,UACE,OAAO,KAAK,SAAS,aAAa;AAKxC,UAAI,QAAQ,KAAK,kBAAkB,QAAQ,KAAK;AAChD,WAAK,YAAY;AACjB,UAAI,CAAC,sBAAsB;AAEvB,aAAK,cAAc;AAGnB,YAAI,cACA,WAAW,aACX,CAAC,MAAM,WAAW,WAAW,YAAY;AAAA,QAEzC,QAAQ,gBAAgB;AAAA;AAAA,QAGxB,QAAQ,gBAAgB,gBAAgB;AACxC,eAAK,qBAAqB,qBAAqB,OAAO;AACtD,cAAI,qBAAqB,QAAQ;AAC7B,+BAAmB,cAAc;AAAA,UACrC;AAAA,QACJ;AAAA,MACJ;AACA,WAAK,qBAAqB,KAAK,mBAAmB,iBAAiB,QAAQ,WAAW;AACtF,UAAI,4BAA4B,WAAY;AACxC,YAAI,MAAM,YAAY,SAAS;AAC3B,gBAAM,mBAAmB;AAAA,QAC7B;AAAA,MACJ;AACA,UAAI,YAAY,QAAQ,aAAa,SAAS,CAAC,GAAG,QAAQ,SAAS;AACnE,UAAIC,MAAK,KAAK,MAAM,SAAS,kBAAkB,KAAK,GAAG,UAAUA,IAAG,SAAS,WAAWA,IAAG;AAC3F,UAAI,WAAW;AAAA,QACX,MAAM,SAAUC,SAAQ;AACpB,oCAA0B;AAC1B,gBAAM,aAAaA,SAAQ,SAAS;AAAA,QACxC;AAAA,QACA,OAAO,SAAU,OAAO;AACpB,oCAA0B;AAC1B,gBAAM,YAAY,OAAO,SAAS;AAAA,QACtC;AAAA,MACJ;AACA,UAAI,CAAC,yBAAyB,YAAY,CAAC,KAAK,UAAU;AAGtD,YAAI,KAAK,WAAW,KAAK,UAAU;AAC/B,eAAK,QAAQ,eAAe,KAAK,QAAQ;AAAA,QAC7C;AACA,aAAK,UAAU;AACf,aAAK,WAAW;AAAA,MACpB;AACA,cAAQ,YAAY,QAAQ;AAC5B,aAAO;AAAA,IACX;AACA,IAAAF,iBAAgB,UAAU,YAAY,SAAU,YAAY,kBAAkB;AAC1E,aAAO,KAAK,mBAAmB,YAAY,gBAAgB,EACtD;AAAA,IACT;AACA,IAAAA,iBAAgB,UAAU,wBAAwB,WAAY;AAC1D,UAAI,OAAO,CAAC;AACZ,eAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,aAAK,EAAE,IAAI,UAAU,EAAE;AAAA,MAC3B;AAOA,UAAI,OAAO,KAAK;AAChB,WAAK,iBAAiB;AACtB,UAAI,eAAe,KAAK,UAAU,MAAM,MAAM,IAAI;AAClD,WAAK,OAAO;AACZ,aAAO;AAAA,IACX;AAGA,IAAAA,iBAAgB,UAAU,UAAU,WAAY;AAC5C,WAAK;AAAA;AAAA;AAAA;AAAA;AAAA,QAKL,KAAK,iBAAiB,KAAK;AAAA,QAAG,KAAK;AAAA,MAAS;AAAA,IAChD;AACA,IAAAA,iBAAgB,UAAU,eAAe,SAAUE,SAAQ,WAAW;AAClE,UAAI,YAAY,KAAK,aAAa;AAClC,UAAI,cAAc,KAAK,0BAA0BA,SAAQ,SAAS;AAKlE,UAAI,aAAa,CAACA,QAAO,WAAW,KAAK,QAAQ,mBAAmB;AAChE,aAAK,iBAAiBA,SAAQ,SAAS;AAAA,MAC3C;AACA,UAAI,aAAa,aAAa;AAC1B,+BAAuB,KAAK,WAAW,QAAQA,OAAM;AAAA,MACzD;AAAA,IACJ;AACA,IAAAF,iBAAgB,UAAU,cAAc,SAAU,OAAO,WAAW;AAGhE,UAAI,cAAc,SAAS,SAAS,CAAC,GAAG,KAAK,cAAc,CAAC,GAAG,EAAE,OAAc,QAAQ,MAAM,eAAe,eAAe,cAAc,OAAO,SAAS,MAAM,CAAC;AAChK,WAAK,iBAAiB,aAAa,SAAS;AAC5C,6BAAuB,KAAK,WAAW,SAAU,KAAK,KAAK,QAAQ,KAAM;AAAA,IAC7E;AACA,IAAAA,iBAAgB,UAAU,eAAe,WAAY;AACjD,aAAO,KAAK,UAAU,OAAO;AAAA,IACjC;AACA,IAAAA,iBAAgB,UAAU,gBAAgB,WAAY;AAClD,UAAI,KAAK;AACL;AACJ,UAAI,KAAK,WAAW,KAAK,UAAU;AAC/B,aAAK,QAAQ,eAAe,KAAK,QAAQ;AACzC,eAAO,KAAK;AACZ,eAAO,KAAK;AAAA,MAChB;AACA,WAAK,YAAY;AAEjB,WAAK,cAAc,QAAQ,SAAU,KAAK;AAAE,eAAO,IAAI,YAAY;AAAA,MAAG,CAAC;AACvE,WAAK,cAAc,MAAM;AACzB,WAAK,aAAa,UAAU,KAAK,OAAO;AACxC,WAAK,UAAU,MAAM;AACrB,WAAK,aAAa;AAAA,IACtB;AACA,IAAAA,iBAAgB,UAAU,oBAAoB,SAAU,UAAU;AAC9D,aAAO,KAAK,aAAa,UAAU,QAAQ;AAAA,IAC/C;AACA,WAAOA;AAAA,EACX,EAAE,UAAU;AAAA;AAIZ,sBAAsB,eAAe;AAQ9B,SAAS,oBAAoB,UAAU;AAC1C,MAAIK,MAAK,SAAS,SAAS,cAAcA,IAAG,aAAa,kBAAkBA,IAAG;AAC9E,MAAI,gBAAgB,uBAAuB,gBAAgB,gBAAgB;AACvE,WAAO,SAAS,UAAU;AAAA,MACtB,aAAa;AAAA;AAAA;AAAA,MAGb,iBAAiB,SAAU,oBAAoB,SAAS;AAGpD,aAAK,kBAAkB;AAGvB,YAAI,OAAO,KAAK,oBAAoB,YAAY;AAC5C,iBAAO,KAAK,gBAAgB,oBAAoB,OAAO;AAAA,QAC3D;AAEA,eAAO;AAAA,MACX;AAAA,IACJ,CAAC;AAAA,EACL;AACA,SAAO,SAAS,UAAU;AAC9B;AACA,SAAS,yCAAyC,OAAO;AACrD,aAAW,YAAY,SAASC,WAAU,MAAM,IAAI,MAAM,SAAS,MAAM,KAAK;AAClF;AACO,SAAS,sBAAsB,SAAS;AAC3C,MAAI,WAAW,YAAY,SAAS,SAAS;AACzC,eAAW,YAAY,SAASA,WAAU,MAAM,IAAI,OAAO;AAAA,EAC/D;AACJ;AACA,SAAS,iBAAiB,aAA0D;AAChF,SAAQ,gBAAgB,kBACpB,gBAAgB,cAChB,gBAAgB;AACxB;;;AC5vBA,IAAI;AAAA;AAAA,EAA4B,WAAY;AACxC,aAASC,YAAWC,KAAI;AACpB,UAAI,QAAQA,IAAG,OAAO,SAASA,IAAG,QAAQ,YAAYA,IAAG,WAAW,kBAAkBA,IAAG;AACzF,WAAK,2BAA2B,oBAAI,QAAQ;AAC5C,WAAK,QAAQ;AACb,UAAI,QAAQ;AACR,aAAK,SAAS;AAAA,MAClB;AACA,UAAI,WAAW;AACX,aAAK,aAAa,SAAS;AAAA,MAC/B;AACA,UAAI,iBAAiB;AACjB,aAAK,mBAAmB,eAAe;AAAA,MAC3C;AAAA,IACJ;AACA,IAAAD,YAAW,UAAU,eAAe,SAAU,WAAW;AACrD,UAAI,QAAQ;AACZ,WAAK,YAAY,KAAK,aAAa,CAAC;AACpC,UAAI,MAAM,QAAQ,SAAS,GAAG;AAC1B,kBAAU,QAAQ,SAAU,eAAe;AACvC,gBAAM,YAAY,UAAU,MAAM,WAAW,aAAa;AAAA,QAC9D,CAAC;AAAA,MACL,OACK;AACD,aAAK,YAAY,UAAU,KAAK,WAAW,SAAS;AAAA,MACxD;AAAA,IACJ;AACA,IAAAA,YAAW,UAAU,eAAe,SAAU,WAAW;AACrD,WAAK,YAAY,CAAC;AAClB,WAAK,aAAa,SAAS;AAAA,IAC/B;AACA,IAAAA,YAAW,UAAU,eAAe,WAAY;AAC5C,aAAO,KAAK,aAAa,CAAC;AAAA,IAC9B;AAKA,IAAAA,YAAW,UAAU,eAAe,SAAUC,KAAI;AAC9C,UAAI,WAAWA,IAAG,UAAU,eAAeA,IAAG,cAAc,UAAUA,IAAG,SAAS,YAAYA,IAAG,WAAW,KAAKA,IAAG,wBAAwB,yBAAyB,OAAO,SAAS,QAAQ;AAC7L,aAAO,UAAU,MAAM,QAAQ,QAAQ,WAAY;AAC/C,eAAO,YAAY,MAAM,SAAU,IAAI;AACnC,cAAI,UAAU;AACV,mBAAO,CAAC,GAAc,KAAK,gBAAgB,UAAU,aAAa,MAAM,SAAS,WAAW,KAAK,iBAAiB,sBAAsB,EAAE,KAAK,SAAU,aAAa;AAAE,qBAAQ,SAAS,SAAS,CAAC,GAAG,YAAY,GAAG,EAAE,MAAM,YAAY,OAAO,CAAC;AAAA,YAAI,CAAC,CAAC;AAAA,UAC3P;AACA,iBAAO,CAAC,GAAc,YAAY;AAAA,QACtC,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AACA,IAAAD,YAAW,UAAU,qBAAqB,SAAU,iBAAiB;AACjE,WAAK,kBAAkB;AAAA,IAC3B;AACA,IAAAA,YAAW,UAAU,qBAAqB,WAAY;AAClD,aAAO,KAAK;AAAA,IAChB;AAGA,IAAAA,YAAW,UAAU,cAAc,SAAU,UAAU;AACnD,UAAI,cAAc,CAAC,QAAQ,GAAG,QAAQ,GAAG;AACrC,YAAI,KAAK,WAAW;AAChB,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAEA,IAAAA,YAAW,UAAU,cAAc,SAAU,UAAU;AACnD,aAAO,6BAA6B,QAAQ;AAAA,IAChD;AACA,IAAAA,YAAW,UAAU,iBAAiB,SAAU,SAAS;AACrD,UAAI,QAAQ,KAAK;AACjB,aAAO,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG;AAAA,QAAE;AAAA;AAAA,QAErC,aAAa,SAAU,KAAK;AACxB,iBAAO,MAAM,SAAS,GAAG;AAAA,QAC7B;AAAA,MAAE,CAAC;AAAA,IACX;AAIA,IAAAA,YAAW,UAAU,uBAAuB,SAAU,UAAU,WAAW,SAAS;AAChF,UAAI,cAAc,QAAQ;AAAE,oBAAY,CAAC;AAAA,MAAG;AAC5C,UAAI,YAAY,QAAQ;AAAE,kBAAU,CAAC;AAAA,MAAG;AACxC,aAAO,UAAU,MAAM,QAAQ,QAAQ,WAAY;AAC/C,eAAO,YAAY,MAAM,SAAUC,KAAI;AACnC,cAAI,UAAU;AACV,mBAAO,CAAC,GAAc,KAAK,gBAAgB,UAAU,KAAK,wBAAwB,UAAU,SAAS,KAAK,CAAC,GAAG,KAAK,eAAe,OAAO,GAAG,SAAS,EAAE,KAAK,SAAU,MAAM;AAAE,qBAAQ,SAAS,SAAS,CAAC,GAAG,SAAS,GAAG,KAAK,iBAAiB;AAAA,YAAI,CAAC,CAAC;AAAA,UACxP;AACA,iBAAO,CAAC,GAAc,SAAS,CAAC,GAAG,SAAS,CAAC;AAAA,QACjD,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AACA,IAAAD,YAAW,UAAU,uBAAuB,SAAU,UAAU;AAC5D,UAAI,iBAAiB;AACrB,YAAM,UAAU;AAAA,QACZ,WAAW;AAAA,UACP,OAAO,SAAU,MAAM;AACnB,gBAAI,KAAK,KAAK,UAAU,YAAY,KAAK,WAAW;AAChD,+BAAiB,KAAK,UAAU,KAAK,SAAU,KAAK;AAChD,uBAAO,IAAI,KAAK,UAAU,YACtB,IAAI,MAAM,SAAS,kBACnB,IAAI,MAAM,UAAU;AAAA,cAC5B,CAAC;AACD,kBAAI,gBAAgB;AAChB,uBAAO;AAAA,cACX;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ,CAAC;AACD,aAAO;AAAA,IACX;AAEA,IAAAA,YAAW,UAAU,0BAA0B,SAAU,UAAU,WAAW;AAC1E,aAAO,KAAK,MAAM,KAAK;AAAA,QACnB,OAAO,2BAA2B,QAAQ;AAAA,QAC1C;AAAA,QACA,mBAAmB;AAAA,QACnB,YAAY;AAAA,MAChB,CAAC,EAAE;AAAA,IACP;AACA,IAAAA,YAAW,UAAU,kBAAkB,SAAU,UAAU,WAAW,SAAS,WAAW,iBAAiB,wBAAwB;AAC/H,UAAI,YAAY,QAAQ;AAAE,kBAAU,CAAC;AAAA,MAAG;AACxC,UAAI,cAAc,QAAQ;AAAE,oBAAY,CAAC;AAAA,MAAG;AAC5C,UAAI,oBAAoB,QAAQ;AAAE,0BAAkB,WAAY;AAAE,iBAAO;AAAA,QAAM;AAAA,MAAG;AAClF,UAAI,2BAA2B,QAAQ;AAAE,iCAAyB;AAAA,MAAO;AACzE,aAAO,UAAU,MAAM,QAAQ,QAAQ,WAAY;AAC/C,YAAI,gBAAgB,WAAW,aAAa,qBAAqB,qBAAqB,sBAAsBC,KAAI,OAAO,QAAQ,aAAa;AAC5I,eAAO,YAAY,MAAM,SAAU,IAAI;AACnC,2BAAiB,kBAAkB,QAAQ;AAC3C,sBAAY,uBAAuB,QAAQ;AAC3C,wBAAc,kBAAkB,SAAS;AACzC,gCAAsB,KAAK,2BAA2B,gBAAgB,WAAW;AACjF,gCAAsB,eAAe;AACrC,iCAAuB,sBACnB,oBAAoB,OAAO,CAAC,EAAE,YAAY,IACtC,oBAAoB,MAAM,CAAC,IAC7B;AACN,UAAAA,MAAK,MAAM,QAAQA,IAAG,OAAO,SAASA,IAAG;AACzC,wBAAc;AAAA,YACV;AAAA,YACA,SAAS,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,OAAc,OAAe,CAAC;AAAA,YACzE;AAAA,YACA;AAAA,YACA;AAAA,YACA,mBAAmB,CAAC;AAAA,YACpB;AAAA,YACA;AAAA,UACJ;AACA,oCAA0B;AAC1B,iBAAO,CAAC,GAAc,KAAK,oBAAoB,eAAe,cAAc,yBAAyB,WAAW,WAAW,EAAE,KAAK,SAAUC,SAAQ;AAAE,mBAAQ;AAAA,cACtJ,QAAQA;AAAA,cACR,mBAAmB,YAAY;AAAA,YACnC;AAAA,UAAI,CAAC,CAAC;AAAA,QACd,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AACA,IAAAF,YAAW,UAAU,sBAAsB,SAAU,cAAc,yBAAyB,WAAW,aAAa;AAChH,aAAO,UAAU,MAAM,QAAQ,QAAQ,WAAY;AAC/C,YAAI,aAAa,SAAS,WAAW,gBAAgBG;AACrD,YAAI,QAAQ;AACZ,eAAO,YAAY,MAAM,SAAUF,KAAI;AACnC,wBAAc,YAAY,aAAa,UAAU,YAAY,SAAS,YAAY,YAAY;AAC9F,2BAAiB,CAAC,SAAS;AAC3B,UAAAE,WAAU,SAAU,WAAW;AAAE,mBAAO,UAAU,OAAO,QAAQ,QAAQ,WAAY;AACjF,kBAAI,UAAU;AACd,qBAAO,YAAY,MAAM,SAAUF,KAAI;AACnC,oBAAI,CAAC,2BACD,CAAC,YAAY,oBAAoB,IAAI,SAAS,GAAG;AAGjD,yBAAO;AAAA,oBAAC;AAAA;AAAA,kBAAY;AAAA,gBACxB;AACA,oBAAI,CAAC,cAAc,WAAW,SAAS,GAAG;AAEtC,yBAAO;AAAA,oBAAC;AAAA;AAAA,kBAAY;AAAA,gBACxB;AACA,oBAAI,QAAQ,SAAS,GAAG;AACpB,yBAAO,CAAC,GAAc,KAAK,aAAa,WAAW,yBAAyB,WAAW,WAAW,EAAE,KAAK,SAAU,aAAa;AACxH,wBAAIA;AACJ,wBAAI,OAAO,gBAAgB,aAAa;AACpC,qCAAe,MAAMA,MAAK,CAAC,GACvBA,IAAG,uBAAuB,SAAS,CAAC,IAAI,aACxCA,IAAG;AAAA,oBACX;AAAA,kBACJ,CAAC,CAAC;AAAA,gBACV;AACA,oBAAI,iBAAiB,SAAS,GAAG;AAC7B,6BAAW;AAAA,gBACf,OACK;AAED,6BAAW,YAAY,UAAU,KAAK,KAAK;AAC3C,kBAAAG,WAAU,UAAU,IAAI,UAAU,KAAK,KAAK;AAAA,gBAChD;AACA,oBAAI,YAAY,SAAS,eAAe;AACpC,kCAAgB,SAAS,cAAc,KAAK;AAC5C,sBAAI,YAAY,gBAAgB,WAAW,eAAe,OAAO,GAAG;AAChE,2BAAO,CAAC,GAAc,KAAK,oBAAoB,SAAS,cAAc,yBAAyB,WAAW,WAAW,EAAE,KAAK,SAAU,gBAAgB;AAC9I,qCAAe,KAAK,cAAc;AAAA,oBACtC,CAAC,CAAC;AAAA,kBACV;AAAA,gBACJ;AACA,uBAAO;AAAA,kBAAC;AAAA;AAAA,gBAAY;AAAA,cACxB,CAAC;AAAA,YACL,CAAC;AAAA,UAAG;AACJ,iBAAO,CAAC,GAAc,QAAQ,IAAI,aAAa,WAAW,IAAID,QAAO,CAAC,EAAE,KAAK,WAAY;AACjF,mBAAO,eAAe,cAAc;AAAA,UACxC,CAAC,CAAC;AAAA,QACV,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AACA,IAAAH,YAAW,UAAU,eAAe,SAAU,OAAO,yBAAyB,WAAW,aAAa;AAClG,aAAO,UAAU,MAAM,QAAQ,QAAQ,WAAY;AAC/C,YAAI,WAAW,WAAW,kBAAkB,WAAW,eAAe,eAAe,cAAc,aAAa;AAChH,YAAI,QAAQ;AACZ,eAAO,YAAY,MAAM,SAAUC,KAAI;AACnC,cAAI,CAAC,WAAW;AACZ,mBAAO,CAAC,GAAc,IAAI;AAAA,UAC9B;AACA,sBAAY,YAAY;AACxB,sBAAY,MAAM,KAAK;AACvB,6BAAmB,uBAAuB,KAAK;AAC/C,sBAAY,cAAc;AAC1B,0BAAgB,UAAU,gBAAgB,KAAK,UAAU,SAAS;AAClE,0BAAgB,QAAQ,QAAQ,aAAa;AAK7C,cAAI,CAAC,YAAY,0BACb,KAAK,qBAAqB,KAAK,GAAG;AAClC,2BAAe,UAAU,cAAc,YAAY;AACnD,0BAAc,KAAK,aAAa,KAAK,UAAU,YAAY;AAC3D,gBAAI,aAAa;AACb,wBAAU,YAAY,YAAY,YAAY,gBAAgB;AAC9D,kBAAI,SAAS;AACT,gCAAgB,QAAQ;AAAA;AAAA;AAAA,kBAGxB,UAAU,UAAU,KAAK,OAAO,SAAS;AAAA,oBACrC;AAAA,oBACA,yBAAyB,OAAO,SAAS;AAAA,oBACzC,YAAY;AAAA,oBACZ,EAAE,OAAc,aAAa,YAAY,YAAY;AAAA,kBACzD,CAAC;AAAA,gBAAC;AAAA,cACN;AAAA,YACJ;AAAA,UACJ;AACA,iBAAO,CAAC,GAAc,cAAc,KAAK,SAAUC,SAAQ;AACnD,gBAAID,KAAI;AACR,gBAAIC,YAAW,QAAQ;AAAE,cAAAA,UAAS;AAAA,YAAe;AAGjD,gBAAI,MAAM,YAAY;AAClB,oBAAM,WAAW,QAAQ,SAAU,WAAW;AAC1C,oBAAI,UAAU,KAAK,UAAU,YAAY,UAAU,WAAW;AAC1D,4BAAU,UAAU,QAAQ,SAAU,KAAK;AACvC,wBAAI,IAAI,KAAK,UAAU,QAAQ,IAAI,MAAM,SAAS,eAAe;AAC7D,kCAAY,kBAAkB,IAAI,MAAM,KAAK,IAAIA;AAAA,oBACrD;AAAA,kBACJ,CAAC;AAAA,gBACL;AAAA,cACJ,CAAC;AAAA,YACL;AAEA,gBAAI,CAAC,MAAM,cAAc;AACrB,qBAAOA;AAAA,YACX;AAGA,gBAAIA,WAAU,MAAM;AAEhB,qBAAOA;AAAA,YACX;AACA,gBAAI,iBAAiB,MAAMD,MAAK,MAAM,gBAAgB,QAAQA,QAAO,SAAS,SAASA,IAAG,KAAK,SAAU,GAAG;AAAE,qBAAO,EAAE,KAAK,UAAU;AAAA,YAAU,CAAC,OAAO,QAAQ,OAAO,SAAS,KAAK;AACrL,gBAAI,MAAM,QAAQC,OAAM,GAAG;AACvB,qBAAO,MAAM,wBAAwB,OAAO,2BAA2B,eAAeA,SAAQ,WAAW;AAAA,YAC7G;AAEA,gBAAI,MAAM,cAAc;AACpB,qBAAO,MAAM,oBAAoB,MAAM,cAAc,2BAA2B,eAAeA,SAAQ,WAAW;AAAA,YACtH;AAAA,UACJ,CAAC,CAAC;AAAA,QACV,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AACA,IAAAF,YAAW,UAAU,0BAA0B,SAAU,OAAO,yBAAyBE,SAAQ,aAAa;AAC1G,UAAI,QAAQ;AACZ,aAAO,QAAQ,IAAIA,QAAO,IAAI,SAAU,MAAM;AAC1C,YAAI,SAAS,MAAM;AACf,iBAAO;AAAA,QACX;AAEA,YAAI,MAAM,QAAQ,IAAI,GAAG;AACrB,iBAAO,MAAM,wBAAwB,OAAO,yBAAyB,MAAM,WAAW;AAAA,QAC1F;AAEA,YAAI,MAAM,cAAc;AACpB,iBAAO,MAAM,oBAAoB,MAAM,cAAc,yBAAyB,MAAM,WAAW;AAAA,QACnG;AAAA,MACJ,CAAC,CAAC;AAAA,IACN;AAIA,IAAAF,YAAW,UAAU,6BAA6B,SAAU,gBAAgB,aAAa;AACrF,UAAI,kBAAkB,SAAU,MAAM;AAAE,eAAO,CAAC,MAAM,QAAQ,IAAI;AAAA,MAAG;AACrE,UAAI,2BAA2B,KAAK;AACpC,eAAS,oBAAoB,gBAAgB;AACzC,YAAI,CAAC,yBAAyB,IAAI,cAAc,GAAG;AAC/C,cAAI,YAAY,oBAAI,IAAI;AACxB,mCAAyB,IAAI,gBAAgB,SAAS;AACtD,gBAAM,gBAAgB;AAAA,YAClB,WAAW,SAAU,MAAM,GAAG,IAAI,KAAK,WAAW;AAC9C,kBAAI,KAAK,KAAK,UAAU,UAAU;AAC9B,0BAAU,QAAQ,SAAUK,OAAM;AAC9B,sBAAI,gBAAgBA,KAAI,KAAK,gBAAgBA,KAAI,GAAG;AAChD,8BAAU,IAAIA,KAAI;AAAA,kBACtB;AAAA,gBACJ,CAAC;AAAA,cACL;AAAA,YACJ;AAAA,YACA,gBAAgB,SAAU,QAAQ,GAAG,IAAI,KAAK,WAAW;AACrD,kBAAI,WAAW,YAAY,OAAO,KAAK,KAAK;AAC5C,cAAAD,WAAU,UAAU,IAAI,OAAO,KAAK,KAAK;AACzC,kBAAI,qBAAqB,oBAAoB,QAAQ;AACrD,kBAAI,mBAAmB,OAAO,GAAG;AAG7B,0BAAU,QAAQ,SAAU,MAAM;AAC9B,sBAAI,gBAAgB,IAAI,KAAK,gBAAgB,IAAI,GAAG;AAChD,8BAAU,IAAI,IAAI;AAAA,kBACtB;AAAA,gBACJ,CAAC;AACD,0BAAU,IAAI,MAAM;AACpB,mCAAmB,QAAQ,SAAU,WAAW;AAC5C,4BAAU,IAAI,SAAS;AAAA,gBAC3B,CAAC;AAAA,cACL;AAAA,YACJ;AAAA,UACJ,CAAC;AAAA,QACL;AACA,eAAO,yBAAyB,IAAI,cAAc;AAAA,MACtD;AACA,aAAO,oBAAoB,cAAc;AAAA,IAC7C;AACA,WAAOJ;AAAA,EACX,EAAE;AAAA;;;AC1VF,IAAI,0BAA0B,KAAK,gBAAgB,UAAU,KAAK;AAClE,SAAS,2BAA2B,OAAO,YAAY;AACnD,MAAI,WAAW,MAAM,UAAU;AAC/B,MAAI,OAAO,aAAa,YAAY;AAChC,UAAM,UAAU,IAAI,WAAY;AAC5B,8BAAwB;AAAA,QAAI;AAAA;AAAA;AAAA;AAAA;AAAA,SAK3B,wBAAwB,IAAI,KAAK,IAAI,KAAK;AAAA,MAAI;AAE/C,aAAO,SAAS,MAAM,MAAM,SAAS;AAAA,IACzC;AAAA,EACJ;AACJ;AACA,SAAS,oBAAoB,MAAM;AAC/B,MAAI,KAAK,eAAe,GAAG;AACvB,iBAAa,KAAK,eAAe,CAAC;AAClC,SAAK,eAAe,IAAI;AAAA,EAC5B;AACJ;AAaA,IAAI;AAAA;AAAA,EAA2B,WAAY;AACvC,aAASM,WAAU,cAAc,SAAS;AACtC,UAAI,YAAY,QAAQ;AAAE,kBAAU,aAAa,gBAAgB;AAAA,MAAG;AACpE,WAAK,UAAU;AACf,WAAK,YAAY,oBAAI,IAAI;AACzB,WAAK,WAAW;AAChB,WAAK,gBAAgB;AACrB,WAAK,UAAU;AACf,WAAK,QAAQ;AACb,WAAK,kBAAkB;AACvB,UAAI,QAAS,KAAK,QAAQ,aAAa;AAMvC,UAAI,CAAC,wBAAwB,IAAI,KAAK,GAAG;AACrC,gCAAwB,IAAI,OAAO,CAAC;AACpC,mCAA2B,OAAO,OAAO;AACzC,mCAA2B,OAAO,QAAQ;AAC1C,mCAA2B,OAAO,OAAO;AAAA,MAC7C;AAAA,IACJ;AACA,IAAAA,WAAU,UAAU,OAAO,SAAU,OAAO;AACxC,UAAI,gBAAgB,MAAM,iBAAiB,cAAc;AACzD,UAAI,KAAK,aACL,KAAK,kBAAkB,cAAc,WACrC,CAAC,MAAM,KAAK,WAAW,MAAM,SAAS,GAAG;AACzC,wBAAgB,cAAc;AAAA,MAClC;AACA,UAAI,CAAC,MAAM,MAAM,WAAW,KAAK,SAAS,GAAG;AACzC,aAAK,WAAW;AAAA,MACpB;AACA,aAAO,OAAO,MAAM;AAAA,QAChB,UAAU,MAAM;AAAA,QAChB,WAAW,MAAM;AAAA,QACjB,cAAc;AAAA,QACd,eAAe,KAAK,iBAAiB,CAAC;AAAA,QACtC;AAAA,MACJ,CAAC;AACD,UAAI,MAAM,iBAAiB;AACvB,aAAK,mBAAmB,MAAM,eAAe;AAAA,MACjD;AACA,UAAI,MAAM,eAAe;AACrB,aAAK,gBAAgB,MAAM;AAAA,MAC/B;AACA,aAAO;AAAA,IACX;AACA,IAAAA,WAAU,UAAU,QAAQ,WAAY;AACpC,0BAAoB,IAAI;AACxB,WAAK,QAAQ;AAAA,IACjB;AACA,IAAAA,WAAU,UAAU,UAAU,WAAY;AACtC,UAAI,UAAU,KAAK,eAAe;AAClC,UAAI,KAAK,YAAY,MAAM,SAAS,KAAK,SAAS,OAAO,GAAG;AACxD,eAAO,KAAK,SAAS;AAAA,MACzB;AACA,WAAK,YAAY,KAAK,SAAS;AAC/B,UAAI,KAAK,KAAK;AACd,UAAI,MAAM,GAAG,QAAQ,gBAAgB,YAAY;AAC7C,eAAO,EAAE,UAAU,MAAM;AAAA,MAC7B;AACA,UAAI,OAAO,KAAK,MAAM,KAAK,OAAO;AAClC,WAAK,eAAe,MAAM,OAAO;AACjC,aAAO;AAAA,IACX;AACA,IAAAA,WAAU,UAAU,iBAAiB,SAAU,MAAM,SAAS;AAC1D,WAAK,WACD,OACI;AAAA,QACI;AAAA,QACA,SAAS,WAAW,KAAK,eAAe;AAAA,MAC5C,IACE;AAAA,IACd;AACA,IAAAA,WAAU,UAAU,iBAAiB,SAAU,WAAW;AACtD,UAAIC;AACJ,UAAI,cAAc,QAAQ;AAAE,oBAAY,KAAK;AAAA,MAAW;AACxD,aAAO;AAAA,QACH,OAAO,KAAK;AAAA,QACZ;AAAA,QACA,mBAAmB;AAAA,QACnB,YAAY;AAAA,QACZ,kBAAkBA,MAAK,KAAK,qBAAqB,QAAQA,QAAO,SAAS,SAASA,IAAG,QAAQ;AAAA,MACjG;AAAA,IACJ;AACA,IAAAD,WAAU,UAAU,UAAU,SAAU,MAAM;AAC1C,UAAI,QAAQ;AACZ,UAAI,UAAU,KAAK,YAAY,KAAK,SAAS;AAC7C,WAAK,eAAe,IAAI;AACxB,UAAI,CAAC,KAAK,SAAS,CAAC,MAAM,WAAW,QAAQ,QAAQ,QAAQ,KAAK,MAAM,GAAG;AACvE,aAAK,QAAQ;AACb,YAAI,CAAC,KAAK,eAAe;AACrB,eAAK,gBAAgB,WAAW,WAAY;AAAE,mBAAO,MAAM,OAAO;AAAA,UAAG,GAAG,CAAC;AAAA,QAC7E;AAAA,MACJ;AAAA,IACJ;AACA,IAAAA,WAAU,UAAU,qBAAqB,SAAU,IAAI;AACnD,UAAI,QAAQ;AACZ,UAAI,OAAO,KAAK;AACZ;AACJ,UAAI,KAAK,YAAY;AACjB,aAAK,UAAU,OAAO,KAAK,UAAU;AAAA,MACzC;AACA,WAAK,kBAAkB;AACvB,UAAI,IAAI;AACJ,WAAG,WAAW,IAAI;AAClB,aAAK,UAAU,IAAK,KAAK,aAAa,WAAY;AAC9C,cAAI,OAAO,MAAM,QAAQ;AACzB,cAAI,KAAK,2BAA2B;AAMhC,eAAG,SAAS,EAAE;AAAA,UAClB,OACK;AASD,gCAAoB,EAAE;AAAA,UAC1B;AAAA,QACJ,CAAE;AAAA,MACN,OACK;AACD,eAAO,KAAK;AAAA,MAChB;AAAA,IACJ;AACA,IAAAA,WAAU,UAAU,SAAS,WAAY;AACrC,UAAI,QAAQ;AACZ,0BAAoB,IAAI;AACxB,UAAI,KAAK,aAAa,GAAG;AACrB,aAAK,UAAU,QAAQ,SAAU,UAAU;AAAE,iBAAO,SAAS,KAAK;AAAA,QAAG,CAAC;AAAA,MAC1E;AACA,WAAK,QAAQ;AAAA,IACjB;AACA,IAAAA,WAAU,UAAU,eAAe,WAAY;AAC3C,UAAI,CAAC,KAAK,SAAS,CAAC,KAAK,UAAU,MAAM;AACrC,eAAO;AAAA,MACX;AACA,UAAI,yBAAyB,KAAK,aAAa,KAAK,KAAK,iBAAiB;AACtE,YAAI,cAAc,KAAK,gBAAgB,QAAQ;AAC/C,YAAI,gBAAgB,gBAAgB,gBAAgB,qBAAqB;AACrE,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACA,IAAAA,WAAU,UAAU,OAAO,WAAY;AACnC,UAAI,CAAC,KAAK,SAAS;AACf,aAAK,UAAU;AAEf,aAAK,MAAM;AACX,aAAK,OAAO;AAGZ,aAAK,SAASA,WAAU,UAAU;AAClC,YAAI,KAAK,KAAK;AACd,YAAI;AACA,aAAG,YAAY;AAAA,MACvB;AAAA,IACJ;AAGA,IAAAA,WAAU,UAAU,SAAS,WAAY;AAAA,IAAE;AAC3C,IAAAA,WAAU,UAAU,cAAc,SAAU,WAAW;AACnD,UAAI,QAAQ;AACZ,UAAI,cAAc,QAAQ;AAAE,oBAAY,KAAK;AAAA,MAAW;AACxD,UAAI,KAAK,KAAK;AACd,UAAI,MAAM,GAAG,QAAQ,gBAAgB,YAAY;AAC7C;AAAA,MACJ;AACA,UAAI,eAAe,SAAS,SAAS,CAAC,GAAG,KAAK,eAAe,SAAS,CAAC,GAAG,EAAE,SAAS,MAAM,UAAU,SAAU,MAAM;AAAE,eAAO,MAAM,QAAQ,IAAI;AAAA,MAAG,EAAE,CAAC;AACtJ,UAAI,CAAC,KAAK,aAAa,CAAC,MAAM,cAAc,KAAK,SAAS,GAAG;AACzD,aAAK,OAAO;AACZ,aAAK,SAAS,KAAK,MAAM,MAAO,KAAK,YAAY,YAAa;AAAA,MAClE;AAAA,IACJ;AACA,IAAAA,WAAU,UAAU,iBAAiB,WAAY;AAC7C,WAAK,YAAY;AAAA,IACrB;AACA,IAAAA,WAAU,UAAU,cAAc,SAAUE,SAAQ,WAAW;AAC3D,UAAI,YAAY,KAAK;AACrB,aAAO,EAAE;AAAA;AAAA;AAAA,MAIL,UAAU,YAAY,wBAAwB,IAAI,KAAK,KAAK,KAC5D,MAAM,WAAW,UAAU,SAAS,KACpC,MAAMA,QAAO,MAAM,UAAU,OAAO,IAAI;AAAA,IAChD;AACA,IAAAF,WAAU,UAAU,aAAa,SAAUE,SAAQ,UAAU,SAAS,oBAAoB;AACtF,UAAI,QAAQ;AACZ,UAAI,SAAS,IAAI,WAAW;AAC5B,UAAI,gBAAgB,gBAAgBA,QAAO,MAAM,IAAIA,QAAO,OAAO,MAAM,CAAC,IAAI,CAAC;AAG/E,WAAK,MAAM;AACX,UAAI,iBAAiBA,WAAU,gBAAgBA,QAAO,WAAW,GAAG;AAChE,YAAI,aAAa,qBAAqB,KAAK,QAAQ,EAAE,QAAQA,OAAM;AACnE,QAAAA,QAAO,OAAO;AAAA,MAMlB,WACS,aAAaA,WAAUA,QAAO,SAAS;AAC5C,YAAI,OAAO,KAAK,QAAQ;AACxB,QAAAA,QAAO,OAAO,OAAO,MAAM,KAAK,QAAQA,QAAO,IAAI;AAAA,MACvD;AACA,WAAK,gBAAgB;AACrB,UAAI,QAAQ,gBAAgB,YAAY;AACpC,aAAK,eAAe,EAAE,QAAQA,QAAO,MAAM,UAAU,KAAK,GAAG,KAAK,eAAe,QAAQ,SAAS,CAAC;AAAA,MACvG,WACS,uBAAuB,GAAmC;AAC/D,YAAI,kBAAkBA,SAAQ,QAAQ,WAAW,GAAG;AAKhD,eAAK,MAAM,mBAAmB,SAAU,OAAO;AAC3C,gBAAI,MAAM,YAAYA,SAAQ,QAAQ,SAAS,GAAG;AAC9C,oBAAM,WAAW;AAAA,gBACb,OAAO;AAAA,gBACP,MAAMA,QAAO;AAAA,gBACb,WAAW,QAAQ;AAAA,gBACnB,WAAW,uBAAuB;AAAA,cACtC,CAAC;AACD,oBAAM,YAAY;AAAA,gBACd,QAAQA;AAAA,gBACR,WAAW,QAAQ;AAAA,gBACnB,SAAS,wBAAwB,IAAI,MAAM,KAAK;AAAA,cACpD;AAAA,YACJ,OACK;AAiCD,kBAAI,MAAM,YAAY,MAAM,SAAS,KAAK,UAAU;AAGhD,gBAAAA,QAAO,OAAO,MAAM,SAAS,KAAK;AAClC;AAAA,cACJ;AAAA,YAGJ;AACA,gBAAI,cAAc,MAAM,eAAe,QAAQ,SAAS;AACxD,gBAAIC,QAAO,MAAM,KAAK,WAAW;AAOjC,gBAAI,CAAC,MAAM,WAAW,MAAM,MAAM,WAAW,QAAQ,SAAS,GAAG;AAG7D,oBAAM,YAAY,QAAQ,SAAS;AAAA,YACvC;AAMA,kBAAM,eAAeA,OAAM,WAAW;AACtC,gBAAIA,MAAK,UAAU;AACf,cAAAD,QAAO,OAAOC,MAAK;AAAA,YACvB;AAAA,UACJ,CAAC;AAAA,QACL,OACK;AACD,eAAK,YAAY;AAAA,QACrB;AAAA,MACJ;AAAA,IACJ;AACA,IAAAH,WAAU,UAAU,YAAY,WAAY;AACxC,WAAK,eAAe;AACpB,aAAQ,KAAK,gBAAgB,cAAc;AAAA,IAC/C;AACA,IAAAA,WAAU,UAAU,YAAY,SAAU,OAAO;AAC7C,WAAK,gBAAgB,cAAc;AACnC,WAAK,YAAY;AACjB,WAAK,MAAM;AACX,UAAI,MAAM,eAAe;AACrB,aAAK,gBAAgB,MAAM;AAAA,MAC/B;AACA,UAAI,MAAM,cAAc;AACpB,aAAK,eAAe,MAAM;AAAA,MAC9B;AACA,aAAO;AAAA,IACX;AACA,WAAOA;AAAA,EACX,EAAE;AAAA;AAEK,SAAS,kBAAkBI,SAAQ,aAAa;AACnD,MAAI,gBAAgB,QAAQ;AAAE,kBAAc;AAAA,EAAQ;AACpD,MAAI,eAAe,gBAAgB,YAAY,gBAAgB;AAC/D,MAAI,kBAAkB,CAAC,sBAAsBA,OAAM;AACnD,MAAI,CAAC,mBAAmB,gBAAgBA,QAAO,MAAM;AACjD,sBAAkB;AAAA,EACtB;AACA,SAAO;AACX;;;AC7WA,IAAIC,kBAAiB,OAAO,UAAU;AACtC,IAAI;AAAA;AAAA,EAA8B,WAAY;AAC1C,aAASC,cAAaC,KAAI;AACtB,UAAI,QAAQA,IAAG,OAAO,OAAOA,IAAG,MAAMC,kBAAiBD,IAAG,gBAAgB,oBAAoBA,IAAG,mBAAmB,KAAKA,IAAG,oBAAoB,qBAAqB,OAAO,SAAS,QAAQ,IAAI,cAAcA,IAAG,aAAa,KAAKA,IAAG,SAAS,UAAU,OAAO,SAAS,QAAQ,IAAI,KAAKA,IAAG,iBAAiB,kBAAkB,OAAO,SAAS,CAAC,IAAI,IAAI,aAAaA,IAAG,YAAY,KAAKA,IAAG,wBAAwB,yBAAyB,OAAO,SAAS,CAAC,CAAC,MAAM,yBAAyB;AAChe,UAAI,QAAQ;AACZ,WAAK,kBAAkB,CAAC;AAGxB,WAAK,UAAU,oBAAI,IAAI;AAKvB,WAAK,iBAAiB,oBAAI,IAAI;AAC9B,WAAK,iBAAiB,KAAK,gBAAgB,UAAU,KAAK;AAC1D,WAAK,iBAAiB;AACtB,WAAK,mBAAmB;AACxB,WAAK,oBAAoB;AAGzB,WAAK,0BAA0B,oBAAI,IAAI;AACvC,UAAI,2BAA2B,IAAI;AAAA,QAAkB,SAAU,UAAU;AAAE,iBAAO,MAAM,MAAM,kBAAkB,QAAQ;AAAA,QAAG;AAAA;AAAA,QAE3H,EAAE,OAAO,MAAM;AAAA,MAAC;AAChB,WAAK,QAAQ;AACb,WAAK,OAAO;AACZ,WAAK,iBAAiBC,mBAAkB,uBAAO,OAAO,IAAI;AAC1D,WAAK,qBAAqB;AAC1B,WAAK,kBAAkB;AACvB,WAAK,aAAa,cAAc,IAAI,WAAW,EAAE,MAAa,CAAC;AAC/D,WAAK,UAAU;AACf,WAAK,yBAAyB;AAC9B,WAAK,oBACD,oBACI,yBACK,OAAO,iBAAiB,EAKxB,OAAO,wBAAwB,IAClC;AACV,UAAK,KAAK,cAAc,aAAc;AAClC,aAAK,gBAAgB,uBAAO,OAAO,IAAI;AAAA,MAC3C;AAAA,IACJ;AAKA,IAAAF,cAAa,UAAU,OAAO,WAAY;AACtC,UAAI,QAAQ;AACZ,WAAK,QAAQ,QAAQ,SAAU,OAAO,SAAS;AAC3C,cAAM,qBAAqB,OAAO;AAAA,MACtC,CAAC;AACD,WAAK,qBAAqB,kBAAkB,EAAE,CAAC;AAAA,IACnD;AACA,IAAAA,cAAa,UAAU,uBAAuB,SAAU,OAAO;AAC3D,WAAK,eAAe,QAAQ,SAAU,QAAQ;AAAE,eAAO,OAAO,KAAK;AAAA,MAAG,CAAC;AACvE,WAAK,eAAe,MAAM;AAAA,IAC9B;AACA,IAAAA,cAAa,UAAU,SAAS,SAAUC,KAAI;AAC1C,UAAI,IAAI;AACR,UAAI,WAAWA,IAAG,UAAU,YAAYA,IAAG,WAAW,qBAAqBA,IAAG,oBAAoB,gBAAgBA,IAAG,eAAe,KAAKA,IAAG,gBAAgB,iBAAiB,OAAO,SAAS,CAAC,IAAI,IAAI,KAAKA,IAAG,qBAAqB,sBAAsB,OAAO,SAAS,QAAQ,IAAI,oBAAoBA,IAAG,QAAQ,iBAAiBA,IAAG,gBAAgB,KAAKA,IAAG,aAAa,cAAc,OAAO,WAAW,KAAK,KAAK,eAAe,YAAY,QAAQ,OAAO,SAAS,SAAS,GAAG,gBAAgB,iBAAiB,IAAI,KAAKA,IAAG,aAAa,cAAc,OAAO,WAAW,KAAK,KAAK,eAAe,YAAY,QAAQ,OAAO,SAAS,SAAS,GAAG,gBAAgB,SAAS,IAAI,iBAAiBA,IAAG,gBAAgB,UAAUA,IAAG;AACvsB,aAAO,UAAU,MAAM,QAAQ,QAAQ,WAAY;AAC/C,YAAI,YAAYE,mBAAkB,oBAAoBC;AACtD,eAAO,YAAY,MAAM,SAAU,IAAI;AACnC,kBAAQ,GAAG,OAAO;AAAA,YACd,KAAK;AACD,cAAAC,WAAU,UAAU,EAAE;AACtB,cAAAA,WAAU,gBAAgB,kBAAkB,gBAAgB,YAAY,EAAE;AAC1E,2BAAa,KAAK,mBAAmB;AACrC,yBAAW,KAAK,MAAM,iBAAiB,KAAK,UAAU,QAAQ,CAAC;AAC/D,cAAAF,oBAAmB,KAAK,gBAAgB,QAAQ,EAAE;AAClD,0BAAY,KAAK,aAAa,UAAU,SAAS;AACjD,kBAAI,CAACA;AAAkB,uBAAO,CAAC,GAAa,CAAC;AAC7C,qBAAO,CAAC,GAAa,KAAK,WAAW,qBAAqB,UAAU,WAAW,OAAO,CAAC;AAAA,YAC3F,KAAK;AACD,0BAAa,GAAG,KAAK;AACrB,iBAAG,QAAQ;AAAA,YACf,KAAK;AACD,mCAAqB,KAAK,kBACrB,KAAK,cAAc,UAAU,IAAI;AAAA,gBAC9B;AAAA,gBACA;AAAA,gBACA,SAAS;AAAA,gBACT,OAAO;AAAA,cACX;AACJ,kBAAI,oBAAoB;AACpB,qBAAK,uBAAuB,oBAAoB;AAAA,kBAC5C;AAAA,kBACA,UAAU;AAAA,kBACV;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA,QAAQ;AAAA,kBACR;AAAA,gBACJ,CAAC;AAAA,cACL;AACA,mBAAK,iBAAiB;AACtB,cAAAC,QAAO;AACP,qBAAO,CAAC,GAAc,IAAI,QAAQ,SAAU,SAAS,QAAQ;AACrD,uBAAO,SAASA,MAAK,sBAAsB,UAAU,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,mBAAuC,CAAC,GAAG,WAAW,KAAK,GAAG,SAAUE,SAAQ;AACnK,sBAAI,sBAAsBA,OAAM,KAAK,gBAAgB,QAAQ;AACzD,0BAAM,IAAI,YAAY;AAAA,sBAClB,eAAe,2BAA2BA,OAAM;AAAA,oBACpD,CAAC;AAAA,kBACL;AACA,sBAAI,oBAAoB;AACpB,uCAAmB,UAAU;AAC7B,uCAAmB,QAAQ;AAAA,kBAC/B;AACA,sBAAI,cAAc,SAAS,CAAC,GAAGA,OAAM;AACrC,sBAAI,OAAO,mBAAmB,YAAY;AACtC,qCAAiB,eAAe,WAAW;AAAA,kBAC/C;AACA,sBAAI,gBAAgB,YAAY,sBAAsB,WAAW,GAAG;AAChE,2BAAO,YAAY;AAAA,kBACvB;AACA,yBAAOF,MAAK,mBAAmB;AAAA,oBAC3B;AAAA,oBACA,QAAQ;AAAA,oBACR,UAAU;AAAA,oBACV;AAAA,oBACA;AAAA,oBACA;AAAA,oBACA;AAAA,oBACA,QAAQ;AAAA,oBACR;AAAA,oBACA;AAAA,oBACA;AAAA,oBACA,kBAAkB,qBAAqB,aAAa;AAAA,oBACpD;AAAA,oBACA;AAAA,kBACJ,CAAC;AAAA,gBACL,CAAC,EAAE,UAAU;AAAA,kBACT,MAAM,SAAU,aAAa;AACzB,oBAAAA,MAAK,iBAAiB;AAMtB,wBAAI,EAAE,aAAa,gBAAgB,YAAY,YAAY,OAAO;AAC9D,8BAAQ,WAAW;AAAA,oBACvB;AAAA,kBACJ;AAAA,kBACA,OAAO,SAAU,KAAK;AAClB,wBAAI,oBAAoB;AACpB,yCAAmB,UAAU;AAC7B,yCAAmB,QAAQ;AAAA,oBAC/B;AACA,wBAAI,oBAAoB;AACpB,sBAAAA,MAAK,MAAM,iBAAiB,UAAU;AAAA,oBAC1C;AACA,oBAAAA,MAAK,iBAAiB;AACtB,2BAAO,eAAe,cAAc,MAAO,IAAI,YAAY;AAAA,sBACvD,cAAc;AAAA,oBAClB,CAAC,CAAE;AAAA,kBACP;AAAA,gBACJ,CAAC;AAAA,cACL,CAAC,CAAC;AAAA,UACd;AAAA,QACJ,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AACA,IAAAJ,cAAa,UAAU,qBAAqB,SAAU,UAAU,OAAO;AACnE,UAAI,QAAQ;AACZ,UAAI,UAAU,QAAQ;AAAE,gBAAQ,KAAK;AAAA,MAAO;AAC5C,UAAIM,UAAS,SAAS;AACtB,UAAI,cAAc,CAAC;AACnB,UAAI,YAAY,SAAS,gBAAgB;AACzC,UAAI,CAAC,aAAa,kBAAkBA,SAAQ,SAAS,WAAW,GAAG;AAC/D,YAAI,CAAC,kCAAkCA,OAAM,GAAG;AAC5C,sBAAY,KAAK;AAAA,YACb,QAAQA,QAAO;AAAA,YACf,QAAQ;AAAA,YACR,OAAO,SAAS;AAAA,YAChB,WAAW,SAAS;AAAA,UACxB,CAAC;AAAA,QACL;AACA,YAAI,kCAAkCA,OAAM,KACxC,gBAAgBA,QAAO,WAAW,GAAG;AACrC,cAAI,OAAO,MAAM,KAAK;AAAA,YAClB,IAAI;AAAA;AAAA;AAAA;AAAA,YAIJ,OAAO,KAAK,gBAAgB,SAAS,QAAQ,EAAE;AAAA,YAC/C,WAAW,SAAS;AAAA,YACpB,YAAY;AAAA,YACZ,mBAAmB;AAAA,UACvB,CAAC;AACD,cAAI,aAAa;AACjB,cAAI,KAAK,QAAQ;AACb,yBAAa,qBAAqB,KAAK,QAAQA,OAAM;AAAA,UACzD;AACA,cAAI,OAAO,eAAe,aAAa;AAGnC,YAAAA,QAAO,OAAO;AACd,wBAAY,KAAK;AAAA,cACb,QAAQ;AAAA,cACR,QAAQ;AAAA,cACR,OAAO,SAAS;AAAA,cAChB,WAAW,SAAS;AAAA,YACxB,CAAC;AAAA,UACL;AAAA,QACJ;AACA,YAAI,kBAAkB,SAAS;AAC/B,YAAI,iBAAiB;AACjB,eAAK,QAAQ,QAAQ,SAAUL,KAAI,SAAS;AACxC,gBAAI,kBAAkBA,IAAG;AACzB,gBAAI,YAAY,mBAAmB,gBAAgB;AACnD,gBAAI,CAAC,aAAa,CAACF,gBAAe,KAAK,iBAAiB,SAAS,GAAG;AAChE;AAAA,YACJ;AACA,gBAAI,UAAU,gBAAgB,SAAS;AACvC,gBAAI,KAAK,MAAM,QAAQ,IAAI,OAAO,GAAG,WAAW,GAAG,UAAU,YAAY,GAAG;AAE5E,gBAAI,KAAK,MAAM,KAAK;AAAA,cAChB,OAAO;AAAA,cACP;AAAA,cACA,mBAAmB;AAAA,cACnB,YAAY;AAAA,YAChB,CAAC,GAAG,qBAAqB,GAAG,QAAQ,WAAW,GAAG;AAClD,gBAAI,YAAY,oBAAoB;AAEhC,kBAAI,kBAAkB,QAAQ,oBAAoB;AAAA,gBAC9C,gBAAgBO;AAAA,gBAChB,WAAY,YAAY,iBAAiB,QAAQ,KAAM;AAAA,gBACvD,gBAAgB;AAAA,cACpB,CAAC;AAED,kBAAI,iBAAiB;AACjB,4BAAY,KAAK;AAAA,kBACb,QAAQ;AAAA,kBACR,QAAQ;AAAA,kBACR,OAAO;AAAA,kBACP;AAAA,gBACJ,CAAC;AAAA,cACL;AAAA,YACJ;AAAA,UACJ,CAAC;AAAA,QACL;AAAA,MACJ;AACA,UAAI,YAAY,SAAS,KACrB,SAAS,kBACT,SAAS,UACT,SAAS,kBACT,SAAS,kBAAkB;AAC3B,YAAI,YAAY,CAAC;AACjB,aAAK,eAAe;AAAA,UAChB,aAAa,SAAUC,QAAO;AAC1B,gBAAI,CAAC,WAAW;AACZ,0BAAY,QAAQ,SAAU,OAAO;AAAE,uBAAOA,OAAM,MAAM,KAAK;AAAA,cAAG,CAAC;AAAA,YACvE;AAIA,gBAAI,SAAS,SAAS;AAGtB,gBAAI,gBAAgB,CAAC,uBAAuBD,OAAM,KAC7C,kCAAkCA,OAAM,KAAK,CAACA,QAAO;AAC1D,gBAAI,QAAQ;AACR,kBAAI,CAAC,WAAW;AAKZ,oBAAIE,QAAOD,OAAM,KAAK;AAAA,kBAClB,IAAI;AAAA;AAAA;AAAA;AAAA,kBAIJ,OAAO,MAAM,gBAAgB,SAAS,QAAQ,EAAE;AAAA,kBAChD,WAAW,SAAS;AAAA,kBACpB,YAAY;AAAA,kBACZ,mBAAmB;AAAA,gBACvB,CAAC;AACD,oBAAIC,MAAK,UAAU;AACf,kBAAAF,UAAS,SAAS,SAAS,CAAC,GAAGA,OAAM,GAAG,EAAE,MAAME,MAAK,OAAO,CAAC;AAC7D,sBAAI,iBAAiBF,SAAQ;AACzB,2BAAOA,QAAO;AAAA,kBAClB;AACA,sBAAI,aAAaA,SAAQ;AACrB,2BAAOA,QAAO;AAAA,kBAClB;AAAA,gBACJ;AAAA,cACJ;AAIA,kBAAI,eAAe;AACf,uBAAOC,QAAOD,SAAQ;AAAA,kBAClB,SAAS,SAAS;AAAA,kBAClB,WAAW,SAAS;AAAA,gBACxB,CAAC;AAAA,cACL;AAAA,YACJ;AAGA,gBAAI,CAAC,aAAa,CAAC,SAAS,kBAAkB,eAAe;AACzD,cAAAC,OAAM,OAAO;AAAA,gBACT,IAAI;AAAA,gBACJ,QAAQ,SAAU,OAAON,KAAI;AACzB,sBAAI,YAAYA,IAAG,WAAWQ,UAASR,IAAG;AAC1C,yBAAO,cAAc,eAAe,QAAQQ;AAAA,gBAChD;AAAA,cACJ,CAAC;AAAA,YACL;AAAA,UACJ;AAAA,UACA,SAAS,SAAS;AAAA;AAAA,UAElB,YAAY;AAAA;AAAA;AAAA,UAGZ,kBAAkB,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA,UAK3B,gBAAgB,SAAS,kBAAkB;AAAA,QAC/C,CAAC,EAAE,QAAQ,SAAUH,SAAQ;AAAE,iBAAO,UAAU,KAAKA,OAAM;AAAA,QAAG,CAAC;AAC/D,YAAI,SAAS,uBAAuB,SAAS,gBAAgB;AAIzD,iBAAO,QAAQ,IAAI,SAAS,EAAE,KAAK,WAAY;AAAE,mBAAOA;AAAA,UAAQ,CAAC;AAAA,QACrE;AAAA,MACJ;AACA,aAAO,QAAQ,QAAQA,OAAM;AAAA,IACjC;AACA,IAAAN,cAAa,UAAU,yBAAyB,SAAU,oBAAoB,UAAU;AACpF,UAAI,QAAQ;AACZ,UAAI,OAAO,OAAO,uBAAuB,aACrC,mBAAmB,SAAS,SAAS,IACnC;AACN,aAAO,KAAK,MAAM,4BAA4B,SAAU,OAAO;AAC3D,YAAI;AACA,gBAAM,mBAAmB,SAAS,SAAS,CAAC,GAAG,QAAQ,GAAG,EAAE,QAAQ,EAAE,KAAW,EAAE,CAAC,GAAG,KAAK;AAAA,QAChG,SACO,OAAO;AACV,qBAAW,YAAY,SAASK,WAAU,MAAM,KAAK;AAAA,QACzD;AAAA,MACJ,GAAG,SAAS,UAAU;AAAA,IAC1B;AACA,IAAAL,cAAa,UAAU,aAAa,SAAU,SAAS,SAAS,eAAe;AAC3E,aAAO,KAAK,qBAAqB,SAAS,SAAS,aAAa,EAAE,QAC7D;AAAA,IACT;AACA,IAAAA,cAAa,UAAU,gBAAgB,WAAY;AAC/C,UAAI,QAAQ,uBAAO,OAAO,IAAI;AAC9B,WAAK,QAAQ,QAAQ,SAAU,MAAM,SAAS;AAC1C,cAAM,OAAO,IAAI;AAAA,UACb,WAAW,KAAK;AAAA,UAChB,eAAe,KAAK;AAAA,UACpB,cAAc,KAAK;AAAA,UACnB,eAAe,KAAK;AAAA,QACxB;AAAA,MACJ,CAAC;AACD,aAAO;AAAA,IACX;AACA,IAAAA,cAAa,UAAU,cAAc,SAAU,SAAS;AACpD,UAAI,YAAY,KAAK,QAAQ,IAAI,OAAO;AACxC,UAAI,WAAW;AACX,kBAAU,eAAe;AACzB,kBAAU,gBAAgB,CAAC;AAAA,MAC/B;AAAA,IACJ;AACA,IAAAA,cAAa,UAAU,YAAY,SAAU,UAAU;AACnD,aAAO,KAAK,kBAAkB,kBAAkB,QAAQ;AAAA,IAC5D;AACA,IAAAA,cAAa,UAAU,kBAAkB,SAAU,UAAU;AACzD,UAAI,iBAAiB,KAAK;AAC1B,UAAI,CAAC,eAAe,IAAI,QAAQ,GAAG;AAC/B,YAAI,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAMb,kBAAkB,iBAAiB,QAAQ;AAAA,UAC3C,oBAAoB,KAAK,WAAW,qBAAqB,QAAQ;AAAA,UACjE,yBAAyB,cAAc,CAAC,aAAa,GAAG,QAAQ;AAAA,UAChE,aAAa,KAAK,WAAW,YAAY,QAAQ;AAAA,UACjD,aAAa,6BAA6B;AAAA,YACtC,EAAE,MAAM,UAAU,QAAQ,KAAK;AAAA,YAC/B,EAAE,MAAM,aAAa;AAAA,YACrB,EAAE,MAAM,cAAc;AAAA,UAC1B,GAAG,QAAQ;AAAA,UACX,aAAa,iBAAiB,uBAAuB,QAAQ,CAAC;AAAA;AAAA;AAAA,UAG9D,SAAS,SAAS,SAAS,CAAC,GAAG,QAAQ,GAAG,EAAE,aAAa,SAAS,YAAY,IAAI,SAAU,KAAK;AACzF,gBAAI,IAAI,SAAS,yBACb,IAAI,cAAc,SAAS;AAC3B,qBAAO,SAAS,SAAS,CAAC,GAAG,GAAG,GAAG,EAAE,WAAW,QAAQ,CAAC;AAAA,YAC7D;AACA,mBAAO;AAAA,UACX,CAAC,EAAE,CAAC;AAAA,QACZ;AACA,uBAAe,IAAI,UAAU,UAAU;AAAA,MAC3C;AACA,aAAO,eAAe,IAAI,QAAQ;AAAA,IACtC;AACA,IAAAA,cAAa,UAAU,eAAe,SAAU,UAAU,WAAW;AACjE,aAAO,SAAS,SAAS,CAAC,GAAG,KAAK,gBAAgB,QAAQ,EAAE,WAAW,GAAG,SAAS;AAAA,IACvF;AACA,IAAAA,cAAa,UAAU,aAAa,SAAU,SAAS;AACnD,UAAI,QAAQ,KAAK,UAAU,QAAQ,KAAK;AAIxC,gBAAU,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,WAAW,KAAK,aAAa,OAAO,QAAQ,SAAS,EAAE,CAAC;AACpG,UAAI,OAAO,QAAQ,gCAAgC,aAAa;AAC5D,gBAAQ,8BAA8B;AAAA,MAC1C;AACA,UAAI,YAAY,IAAI,UAAU,IAAI;AAClC,UAAI,aAAa,IAAI,gBAAgB;AAAA,QACjC,cAAc;AAAA,QACd;AAAA,QACA;AAAA,MACJ,CAAC;AACD,iBAAW,WAAW,IAAI;AAC1B,WAAK,QAAQ,IAAI,WAAW,SAAS,SAAS;AAG9C,gBAAU,KAAK;AAAA,QACX,UAAU;AAAA,QACV,iBAAiB;AAAA,QACjB,WAAW,WAAW;AAAA,MAC1B,CAAC;AACD,aAAO;AAAA,IACX;AACA,IAAAA,cAAa,UAAU,QAAQ,SAAU,SAAS,SAAS;AACvD,UAAI,QAAQ;AACZ,UAAI,YAAY,QAAQ;AAAE,kBAAU,KAAK,gBAAgB;AAAA,MAAG;AAC5D,MAAAK,WAAU,QAAQ,OAAO,EAAE;AAC3B,MAAAA,WAAU,QAAQ,MAAM,SAAS,YAAY,EAAE;AAC/C,MAAAA,WAAU,CAAC,QAAQ,mBAAmB,EAAE;AACxC,MAAAA,WAAU,CAAC,QAAQ,cAAc,EAAE;AACnC,aAAO,KAAK,WAAW,SAAS,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,OAAO,KAAK,UAAU,QAAQ,KAAK,EAAE,CAAC,CAAC,EAAE,QAAQ,WAAY;AAAE,eAAO,MAAM,UAAU,OAAO;AAAA,MAAG,CAAC;AAAA,IACvK;AACA,IAAAL,cAAa,UAAU,kBAAkB,WAAY;AACjD,aAAO,OAAO,KAAK,gBAAgB;AAAA,IACvC;AACA,IAAAA,cAAa,UAAU,oBAAoB,WAAY;AACnD,aAAO,KAAK;AAAA,IAChB;AACA,IAAAA,cAAa,UAAU,qBAAqB,WAAY;AACpD,aAAO,OAAO,KAAK,mBAAmB;AAAA,IAC1C;AACA,IAAAA,cAAa,UAAU,mBAAmB,SAAU,SAAS;AACzD,WAAK,4BAA4B,OAAO;AACxC,WAAK,iBAAiB;AAAA,IAC1B;AACA,IAAAA,cAAa,UAAU,8BAA8B,SAAU,SAAS;AACpE,UAAI,YAAY,KAAK,QAAQ,IAAI,OAAO;AACxC,UAAI;AACA,kBAAU,KAAK;AAAA,IACvB;AACA,IAAAA,cAAa,UAAU,aAAa,SAAU,SAAS;AACnD,UAAI,YAAY,QAAQ;AAAE,kBAAU;AAAA,UAChC,gBAAgB;AAAA,QACpB;AAAA,MAAG;AAMH,WAAK,qBAAqB,kBAAkB,EAAE,CAAC;AAC/C,WAAK,QAAQ,QAAQ,SAAU,WAAW;AACtC,YAAI,UAAU,iBAAiB;AAG3B,oBAAU,gBAAgB,cAAc;AAAA,QAC5C,OACK;AACD,oBAAU,KAAK;AAAA,QACnB;AAAA,MACJ,CAAC;AACD,UAAI,KAAK,eAAe;AACpB,aAAK,gBAAgB,uBAAO,OAAO,IAAI;AAAA,MAC3C;AAEA,aAAO,KAAK,MAAM,MAAM,OAAO;AAAA,IACnC;AACA,IAAAA,cAAa,UAAU,uBAAuB,SAAU,SAAS;AAC7D,UAAI,QAAQ;AACZ,UAAI,YAAY,QAAQ;AAAE,kBAAU;AAAA,MAAU;AAC9C,UAAI,UAAU,oBAAI,IAAI;AACtB,UAAI,oBAAoB,oBAAI,IAAI;AAChC,UAAI,qBAAqB,oBAAI,IAAI;AACjC,UAAI,MAAM,QAAQ,OAAO,GAAG;AACxB,gBAAQ,QAAQ,SAAU,MAAM;AAC5B,cAAI,OAAO,SAAS,UAAU;AAC1B,8BAAkB,IAAI,MAAM,KAAK;AAAA,UACrC,WACS,eAAe,IAAI,GAAG;AAC3B,8BAAkB,IAAI,MAAM,UAAU,IAAI,GAAG,KAAK;AAAA,UACtD,WACS,gBAAgB,IAAI,KAAK,KAAK,OAAO;AAC1C,+BAAmB,IAAI,IAAI;AAAA,UAC/B;AAAA,QACJ,CAAC;AAAA,MACL;AACA,WAAK,QAAQ,QAAQ,SAAUC,KAAI,SAAS;AACxC,YAAI,KAAKA,IAAG,iBAAiB,WAAWA,IAAG;AAC3C,YAAI,IAAI;AACJ,cAAI,YAAY,OAAO;AACnB,oBAAQ,IAAI,SAAS,EAAE;AACvB;AAAA,UACJ;AACA,cAAI,YAAY,GAAG,WAAW,cAAc,GAAG,QAAQ;AACvD,cAAI,gBAAgB,aACf,YAAY,YAAY,CAAC,GAAG,aAAa,GAAI;AAC9C;AAAA,UACJ;AACA,cAAI,YAAY,YACX,aAAa,kBAAkB,IAAI,SAAS,KAC5C,YAAY,kBAAkB,IAAI,QAAQ,GAAI;AAC/C,oBAAQ,IAAI,SAAS,EAAE;AACvB,gBAAI;AACA,gCAAkB,IAAI,WAAW,IAAI;AACzC,gBAAI;AACA,gCAAkB,IAAI,UAAU,IAAI;AAAA,UAC5C;AAAA,QACJ;AAAA,MACJ,CAAC;AACD,UAAI,mBAAmB,MAAM;AACzB,2BAAmB,QAAQ,SAAU,SAAS;AAI1C,cAAI,UAAU,aAAa,oBAAoB;AAC/C,cAAI,YAAY,MAAM,SAAS,OAAO,EAAE,KAAK;AAAA,YACzC,UAAU,QAAQ;AAAA,YAClB,WAAW,QAAQ;AAAA,UACvB,CAAC;AACD,cAAI,KAAK,IAAI,gBAAgB;AAAA,YACzB,cAAc;AAAA,YACd;AAAA,YACA,SAAS,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,aAAa,eAAe,CAAC;AAAA,UAC5E,CAAC;AACD,UAAAI,WAAU,GAAG,YAAY,OAAO;AAChC,oBAAU,mBAAmB,EAAE;AAC/B,kBAAQ,IAAI,SAAS,EAAE;AAAA,QAC3B,CAAC;AAAA,MACL;AACA,UAAI,WAAW,YAAY,SAAS,kBAAkB,MAAM;AACxD,0BAAkB,QAAQ,SAAU,UAAU,WAAW;AACrD,cAAI,CAAC,UAAU;AACX,uBAAW,YAAY,SAASA,WAAU,KAAK,OAAO,cAAc,WAAW,KAAK,IAAI,SAAS;AAAA,UACrG;AAAA,QACJ,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AACA,IAAAL,cAAa,UAAU,2BAA2B,SAAU,gBAAgB;AACxE,UAAI,QAAQ;AACZ,UAAI,mBAAmB,QAAQ;AAAE,yBAAiB;AAAA,MAAO;AACzD,UAAI,0BAA0B,CAAC;AAC/B,WAAK,qBAAqB,iBAAiB,QAAQ,QAAQ,EAAE,QAAQ,SAAU,iBAAiB,SAAS;AACrG,YAAI,cAAc,gBAAgB,QAAQ;AAC1C,wBAAgB,iBAAiB;AACjC,YAAI,kBACC,gBAAgB,aAAa,gBAAgB,cAAe;AAC7D,kCAAwB,KAAK,gBAAgB,QAAQ,CAAC;AAAA,QAC1D;AACA,cAAM,SAAS,OAAO,EAAE,QAAQ,IAAI;AAAA,MACxC,CAAC;AACD,WAAK,iBAAiB;AACtB,aAAO,QAAQ,IAAI,uBAAuB;AAAA,IAC9C;AACA,IAAAA,cAAa,UAAU,qBAAqB,SAAU,iBAAiB;AACnE,WAAK,SAAS,gBAAgB,OAAO,EAAE,mBAAmB,eAAe;AAAA,IAC7E;AACA,IAAAA,cAAa,UAAU,2BAA2B,SAAUC,KAAI;AAC5D,UAAI,QAAQ;AACZ,UAAI,QAAQA,IAAG,OAAO,cAAcA,IAAG,aAAa,KAAKA,IAAG,aAAa,cAAc,OAAO,SAAS,SAAS,IAAI,YAAYA,IAAG,WAAW,KAAKA,IAAG,SAAS,UAAU,OAAO,SAAS,CAAC,IAAI;AAC9L,cAAQ,KAAK,UAAU,KAAK;AAC5B,kBAAY,KAAK,aAAa,OAAO,SAAS;AAC9C,UAAI,iBAAiB,SAAUS,YAAW;AACtC,eAAO,MAAM,sBAAsB,OAAO,SAASA,UAAS,EAAE,IAAI,SAAUJ,SAAQ;AAChF,cAAI,gBAAgB,YAAY;AAG5B,gBAAI,kBAAkBA,SAAQ,WAAW,GAAG;AACxC,oBAAM,MAAM,MAAM;AAAA,gBACd;AAAA,gBACA,QAAQA,QAAO;AAAA,gBACf,QAAQ;AAAA,gBACR,WAAWI;AAAA,cACf,CAAC;AAAA,YACL;AACA,kBAAM,iBAAiB;AAAA,UAC3B;AACA,cAAI,YAAY,sBAAsBJ,OAAM;AAC5C,cAAI,oBAAoB,+BAA+BA,OAAM;AAC7D,cAAI,aAAa,mBAAmB;AAChC,gBAAI,SAAS,CAAC;AACd,gBAAI,WAAW;AACX,qBAAO,gBAAgBA,QAAO;AAAA,YAClC;AACA,gBAAI,mBAAmB;AACnB,qBAAO,iBAAiBA,QAAO,WAAW,sBAAsB;AAAA,YACpE;AAIA,gBAAI,gBAAgB,UAAU,mBAAmB;AAC7C,oBAAM,IAAI,YAAY,MAAM;AAAA,YAChC;AAAA,UACJ;AACA,cAAI,gBAAgB,UAAU;AAC1B,mBAAOA,QAAO;AAAA,UAClB;AACA,iBAAOA;AAAA,QACX,CAAC;AAAA,MACL;AACA,UAAI,KAAK,gBAAgB,KAAK,EAAE,kBAAkB;AAC9C,YAAI,sBAAsB,KAAK,WAC1B,qBAAqB,OAAO,WAAW,OAAO,EAC9C,KAAK,cAAc;AACxB,eAAO,IAAI,WAAW,SAAU,UAAU;AACtC,cAAI,MAAM;AACV,8BAAoB,KAAK,SAAU,YAAY;AAAE,mBAAQ,MAAM,WAAW,UAAU,QAAQ;AAAA,UAAI,GAAG,SAAS,KAAK;AACjH,iBAAO,WAAY;AAAE,mBAAO,OAAO,IAAI,YAAY;AAAA,UAAG;AAAA,QAC1D,CAAC;AAAA,MACL;AACA,aAAO,eAAe,SAAS;AAAA,IACnC;AACA,IAAAN,cAAa,UAAU,YAAY,SAAU,SAAS;AAClD,WAAK,qBAAqB,OAAO;AACjC,WAAK,iBAAiB;AAAA,IAC1B;AACA,IAAAA,cAAa,UAAU,uBAAuB,SAAU,SAAS;AAC7D,WAAK,4BAA4B,OAAO;AACxC,WAAK,YAAY,OAAO;AAAA,IAC5B;AACA,IAAAA,cAAa,UAAU,cAAc,SAAU,SAAS;AAMpD,WAAK,eAAe,OAAO,OAAO;AAClC,UAAI,KAAK,QAAQ,IAAI,OAAO,GAAG;AAC3B,aAAK,SAAS,OAAO,EAAE,KAAK;AAC5B,aAAK,QAAQ,OAAO,OAAO;AAAA,MAC/B;AAAA,IACJ;AACA,IAAAA,cAAa,UAAU,mBAAmB,WAAY;AAClD,UAAI,KAAK;AACL,aAAK,YAAY;AACrB,WAAK,QAAQ,QAAQ,SAAU,MAAM;AAAE,eAAO,KAAK,OAAO;AAAA,MAAG,CAAC;AAAA,IAClE;AACA,IAAAA,cAAa,UAAU,gBAAgB,WAAY;AAC/C,aAAO,KAAK;AAAA,IAChB;AACA,IAAAA,cAAa,UAAU,wBAAwB,SAAU,OAAO,SAAS,WAEzE,eAAe;AACX,UAAI,QAAQ;AACZ,UAAIC;AACJ,UAAI,kBAAkB,QAAQ;AAAE,yBAAiBA,MAAK,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,wBAAwB,QAAQA,QAAO,SAASA,MAAK,KAAK;AAAA,MAAoB;AAC9L,UAAI;AACJ,UAAI,KAAK,KAAK,gBAAgB,KAAK,GAAG,cAAc,GAAG,aAAa,cAAc,GAAG;AACrF,UAAI,aAAa;AACb,YAAI,KAAK,MAAM,4BAA4B,GAAG,yBAAyB,OAAO,GAAG;AACjF,YAAI,YAAY;AAAA,UACZ,OAAO;AAAA,UACP;AAAA,UACA,eAAe,iBAAiB,WAAW,KAAK;AAAA,UAChD,SAAS,KAAK,eAAe,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,YAAY,CAAC,cAAc,CAAC,CAAC;AAAA,QAChG;AACA,kBAAU,UAAU;AACpB,YAAI,eAAe;AACf,cAAI,uBAAuBU,OAAM,WAAW;AAC5C,cAAI,gBAAgB,0BAA0B,IAAI,oBAAoB,KAAK,oBAAI,IAAI;AACnF,oCAA0B,IAAI,sBAAsB,aAAa;AACjE,cAAI,YAAY,mBAAmB,SAAS;AAC5C,uBAAa,cAAc,IAAI,SAAS;AACxC,cAAI,CAAC,YAAY;AACb,gBAAI,UAAU,IAAI,QAAQ;AAAA,cACtB,QAAQ,MAAM,SAAS;AAAA,YAC3B,CAAC;AACD,0BAAc,IAAI,WAAY,aAAa,OAAQ;AACnD,oBAAQ,WAAW,WAAY;AAC3B,kBAAI,cAAc,OAAO,SAAS,KAAK,cAAc,OAAO,GAAG;AAC3D,0CAA0B,OAAO,oBAAoB;AAAA,cACzD;AAAA,YACJ,CAAC;AAAA,UACL;AAAA,QACJ,OACK;AACD,uBAAa,IAAI,QAAQ;AAAA,YACrB,QAAQ,MAAM,SAAS;AAAA,UAC3B,CAAC;AAAA,QACL;AAAA,MACJ,OACK;AACD,qBAAa,IAAI,QAAQ,CAAC,WAAW,GAAG,EAAE,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;AACtD,kBAAU,KAAK,eAAe,OAAO;AAAA,MACzC;AACA,UAAI,aAAa;AACb,qBAAa,SAAS,YAAY,SAAUL,SAAQ;AAChD,iBAAO,MAAM,WAAW,aAAa;AAAA,YACjC,UAAU;AAAA,YACV,cAAcA;AAAA,YACd;AAAA,YACA;AAAA,UACJ,CAAC;AAAA,QACL,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AACA,IAAAN,cAAa,UAAU,qBAAqB,SAAU,WAAW,oBAAoB,SAAS;AAC1F,UAAI,YAAa,UAAU,gBAAgB,KAAK,kBAAkB;AAIlE,UAAI,eAAe,KAAK,MAAM,iBAAiB,QAAQ,KAAK;AAC5D,aAAO,SAAS,KAAK,sBAAsB,cAAc,QAAQ,SAAS,QAAQ,SAAS,GAAG,SAAUM,SAAQ;AAC5G,YAAI,gBAAgB,2BAA2BA,OAAM;AACrD,YAAI,YAAY,cAAc,SAAS;AAGvC,YAAI,aAAa,UAAU,eAAe;AACtC,cAAI,aAAa,QAAQ,gBAAgB,QAAQ;AAE7C,kBAAM,UAAU,UAAU,IAAI,YAAY;AAAA,cACtC;AAAA,YACJ,CAAC,CAAC;AAAA,UACN;AAIA,oBAAU,WAAWA,SAAQ,cAAc,SAAS,kBAAkB;AACtE,oBAAU,UAAU;AAAA,QACxB;AACA,YAAI,MAAM;AAAA,UACN,MAAMA,QAAO;AAAA,UACb,SAAS;AAAA,UACT,eAAe,cAAc;AAAA,QACjC;AACA,YAAI,aAAa,QAAQ,gBAAgB,UAAU;AAC/C,cAAI,SAAS;AACb,cAAI,gBAAgB,cAAc;AAAA,QACtC;AACA,eAAO;AAAA,MACX,GAAG,SAAU,cAAc;AACvB,YAAI,QAAQ,cAAc,YAAY,IAAI,eAAgB,IAAI,YAAY,EAAE,aAA2B,CAAC;AAExG,YAAI,aAAa,UAAU,eAAe;AACtC,oBAAU,UAAU,KAAK;AAAA,QAC7B;AACA,cAAM;AAAA,MACV,CAAC;AAAA,IACL;AACA,IAAAN,cAAa,UAAU,uBAAuB,SAAU,SAAS,SAIjE,eAAe,OAAO;AAClB,UAAI,QAAQ;AACZ,UAAI,kBAAkB,QAAQ;AAAE,wBAAgB,cAAc;AAAA,MAAS;AACvE,UAAI,UAAU,QAAQ;AAAE,gBAAQ,QAAQ;AAAA,MAAO;AAC/C,UAAI,YAAY,KAAK,aAAa,OAAO,QAAQ,SAAS;AAC1D,UAAI,YAAY,KAAK,SAAS,OAAO;AACrC,UAAI,WAAW,KAAK,eAAe;AACnC,UAAIC,MAAK,QAAQ,aAAa,cAAcA,QAAO,SAAU,YAAY,SAAS,eAAgB,gBAAgBA,KAAI,KAAK,QAAQ,aAAa,cAAc,OAAO,SAAU,YAAY,SAAS,eAAgB,SAAS,IAAI,KAAK,QAAQ,mBAAmB,oBAAoB,OAAO,SAAS,QAAQ,IAAI,KAAK,QAAQ,6BAA6B,8BAA8B,OAAO,SAAS,QAAQ,IAAI,KAAK,QAAQ,SAAS,UAAU,OAAO,SAAS,CAAC,IAAI;AAC1c,UAAI,aAAa,OAAO,OAAO,CAAC,GAAG,SAAS;AAAA,QACxC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACJ,CAAC;AACD,UAAI,gBAAgB,SAAUS,YAAW;AAIrC,mBAAW,YAAYA;AACvB,YAAIE,mBAAkB,MAAM,mBAAmB,WAAW,YAAY,aAAa;AACnF;AAAA;AAAA;AAAA,UAGA,WAAW,gBAAgB;AAAA;AAAA,UAGvBA,iBAAgB,QAAQ,SAAS,KACjC,UAAU;AAAA,UAAiB;AAC3B,oBAAU,gBAAgB,sBAAsB,EAAE,eAAe,OAAO;AAAA,QAC5E;AACA,eAAOA;AAAA,MACX;AAGA,UAAI,kBAAkB,WAAY;AAAE,eAAO,MAAM,eAAe,OAAO,OAAO;AAAA,MAAG;AACjF,WAAK,eAAe,IAAI,SAAS,SAAU,QAAQ;AAC/C,wBAAgB;AAEhB,mBAAW,WAAY;AAAE,iBAAO,QAAQ,OAAO,MAAM;AAAA,QAAG,CAAC;AAAA,MAC7D,CAAC;AACD,UAAI,SAAS;AAQb,UAAI,KAAK,gBAAgB,WAAW,KAAK,EAAE,kBAAkB;AACzD,kBAAU,IAAI,QAAQ,KAAK,WACtB,qBAAqB,WAAW,OAAO,WAAW,WAAW,WAAW,OAAO,EAC/E,KAAK,aAAa,EAClB,KAAK,SAAUA,kBAAiB;AAAE,iBAAOA,iBAAgB;AAAA,QAAS,CAAC,CAAC;AAMzE,+BAAuB;AAAA,MAC3B,OACK;AACD,YAAI,kBAAkB,cAAc,WAAW,SAAS;AACxD,+BAAuB,gBAAgB;AACvC,kBAAU,IAAI,QAAQ,gBAAgB,OAAO;AAAA,MACjD;AACA,cAAQ,QAAQ,KAAK,iBAAiB,eAAe;AACrD,aAAO;AAAA,QACH;AAAA,QACA,UAAU;AAAA,MACd;AAAA,IACJ;AACA,IAAAZ,cAAa,UAAU,iBAAiB,SAAUC,KAAI;AAClD,UAAI,QAAQ;AACZ,UAAI,cAAcA,IAAG,aAAa,UAAUA,IAAG,SAAS,KAAKA,IAAG,YAAY,aAAa,OAAO,SAAS,QAAQ,IAAI,KAAKA,IAAG,kBAAkB,mBAAmB,OAAO,SAAS,aAAa,aAAa,gBAAgB,IAAI,SAAS,IAAI,iBAAiBA,IAAG;AACjQ,UAAI,sBAAsB,oBAAI,IAAI;AAClC,UAAI,SAAS;AACT,aAAK,qBAAqB,OAAO,EAAE,QAAQ,SAAU,IAAI,SAAS;AAC9D,8BAAoB,IAAI,SAAS;AAAA,YAC7B;AAAA,YACA,UAAU,MAAM,SAAS,OAAO,EAAE,QAAQ;AAAA,UAC9C,CAAC;AAAA,QACL,CAAC;AAAA,MACL;AACA,UAAI,UAAU,oBAAI,IAAI;AACtB,UAAI,aAAa;AACb,aAAK,MAAM,MAAM;AAAA,UACb,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UA8BR,YAAa,cAAc,oBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAQhD;AAAA,UACA,gBAAgB,SAAU,OAAO,MAAM,UAAU;AAC7C,gBAAI,KAAK,MAAM,mBAAmB,aAAa,MAAM,QAAQ;AAC7D,gBAAI,IAAI;AACJ,kBAAI,gBAAgB;AAIhB,oCAAoB,OAAO,GAAG,OAAO;AACrC,oBAAIK,UAAS,eAAe,IAAI,MAAM,QAAQ;AAC9C,oBAAIA,YAAW,MAAM;AAGjB,kBAAAA,UAAS,GAAG,QAAQ;AAAA,gBACxB;AAGA,oBAAIA,YAAW,OAAO;AAClB,0BAAQ,IAAI,IAAIA,OAAM;AAAA,gBAC1B;AAGA,uBAAOA;AAAA,cACX;AACA,kBAAI,mBAAmB,MAAM;AAIzB,oCAAoB,IAAI,GAAG,SAAS,EAAE,IAAQ,UAAoB,KAAW,CAAC;AAAA,cAClF;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL;AACA,UAAI,oBAAoB,MAAM;AAC1B,4BAAoB,QAAQ,SAAUL,KAAI,SAAS;AAC/C,cAAI,KAAKA,IAAG,IAAI,WAAWA,IAAG,UAAU,OAAOA,IAAG;AAClD,cAAIK;AAGJ,cAAI,gBAAgB;AAChB,gBAAI,CAAC,MAAM;AACP,kBAAI,OAAO,GAAG,WAAW;AACzB,mBAAK,MAAM;AACX,qBAAO,KAAK,QAAQ;AAAA,YACxB;AACA,YAAAA,UAAS,eAAe,IAAI,MAAM,QAAQ;AAAA,UAC9C;AAEA,cAAI,CAAC,kBAAkBA,YAAW,MAAM;AACpC,YAAAA,UAAS,GAAG,QAAQ;AAAA,UACxB;AACA,cAAIA,YAAW,OAAO;AAClB,oBAAQ,IAAI,IAAIA,OAAM;AAAA,UAC1B;AACA,cAAI,QAAQ,QAAQ,oBAAoB,KAAK,GAAG;AAC5C,kBAAM,qBAAqB,OAAO;AAAA,UACtC;AAAA,QACJ,CAAC;AAAA,MACL;AACA,UAAI,kBAAkB;AAQlB,aAAK,MAAM,iBAAiB,gBAAgB;AAAA,MAChD;AACA,aAAO;AAAA,IACX;AACA,IAAAN,cAAa,UAAU,qBAAqB,SAAU,WAAWC,KAIjE,eAAe;AACX,UAAI,QAAQ;AACZ,UAAI,QAAQA,IAAG,OAAO,YAAYA,IAAG,WAAW,cAAcA,IAAG,aAAa,qBAAqBA,IAAG,oBAAoB,cAAcA,IAAG,aAAa,oBAAoBA,IAAG,mBAAmB,UAAUA,IAAG,SAAS,8BAA8BA,IAAG;AACzP,UAAI,mBAAmB,UAAU;AACjC,gBAAU,KAAK;AAAA,QACX,UAAU;AAAA,QACV;AAAA,QACA;AAAA,MACJ,CAAC;AACD,UAAI,YAAY,WAAY;AAAE,eAAO,UAAU,QAAQ;AAAA,MAAG;AAC1D,UAAI,mBAAmB,SAAUO,OAAMK,gBAAe;AAClD,YAAIA,mBAAkB,QAAQ;AAAE,UAAAA,iBAAgB,UAAU,iBAAiB,cAAc;AAAA,QAAS;AAClG,YAAI,OAAOL,MAAK;AAChB,YAAI,WAAW,YAAY,SAAS,CAAC,qBAAqB,CAAC,MAAM,MAAM,CAAC,CAAC,GAAG;AACxE,gCAAsBA,MAAK,OAAO;AAAA,QACtC;AACA,YAAI,WAAW,SAAUM,OAAM;AAC3B,iBAAO,WAAW,GAAG,SAAS,EAAE,MAAMA,OAAM,SAAS,yBAAyBD,cAAa,GAAG,eAAeA,eAAc,GAAIL,MAAK,WAAW,OAAO,EAAE,SAAS,KAAK,CAAE,CAAC;AAAA,QAC7K;AACA,YAAI,QAAQ,MAAM,gBAAgB,KAAK,EAAE,oBAAoB;AACzD,iBAAO,MAAM,WACR,aAAa;AAAA,YACd,UAAU;AAAA,YACV,cAAc,EAAE,KAAW;AAAA,YAC3B;AAAA,YACA;AAAA,YACA,wBAAwB;AAAA,UAC5B,CAAC,EACI,KAAK,SAAU,UAAU;AAAE,mBAAO,SAAS,SAAS,QAAQ,MAAM;AAAA,UAAG,CAAC;AAAA,QAC/E;AAKA,YAAI,gBAAgB,UAChBK,mBAAkB,cAAc,WAChC,MAAM,QAAQL,MAAK,OAAO,GAAG;AAC7B,iBAAO,SAAS,MAAM;AAAA,QAC1B;AACA,eAAO,SAAS,IAAI;AAAA,MACxB;AACA,UAAI,qBAAqB,gBAAgB,aAAa,IAG/C,kBAAkB,cAAc,WAC/B,uBAAuB,UACvB,IACE;AACV,UAAI,kBAAkB,WAAY;AAC9B,eAAO,MAAM,mBAAmB,WAAW,oBAAoB;AAAA,UAC3D;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACJ,CAAC;AAAA,MACL;AACA,UAAI,eAAe,+BACf,OAAO,qBAAqB,YAC5B,qBAAqB,iBACrB,yBAAyB,aAAa;AAC1C,cAAQ,aAAa;AAAA,QACjB;AAAA,QACA,KAAK,eAAe;AAChB,cAAI,OAAO,UAAU;AACrB,cAAI,KAAK,UAAU;AACf,mBAAO;AAAA,cACH,UAAU;AAAA,cACV,SAAS,CAAC,iBAAiB,MAAM,UAAU,UAAU,CAAC,CAAC;AAAA,YAC3D;AAAA,UACJ;AACA,cAAI,qBAAqB,cAAc;AACnC,mBAAO;AAAA,cACH,UAAU;AAAA,cACV,SAAS,CAAC,iBAAiB,IAAI,GAAG,gBAAgB,CAAC;AAAA,YACvD;AAAA,UACJ;AACA,iBAAO,EAAE,UAAU,MAAM,SAAS,CAAC,gBAAgB,CAAC,EAAE;AAAA,QAC1D;AAAA,QACA,KAAK,qBAAqB;AACtB,cAAI,OAAO,UAAU;AACrB,cAAI,KAAK,YAAY,qBAAqB,cAAc;AACpD,mBAAO;AAAA,cACH,UAAU;AAAA,cACV,SAAS,CAAC,iBAAiB,IAAI,GAAG,gBAAgB,CAAC;AAAA,YACvD;AAAA,UACJ;AACA,iBAAO,EAAE,UAAU,MAAM,SAAS,CAAC,gBAAgB,CAAC,EAAE;AAAA,QAC1D;AAAA,QACA,KAAK;AACD,iBAAO;AAAA,YACH,UAAU;AAAA,YACV,SAAS,CAAC,iBAAiB,UAAU,GAAG,UAAU,UAAU,CAAC,CAAC;AAAA,UAClE;AAAA,QACJ,KAAK;AACD,cAAI,cAAc;AACd,mBAAO;AAAA,cACH,UAAU;AAAA,cACV,SAAS,CAAC,iBAAiB,UAAU,CAAC,GAAG,gBAAgB,CAAC;AAAA,YAC9D;AAAA,UACJ;AACA,iBAAO,EAAE,UAAU,MAAM,SAAS,CAAC,gBAAgB,CAAC,EAAE;AAAA,QAC1D,KAAK;AACD,cAAI,cAAc;AACd,mBAAO;AAAA,cACH,UAAU;AAAA;AAAA;AAAA;AAAA,cAIV,SAAS,CAAC,iBAAiB,UAAU,QAAQ,CAAC,GAAG,gBAAgB,CAAC;AAAA,YACtE;AAAA,UACJ;AACA,iBAAO,EAAE,UAAU,MAAM,SAAS,CAAC,gBAAgB,CAAC,EAAE;AAAA,QAC1D,KAAK;AACD,iBAAO,EAAE,UAAU,OAAO,SAAS,CAAC,EAAE;AAAA,MAC9C;AAAA,IACJ;AACA,IAAAR,cAAa,UAAU,WAAW,SAAU,SAAS;AACjD,UAAI,WAAW,CAAC,KAAK,QAAQ,IAAI,OAAO,GAAG;AACvC,aAAK,QAAQ,IAAI,SAAS,IAAI,UAAU,MAAM,OAAO,CAAC;AAAA,MAC1D;AACA,aAAO,KAAK,QAAQ,IAAI,OAAO;AAAA,IACnC;AACA,IAAAA,cAAa,UAAU,iBAAiB,SAAU,SAAS;AACvD,UAAI,YAAY,QAAQ;AAAE,kBAAU,CAAC;AAAA,MAAG;AACxC,UAAI,aAAa,KAAK,WAAW,eAAe,OAAO;AACvD,aAAO,SAAS,SAAS,CAAC,GAAG,UAAU,GAAG,EAAE,iBAAiB,KAAK,gBAAgB,CAAC;AAAA,IACvF;AACA,WAAOA;AAAA,EACX,EAAE;AAAA;;;ACplCF,IAAI,uBAAuB;AAa3B,IAAI;AAAA;AAAA,EAA8B,WAAY;AA2B1C,aAASe,cAAa,SAAS;AAC3B,UAAI,QAAQ;AACZ,WAAK,sBAAsB,CAAC;AAC5B,WAAK,sBAAsB,CAAC;AAC5B,UAAI,CAAC,QAAQ,OAAO;AAChB,cAAM,kBAAkB,EAAE;AAAA,MAC9B;AACA,UAAI,MAAM,QAAQ,KAAK,cAAc,QAAQ,aAAa,UAAU,QAAQ,SAAS,QAAQ,QAAQ,OAAO,oBAAoB,QAAQ,mBAAmBC,MAAK,QAAQ,SAAS,UAAUA,QAAO,SAAS,QAAQA,KAAI,KAAK,QAAQ,oBAAoB,qBAAqB,OAAO,SAAS,IAAI,IAIjS,KAAK,QAAQ,mBAIb,oBAAoB,OAAO,SAAS,OAAO,WAAW,YAClD,CAAC,OAAO,qBACR,WAAW,YAAY,QAAQ,IAAI,KAAK,QAAQ,oBAAoB,qBAAqB,OAAO,SAAS,OAAO,IAAIC,kBAAiB,QAAQ,gBAAgB,KAAK,QAAQ,wBAAwB,yBAAyB,OAAO,SAAS,MAAM,yBAAyB,IAAI,YAAY,QAAQ,WAAW,WAAW,QAAQ,UAAU,kBAAkB,QAAQ,iBAAiB,sBAAsB,QAAQ,MAAM,yBAAyB,QAAQ;AAC9b,UAAI,OAAO,QAAQ;AACnB,UAAI,CAAC,MAAM;AACP,eACI,MAAM,IAAI,SAAS,EAAE,KAAU,aAA0B,QAAiB,CAAC,IAAI,WAAW,MAAM;AAAA,MACxG;AACA,WAAK,OAAO;AACZ,WAAK,QAAQ;AACb,WAAK,wBAAwB,WAAW,qBAAqB;AAC7D,WAAK,qBAAqB;AAC1B,WAAK,iBAAiBA,mBAAkB,uBAAO,OAAO,IAAI;AAC1D,WAAK,WAAW;AAChB,UAAI,oBAAoB;AACpB,mBAAW,WAAY;AAAE,iBAAQ,MAAM,wBAAwB;AAAA,QAAQ,GAAG,kBAAkB;AAAA,MAChG;AACA,WAAK,aAAa,KAAK,WAAW,KAAK,IAAI;AAC3C,WAAK,QAAQ,KAAK,MAAM,KAAK,IAAI;AACjC,WAAK,SAAS,KAAK,OAAO,KAAK,IAAI;AACnC,WAAK,aAAa,KAAK,WAAW,KAAK,IAAI;AAC3C,WAAK,2BAA2B,KAAK,yBAAyB,KAAK,IAAI;AACvE,WAAK,UAAU;AACf,WAAK,aAAa,IAAI,WAAW;AAAA,QAC7B;AAAA,QACA,QAAQ;AAAA,QACR;AAAA,QACA;AAAA,MACJ,CAAC;AACD,WAAK,eAAe,IAAI,aAAa;AAAA,QACjC,OAAO,KAAK;AAAA,QACZ,MAAM,KAAK;AAAA,QACX,gBAAgB,KAAK;AAAA,QACrB;AAAA,QACA;AAAA,QACA;AAAA,QACA,iBAAiB;AAAA,UACb,MAAM;AAAA,UACN,SAAS;AAAA,QACb;AAAA,QACA,YAAY,KAAK;AAAA,QACjB;AAAA,QACA,aAAa,oBACT,WAAY;AACR,cAAI,MAAM,gBAAgB;AACtB,kBAAM,eAAe;AAAA,cACjB,QAAQ,CAAC;AAAA,cACT,OAAO;AAAA,gBACH,SAAS,MAAM,aAAa,cAAc;AAAA,gBAC1C,WAAW,MAAM,aAAa,iBAAiB,CAAC;AAAA,cACpD;AAAA,cACA,2BAA2B,MAAM,MAAM,QAAQ,IAAI;AAAA,YACvD,CAAC;AAAA,UACL;AAAA,QACJ,IACE;AAAA,MACV,CAAC;AACD,UAAI;AACA,aAAK,kBAAkB;AAAA,IAC/B;AACA,IAAAF,cAAa,UAAU,oBAAoB,WAAY;AACnD,UAAI,OAAO,WAAW,UAAU;AAC5B,YAAI,qBAAqB;AACzB,YAAI,iBAAiB,OAAO,IAAI,iBAAiB;AACjD,SAAC,mBAAmB,cAAc,IAC9B,mBAAmB,cAAc,KAAK,CAAC,GAAG,KAAK,IAAI;AACvD,2BAAmB,oBAAoB;AAAA,MAC3C;AAIA,UAAI,CAAC,wBAAwB,WAAW,YAAY,OAAO;AACvD,+BAAuB;AACvB,mBAAW,WAAY;AACnB,cAAI,OAAO,WAAW,eAClB,OAAO,YACP,OAAO,QAAQ,OAAO,QACtB,CAAC,OAAO,iCAAiC;AACzC,gBAAI,MAAM,OAAO;AACjB,gBAAI,KAAK,OAAO,IAAI;AACpB,gBAAI,MAAM;AACV,gBAAI,OAAO,OAAO,UAAU;AACxB,kBAAI,GAAG,QAAQ,SAAS,IAAI,IAAI;AAC5B,sBACI;AAAA,cAER,WACS,GAAG,QAAQ,UAAU,IAAI,IAAI;AAClC,sBACI;AAAA,cACR;AAAA,YACJ;AACA,gBAAI,KAAK;AACL,yBAAW,YAAY,SAASG,WAAU,IAAI,wEACxB,GAAG;AAAA,YAC7B;AAAA,UACJ;AAAA,QACJ,GAAG,GAAK;AAAA,MACZ;AAAA,IACJ;AACA,WAAO,eAAeH,cAAa,WAAW,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAM/D,KAAK,WAAY;AACb,eAAO,KAAK,aAAa;AAAA,MAC7B;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,IAClB,CAAC;AAKD,IAAAA,cAAa,UAAU,OAAO,WAAY;AACtC,WAAK,aAAa,KAAK;AAAA,IAC3B;AAoBA,IAAAA,cAAa,UAAU,aAAa,SAAU,SAAS;AACnD,UAAI,KAAK,eAAe,YAAY;AAChC,kBAAU,aAAa,KAAK,eAAe,YAAY,OAAO;AAAA,MAClE;AAEA,UAAI,KAAK,0BACJ,QAAQ,gBAAgB,kBACrB,QAAQ,gBAAgB,sBAAsB;AAClD,kBAAU,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,aAAa,cAAc,CAAC;AAAA,MAC5E;AACA,aAAO,KAAK,aAAa,WAAW,OAAO;AAAA,IAC/C;AAUA,IAAAA,cAAa,UAAU,QAAQ,SAAU,SAAS;AAC9C,UAAI,KAAK,eAAe,OAAO;AAC3B,kBAAU,aAAa,KAAK,eAAe,OAAO,OAAO;AAAA,MAC7D;AACA,MAAAG,WAAU,QAAQ,gBAAgB,qBAAqB,EAAE;AACzD,UAAI,KAAK,yBAAyB,QAAQ,gBAAgB,gBAAgB;AACtE,kBAAU,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,aAAa,cAAc,CAAC;AAAA,MAC5E;AACA,aAAO,KAAK,aAAa,MAAM,OAAO;AAAA,IAC1C;AAQA,IAAAH,cAAa,UAAU,SAAS,SAAU,SAAS;AAC/C,UAAI,KAAK,eAAe,QAAQ;AAC5B,kBAAU,aAAa,KAAK,eAAe,QAAQ,OAAO;AAAA,MAC9D;AACA,aAAO,KAAK,aAAa,OAAO,OAAO;AAAA,IAC3C;AAKA,IAAAA,cAAa,UAAU,YAAY,SAAU,SAAS;AAClD,aAAO,KAAK,aAAa,yBAAyB,OAAO;AAAA,IAC7D;AAUA,IAAAA,cAAa,UAAU,YAAY,SAAU,SAAS,YAAY;AAC9D,UAAI,eAAe,QAAQ;AAAE,qBAAa;AAAA,MAAO;AACjD,aAAO,KAAK,MAAM,UAAU,SAAS,UAAU;AAAA,IACnD;AAeA,IAAAA,cAAa,UAAU,eAAe,SAAU,SAAS,YAAY;AACjE,UAAI,eAAe,QAAQ;AAAE,qBAAa;AAAA,MAAO;AACjD,aAAO,KAAK,MAAM,aAAa,SAAS,UAAU;AAAA,IACtD;AAMA,IAAAA,cAAa,UAAU,aAAa,SAAU,SAAS;AACnD,UAAI,MAAM,KAAK,MAAM,WAAW,OAAO;AACvC,UAAI,QAAQ,cAAc,OAAO;AAC7B,aAAK,aAAa,iBAAiB;AAAA,MACvC;AACA,aAAO;AAAA,IACX;AAYA,IAAAA,cAAa,UAAU,gBAAgB,SAAU,SAAS;AACtD,UAAI,MAAM,KAAK,MAAM,cAAc,OAAO;AAC1C,UAAI,QAAQ,cAAc,OAAO;AAC7B,aAAK,aAAa,iBAAiB;AAAA,MACvC;AACA,aAAO;AAAA,IACX;AACA,IAAAA,cAAa,UAAU,0BAA0B,SAAU,IAAI;AAC3D,WAAK,iBAAiB;AAAA,IAC1B;AACA,IAAAA,cAAa,UAAU,eAAe,SAAU,SAAS;AACrD,aAAO,QAAQ,KAAK,MAAM,OAAO;AAAA,IACrC;AAiBA,IAAAA,cAAa,UAAU,aAAa,WAAY;AAC5C,UAAI,QAAQ;AACZ,aAAO,QAAQ,QAAQ,EAClB,KAAK,WAAY;AAClB,eAAO,MAAM,aAAa,WAAW;AAAA,UACjC,gBAAgB;AAAA,QACpB,CAAC;AAAA,MACL,CAAC,EACI,KAAK,WAAY;AAAE,eAAO,QAAQ,IAAI,MAAM,oBAAoB,IAAI,SAAU,IAAI;AAAE,iBAAO,GAAG;AAAA,QAAG,CAAC,CAAC;AAAA,MAAG,CAAC,EACvG,KAAK,WAAY;AAAE,eAAO,MAAM,yBAAyB;AAAA,MAAG,CAAC;AAAA,IACtE;AAKA,IAAAA,cAAa,UAAU,aAAa,WAAY;AAC5C,UAAI,QAAQ;AACZ,aAAO,QAAQ,QAAQ,EAClB,KAAK,WAAY;AAClB,eAAO,MAAM,aAAa,WAAW;AAAA,UACjC,gBAAgB;AAAA,QACpB,CAAC;AAAA,MACL,CAAC,EACI,KAAK,WAAY;AAAE,eAAO,QAAQ,IAAI,MAAM,oBAAoB,IAAI,SAAU,IAAI;AAAE,iBAAO,GAAG;AAAA,QAAG,CAAC,CAAC;AAAA,MAAG,CAAC;AAAA,IAChH;AAMA,IAAAA,cAAa,UAAU,eAAe,SAAU,IAAI;AAChD,UAAI,QAAQ;AACZ,WAAK,oBAAoB,KAAK,EAAE;AAChC,aAAO,WAAY;AACf,cAAM,sBAAsB,MAAM,oBAAoB,OAAO,SAAU,GAAG;AAAE,iBAAO,MAAM;AAAA,QAAI,CAAC;AAAA,MAClG;AAAA,IACJ;AAMA,IAAAA,cAAa,UAAU,eAAe,SAAU,IAAI;AAChD,UAAI,QAAQ;AACZ,WAAK,oBAAoB,KAAK,EAAE;AAChC,aAAO,WAAY;AACf,cAAM,sBAAsB,MAAM,oBAAoB,OAAO,SAAU,GAAG;AAAE,iBAAO,MAAM;AAAA,QAAI,CAAC;AAAA,MAClG;AAAA,IACJ;AAaA,IAAAA,cAAa,UAAU,2BAA2B,SAAU,gBAAgB;AACxE,aAAO,KAAK,aAAa,yBAAyB,cAAc;AAAA,IACpE;AAYA,IAAAA,cAAa,UAAU,iBAAiB,SAAU,SAAS;AACvD,UAAI,MAAM,KAAK,aAAa,eAAe,OAAO;AAClD,UAAI,UAAU,CAAC;AACf,UAAI,UAAU,CAAC;AACf,UAAI,QAAQ,SAAUI,SAAQ,UAAU;AACpC,gBAAQ,KAAK,QAAQ;AACrB,gBAAQ,KAAKA,OAAM;AAAA,MACvB,CAAC;AACD,UAAIA,UAAS,QAAQ,IAAI,OAAO;AAGhC,MAAAA,QAAO,UAAU;AACjB,MAAAA,QAAO,UAAU;AAIjB,MAAAA,QAAO,MAAM,SAAU,OAAO;AAC1B,mBAAW,YAAY,SAASD,WAAU,MAAM,IAAI,KAAK;AAAA,MAC7D,CAAC;AACD,aAAOC;AAAA,IACX;AAYA,IAAAJ,cAAa,UAAU,uBAAuB,SAAU,SAAS;AAC7D,UAAI,YAAY,QAAQ;AAAE,kBAAU;AAAA,MAAU;AAC9C,aAAO,KAAK,aAAa,qBAAqB,OAAO;AAAA,IACzD;AAIA,IAAAA,cAAa,UAAU,UAAU,SAAU,YAAY;AACnD,aAAO,KAAK,MAAM,QAAQ,UAAU;AAAA,IACxC;AAQA,IAAAA,cAAa,UAAU,UAAU,SAAU,iBAAiB;AACxD,aAAO,KAAK,MAAM,QAAQ,eAAe;AAAA,IAC7C;AAIA,IAAAA,cAAa,UAAU,eAAe,SAAU,WAAW;AACvD,WAAK,WAAW,aAAa,SAAS;AAAA,IAC1C;AAIA,IAAAA,cAAa,UAAU,eAAe,SAAU,WAAW;AACvD,WAAK,WAAW,aAAa,SAAS;AAAA,IAC1C;AAIA,IAAAA,cAAa,UAAU,eAAe,WAAY;AAC9C,aAAO,KAAK,WAAW,aAAa;AAAA,IACxC;AAIA,IAAAA,cAAa,UAAU,+BAA+B,SAAU,iBAAiB;AAC7E,WAAK,WAAW,mBAAmB,eAAe;AAAA,IACtD;AAIA,IAAAA,cAAa,UAAU,UAAU,SAAU,SAAS;AAChD,WAAK,OAAO,KAAK,aAAa,OAAO;AAAA,IACzC;AACA,WAAOA;AAAA,EACX,EAAE;AAAA;;;ACxdF,aAAa,WAAW,YAAY,QAAQ,QAAQ,QAAQ;",
  "names": ["InvariantError", "invariant", "_a", "value", "invariant", "_a", "invariant", "root", "_a", "result", "invariant", "invariant", "_a", "stringify", "result", "invariant", "_a", "DocumentTransform", "invariant", "print", "result", "invariant", "hasOwnProperty", "DeepMerger", "result", "Subscription", "SubscriptionObserver", "Observable", "forEach", "concat", "value", "from", "root", "result", "Symbol", "result", "Concast", "result", "_a", "sources", "result", "_a", "result", "result", "invariant", "result", "_a", "result", "ApolloLink", "invariant", "_a", "result", "err", "ApolloError", "_a", "hasOwnProperty", "_a", "result", "print", "_a", "print", "version", "_b", "invariant", "_c", "parseError", "HttpLink", "toString", "hasOwnProperty", "defaultMakeData", "forEach", "slice", "hasOwnProperty", "Trie", "isObjRef", "maybe", "Slot", "hasOwnProperty", "dep", "_a", "dep", "hasOwnProperty", "Trie", "wrap", "cache", "ApolloCache", "wrap", "_a", "Cache", "MissingFieldError", "_a", "_a", "result", "EntityStore", "invariant", "from", "_a", "root", "CacheGroup", "EntityStore", "Root", "_a", "Layer", "Stump", "root", "ObjectCanon", "StoreReader", "wrap", "_a", "result", "result", "invariant", "caches", "cache", "from", "invariant", "_a", "d", "_a", "Policies", "existing", "incoming", "invariant", "result", "supertypeSet", "_a", "from", "invariant", "StoreWriter", "_a", "result", "dataId", "context", "invariant", "value", "selectionSet", "from", "_a", "invariant", "InMemoryCache", "wrap", "_a", "invariant", "result", "FragmentRegistry", "wrap", "enqueue", "root", "NetworkStatus", "_a", "hasOwnProperty", "ObservableQuery", "_a", "result", "invariant", "info", "_a", "invariant", "LocalState", "_a", "result", "execute", "invariant", "node", "QueryInfo", "_a", "result", "diff", "result", "hasOwnProperty", "QueryManager", "_a", "defaultOptions", "hasClientExports", "self", "invariant", "result", "cache", "diff", "DELETE", "variables", "print", "sourcesWithInfo", "networkStatus", "data", "ApolloClient", "_a", "defaultOptions", "invariant", "result"]
}
